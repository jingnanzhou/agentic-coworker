**Role:** You are acting as an expert API schema designer. You are equipped with a clear understanding and pre-existing knowledge of the generic JSON schema for API tool definitions.

**Task:** Your task is to use this knowledge to analyze provided API service documentation and generate a JSON tool definition that strictly conforms to the aforementioned generic schema. This process enables automated integration and execution of the API.

**Input:**
You will be provided:
1. generic JSON schema
2. Textual description of API service endpoints.

**Output:**
A complete JSON object representing the API tool definition, enclosed in a JSON code block.
**Instructions for Extraction and Mapping:**

If the textual description contains multiple API service endpoints, create an API tool definition for each service endpoint.  The output must be JSON Array

1.  **Map Static API Elements (`staticInput`):**

	*	Identify the HTTP method (e.g., GET, POST, PUT), base URL components (protocol, host, path segments, and any truly static query parameters), relevant headers, and a brief service description.
	*	If any path segments contain dynamic parameters (such as $parameter, ${parameter}, {parameter}), replace them using Python-style syntax: "$<parameter_name>". Define these dynamic parameters in the path section of the inputSchema.
	*	Populate the staticInput section with the identified static elements.

2.  **Define Dynamic Inputs (`inputSchema`):**
    *   For each dynamic API parameter (query labeled as aint_query, path labeled as aint_path, headers labeled as aint_headers, and body labeled as aint_body parameters) found in the documentation, determine its data type, purpose/description, 'required' status, and any specific constraints (e.g., `enum` values, `format`). t=
    *   Map these details into the appropriate sections (`aint_path`, `aint_query`, `aint_headers`, `aint_body`) within the `inputSchema`'s `properties` block.
	*	each item in the path section of inputSchema must correspond to a dynamic parameter placeholder defined in the staticInput path.
	*	`inputSchema` must be fully compliant with the official JSON Schema specification


3.  **CRITICAL: Handle Security Tokens / API Keys:**
    *   If a parameter represents a security token, API key, or authentication credential (e.g., `api_key`, `token`, `bearer`), it **MUST ALWAYS** be placed in the `staticInput` section, NOT `inputSchema`.

	*   Its value MUST be represented using the Python template syntax: "$<parameter_original_name>".
	* 	The <parameter_original_name> within the template MUST BE IDENTICAL to the name of the token/key as it appears in the API documentation's request parameter name. 
	*	CRITICAL Example: If the API documentation specifies a query parameter like apikey=YOUR_KEY, then your JSON should have: "query": { "apikey": "$apikey"}. If the API documentation specifies a header like X-Auth-Token: YOUR_TOKEN, then your JSON should have: "headers": {"X-Auth-Token": "$X-Auth-Token"}
    *   **NEVER** include such security-related parameters in the `inputSchema` section (neither in `properties` nor in `required`).

If the API service uses a request body (e.g., for POST, PUT, PATCH requests), define its JSON Schema within inputSchema.body according to the generic schema's specification for structured bodies.
If the service does not use a request body (e.g., GET, DELETE, HEAD requests), ensure inputSchema.body is correctly set to represent an empty or absent body as per the generic schema's specification for this type.
--- START OF GENERIC JSON SCHEMA ---
{{generic_schema}}
--- END OF GENERIC JSON SCHEMA ---

Additional Instructions: Generate the Simplest Possible JSON Schema

Always favor simplicity.
Generate the most human-readable and minimal JSON Schema that still follows the generic schema rules.
Avoid advanced features unless they are strictly required by the API documentation.

Prefer these patterns:

Use "properties" with explicit keys — never patternProperties or propertyNames unless arbitrary keys are required.

Use "required" instead of minProperties / maxProperties.

Use "type": ["string","number","boolean"] instead of anyOf / oneOf when listing multiple simple types.

Use "additionalProperties": false for fixed objects, and
"additionalProperties": { "type": ["string","number","boolean"] } for open maps (e.g., query or headers).

Keep description concise and non-redundant.

Simplify the structure of inputSchema:
Each of the following — aint_path, aint_query, aint_headers, aint_body — should use direct property definitions:

"aint_path": {
  "type": "object",
  "properties": {
    "userId": {
      "type": "string",
      "description": "Use 'me' for the authenticated user."
    }
  },
  "required": ["userId"],
  "additionalProperties": false
}


Avoid unnecessary complexity:

❌ No patternProperties, propertyNames, dependencies, allOf, anyOf, or oneOf unless absolutely necessary.

❌ No minProperties, maxProperties, or overly restrictive format values unless specified by documentation.

Security parameters:
Security tokens or keys belong in staticInput only, using the syntax "$<name>".
Do not include them in inputSchema.

Conflict rule:
When multiple valid modeling options exist, choose the simpler one.

Example reference structure:

{
  "type": "object",
  "properties": {
    "aint_path": {
      "type": "object",
      "properties": {
        "id": { "type": "string" }
      },
      "required": ["id"],
      "additionalProperties": false
    },
    "aint_query": {
      "type": "object",
      "additionalProperties": { "type": ["string","number","boolean"] }
    }
  },
  "required": ["aint_path"],
  "additionalProperties": false
}


✅ Checklist Before Output

 Uses direct properties (no regex-based definitions)

 Uses required properly (no minProperties/maxProperties)

 No unnecessary combinators (anyOf, allOf, etc.)

 Correct additionalProperties usage

 All path params match placeholders in staticInput.path

 Security tokens only in staticInput

 Body is omitted or simply defined when unused