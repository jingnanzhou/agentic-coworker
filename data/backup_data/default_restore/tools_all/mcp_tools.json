{
  "default": [
    {
      "name": "generate_greeting",
      "description": "Mutation tool for text generation in content: Generates a personalized greeting message from a provided person name and returns the greeting string for use in salutations or sample messages. Call when you need a simple, polite greeting derived solely from a name and no delivery or storage is required. Do not call when you need to send messages, fill multi-field templates, translate/localize content, or validate arbitrary JSON; use dedicated messaging, templating, translation, or validation tools instead. Requires: name (string, 1\u2013100 UTF-8 characters, plain text); no authentication; provide the exact name spelling as intended in the output. Rules: idempotent and side-effect free; produces a single-line English greeting; rejects empty or out-of-bounds names and returns a validation error without persisting any data. Keywords: personalized greeting, salutation generation, text generation, content drafting, name input, sample message. updated",
      "document": {
        "id": "ace895ed-7090-4925-aebd-5b1227da1968",
        "name": "generate_greeting",
        "appName": "hostdockerinternal5000",
        "tool_type": "system",
        "transport": "http",
        "description": "Mutation tool for text generation in content: Generates a personalized greeting message from a provided person name and returns the greeting string for use in salutations or sample messages. Call when you need a simple, polite greeting derived solely from a name and no delivery or storage is required. Do not call when you need to send messages, fill multi-field templates, translate/localize content, or validate arbitrary JSON; use dedicated messaging, templating, translation, or validation tools instead. Requires: name (string, 1\u2013100 UTF-8 characters, plain text); no authentication; provide the exact name spelling as intended in the output. Rules: idempotent and side-effect free; produces a single-line English greeting; rejects empty or out-of-bounds names and returns a validation error without persisting any data. Keywords: personalized greeting, salutation generation, text generation, content drafting, name input, sample message. updated",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_body"
          ],
          "properties": {
            "aint_body": {
              "type": "object",
              "title": "GreetInput",
              "example": {
                "name": "John Doe"
              },
              "required": [
                "name"
              ],
              "properties": {
                "name": {
                  "type": "string",
                  "title": "Name",
                  "maxLength": 100,
                  "minLength": 1,
                  "description": "Name of the person to greet"
                }
              },
              "description": "Input model for greeting request"
            }
          },
          "description": "Generate a personalized greeting message for a given name.\n    \n    This endpoint demonstrates how to:\n    - Handle JSON request body with Pydantic models\n    - Validate input data\n    - Return structured JSON responses\n    - Log request details for monitoring\n    \n    **Note**: This endpoint does not require authentication for demonstration purposes."
        },
        "staticInput": {
          "url": {
            "host": [
              "host",
              "docker",
              "internal"
            ],
            "path": [
              "samples",
              "greet"
            ],
            "port": "5000",
            "query": {},
            "protocol": "http"
          },
          "method": "POST",
          "headers": {
            "Content-Type": "application/json"
          }
        }
      },
      "canonical_data": {
        "name": "generate_greeting",
        "inputs": {
          "optional": "No optional inputs; only the structured request body with the required name is accepted.",
          "required": [
            {
              "name": "aint_body",
              "description": "The JSON request body object for the greeting operation. It encapsulates the greeting input model and is required to provide the fields needed to generate the greeting."
            },
            {
              "name": "aint_body.name",
              "description": "The person's name to greet (string, 1\u2013100 UTF-8 characters, plain text). This is the sole content used to construct the greeting and must be provided exactly as it should appear in the output."
            }
          ]
        },
        "intent": "Produce a polite, personalized greeting from a provided person name without sending, storing, or templating content.",
        "context": "The tool generates exactly one single-line English greeting derived solely from the provided name, preserving the name's exact spelling. It rejects empty or length-out-of-bounds names with a validation error. The endpoint demonstrates JSON request handling and input validation and returns JSON responses. It may log request details for monitoring. No authentication is required. Use this tool only for greeting generation\u2014not for sending messages, filling multi-field templates, translating/localizing content, or validating arbitrary JSON.",
        "outputs": "On success, returns a single-line English greeting string (as a JSON response) that incorporates the provided name and can be used directly in salutations or sample messages. On invalid input (e.g., missing or out-of-bounds name), returns a validation error response in JSON.",
        "operation": "Generate a personalized greeting message",
        "preconditions": "The request must include a JSON body (aint_body) containing the required name field. The name must be a non-empty string of 1 to 100 UTF-8 characters in plain text. The API endpoint must be reachable; no authentication is required.",
        "postconditions": "No data is created, modified, sent, or stored by the tool. After successful execution, only a generated greeting string is returned, or a validation error is produced on failure; the operation is idempotent and side-effect free with respect to persisted domain state.",
        "business_objects": [
          "person name",
          "greeting message"
        ]
      },
      "tenant": "default",
      "tool_type": "system"
    },
    {
      "name": "get_auth_provider_url",
      "description": "Retrieval tool for obtaining provider authorization URLs in identity: retrieves the OAuth/OIDC authorization URL for a specified authentication provider by name and returns an HTTPS URL to initiate a user authorization flow. Call when you need to start sign-in by directing a user or browser to a provider\u2019s login page in order to later exchange an authorization code for an access token. Do not call when you already have a valid access token, when you need to exchange or refresh tokens, or when you need to list supported providers; use the appropriate token exchange/refresh or provider listing tool instead. Requires: provider_name as a lowercase ASCII identifier (e.g., \"google\", \"github\", \"linkedin\"); no other parameters; expect the result as a single URL string. Rules: treat the returned URL as opaque (do not alter or append query parameters), URLs may embed state/nonce and can be single-use or time-limited, calls are idempotent but may return different URLs per invocation, and this tool performs no authentication and has no side effects beyond retrieval. Keywords: oauth authorization url, oidc, identity provider, sso, login initiation, provider_name, redirect url, authentication.",
      "document": {
        "id": "7b7370f0-f751-4800-b693-fe299e611126",
        "name": "get_auth_provider_url",
        "appName": "hostdockerinternal5000",
        "tool_type": "system",
        "transport": "http",
        "description": "Retrieval tool for obtaining provider authorization URLs in identity: retrieves the OAuth/OIDC authorization URL for a specified authentication provider by name and returns an HTTPS URL to initiate a user authorization flow. Call when you need to start sign-in by directing a user or browser to a provider\u2019s login page in order to later exchange an authorization code for an access token. Do not call when you already have a valid access token, when you need to exchange or refresh tokens, or when you need to list supported providers; use the appropriate token exchange/refresh or provider listing tool instead. Requires: provider_name as a lowercase ASCII identifier (e.g., \"google\", \"github\", \"linkedin\"); no other parameters; expect the result as a single URL string. Rules: treat the returned URL as opaque (do not alter or append query parameters), URLs may embed state/nonce and can be single-use or time-limited, calls are idempotent but may return different URLs per invocation, and this tool performs no authentication and has no side effects beyond retrieval. Keywords: oauth authorization url, oidc, identity provider, sso, login initiation, provider_name, redirect url, authentication.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aint_path": {
              "type": "object",
              "required": [
                "provider_name"
              ],
              "properties": {
                "provider_name": {
                  "type": "string",
                  "description": "The name of the authentication provider such as google, linkedin, github et al to retrieve access token"
                }
              }
            }
          },
          "description": "get authentication provider url by provider name such as google, linkedin, github et al so that agent can use the provider to request access token"
        },
        "staticInput": {
          "url": {
            "host": [
              "host",
              "docker",
              "internal"
            ],
            "path": [
              "auth",
              "providers",
              "${provider_name}"
            ],
            "port": "5000",
            "query": {},
            "protocol": "http"
          },
          "method": "GET",
          "headers": {}
        }
      },
      "canonical_data": {
        "name": "get_auth_provider_url",
        "inputs": {
          "optional": "No optional inputs are supported; only the nested provider_name within aint_path is accepted, and no other parameters (e.g., pagination, filters, additional query data) are used.",
          "required": [
            "aint_path.provider_name: The lowercase ASCII identifier of the target authentication provider (e.g., \"google\", \"github\", \"linkedin\"). It selects which provider\u2019s OAuth/OIDC authorization URL to generate so a user/browser can be redirected to start the authorization flow."
          ]
        },
        "intent": "Provide the OAuth/OIDC authorization URL for a named authentication provider to initiate a user sign-in flow.",
        "context": "Treat the returned URL as opaque; do not modify or append query parameters. URLs may include state/nonce and can be single-use or time-limited. The tool performs no authentication and has no side effects beyond retrieval. It is not for token exchange/refresh or provider discovery. Calls are idempotent but may yield different URLs on each invocation.",
        "outputs": "A single HTTPS authorization URL string for the specified provider. This URL represents the OAuth/OIDC login initiation endpoint for that provider, may embed state/nonce, and can be single-use or time-limited. It is intended to be used as-is (opaque) to redirect a user or open in a browser to begin the authorization flow that later yields an authorization code for token exchange.",
        "operation": "retrieve authorization URL for a specified authentication provider",
        "preconditions": "A provider_name must be supplied within aint_path and formatted as a lowercase ASCII identifier. The call should be made only to initiate a login/authorization flow (not to exchange or refresh tokens, and not to list providers). The API must be reachable; no authentication is required to call this tool.",
        "postconditions": "No system state is modified; the operation is read-only. Upon success, an authorization URL is obtained. Repeated calls are idempotent in effect but may return different URLs.",
        "business_objects": [
          "authentication provider",
          "authorization URL"
        ]
      },
      "tenant": "default",
      "tool_type": "system"
    },
    {
      "name": "compose_email_message",
      "description": "Mutation tool for composing and encoding emails in messaging: Constructs a complete RFC 2822 email message from provided fields (From, To, Subject, Body) and returns a base64url-encoded string for APIs that accept a raw message payload. Call when you need to generate a standards-compliant raw email string to pass to an email sending API. Do not call when you want to actually send, retrieve, or parse emails, or when you need attachments or HTML/multipart content; use the appropriate sending or retrieval/parsing tools instead. Requires recipient (RFC 5322 email address) and email_body (UTF-8 plain text); optional sender (RFC 5322 email address) and subject; output is a single base64url string (RFC 4648 URL-safe, no padding). Rules: if sender is omitted the From header is not set and must be supplied by the sending system; if subject is omitted the Subject header is omitted; the tool only composes and encodes and has no side effects. Keywords: raw email, rfc 2822, base64url, compose email, email api, mime headers, gmail raw, encode message.",
      "document": {
        "id": "31d9937c-cef6-43b3-b53f-5a65918f37c8",
        "name": "compose_email_message",
        "appName": "hostdockerinternal5000",
        "tool_type": "general",
        "transport": "http",
        "description": "Mutation tool for composing and encoding emails in messaging: Constructs a complete RFC 2822 email message from provided fields (From, To, Subject, Body) and returns a base64url-encoded string for APIs that accept a raw message payload. Call when you need to generate a standards-compliant raw email string to pass to an email sending API. Do not call when you want to actually send, retrieve, or parse emails, or when you need attachments or HTML/multipart content; use the appropriate sending or retrieval/parsing tools instead. Requires recipient (RFC 5322 email address) and email_body (UTF-8 plain text); optional sender (RFC 5322 email address) and subject; output is a single base64url string (RFC 4648 URL-safe, no padding). Rules: if sender is omitted the From header is not set and must be supplied by the sending system; if subject is omitted the Subject header is omitted; the tool only composes and encodes and has no side effects. Keywords: raw email, rfc 2822, base64url, compose email, email api, mime headers, gmail raw, encode message.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_body"
          ],
          "properties": {
            "aint_body": {
              "type": "object",
              "title": "EmailRequestBody",
              "required": [
                "recipient",
                "email_body"
              ],
              "properties": {
                "sender": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "title": "Sender",
                  "description": "The sender's email address."
                },
                "subject": {
                  "anyOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "null"
                    }
                  ],
                  "title": "Subject",
                  "description": "The subject of the email."
                },
                "recipient": {
                  "type": "string",
                  "title": "Recipient",
                  "description": "The recipient's email address."
                },
                "email_body": {
                  "type": "string",
                  "title": "Email Body",
                  "description": "The body of the email."
                }
              }
            }
          },
          "description": "Generate an entire email message in RFC 2822 format and base64url encoded string. This format is commonly used by email APIs for sending raw email messages."
        },
        "staticInput": {
          "url": {
            "host": [
              "host",
              "docker",
              "internal"
            ],
            "path": [
              "common",
              "email",
              "raw"
            ],
            "port": "5000",
            "query": {},
            "protocol": "http"
          },
          "method": "POST",
          "headers": {
            "Content-Type": "application/json"
          }
        }
      },
      "canonical_data": {
        "name": "compose_email_message",
        "inputs": {
          "optional": "Within aint_body, sender (RFC 5322 email address) and subject are optional and may be null; when provided they populate the From and Subject headers respectively. If sender is omitted or null, the From header is not set and must be supplied by the sending system. If subject is omitted or null, the Subject header is omitted. No support is provided for attachments, HTML, or multipart content; the body is plain text only.",
          "required": [
            "aint_body: The container object for all email composition fields; required at the top level to supply the data used to build the RFC 2822 message.",
            "aint_body.recipient: The recipient's email address (RFC 5322 format) used to set the To header; required to produce an addressed message.",
            "aint_body.email_body: The plain-text UTF-8 body content of the email; required to populate the message body."
          ]
        },
        "intent": "Create a standards-compliant RFC 2822 email message from provided fields and return it as a base64url-encoded raw payload suitable for email-sending APIs.",
        "context": "Designed to prepare raw email payloads for APIs that accept RFC 2822 messages. The body is plain text only; attachments and HTML/multipart are not supported. Encoding is base64url (URL-safe, unpadded). Header population rules are strict: To is set from recipient; From is only included if sender is provided; Subject is only included if subject is provided. The tool is composition/encoding-only and does not send email.",
        "outputs": "A single string: the complete RFC 2822 email message encoded as base64url (RFC 4648 URL-safe, no padding). This raw encoded payload represents the composed message (including To and, if provided, From and Subject headers, plus the plain-text body) and can be passed directly to email APIs that accept a raw message input.",
        "operation": "compose and base64url-encode an RFC 2822 email message",
        "preconditions": "The caller must provide the top-level aint_body object. Inside it, recipient must be a string representing an RFC 5322-compliant email address, and email_body must be a UTF-8 plain-text string. The tool must be accessible. The operation assumes no attachments, HTML, or multipart content.",
        "postconditions": "A base64url-encoded raw email string is returned representing the composed RFC 2822 message. No sending, retrieval, parsing, or any other side effects occur. If sender was omitted, the output message lacks a From header; if subject was omitted, the output message lacks a Subject header.",
        "business_objects": [
          "RFC 2822 email message",
          "base64url-encoded raw email string"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "list_calendar_events",
      "description": "Retrieval tool for listing events in calendar: Retrieves events from a specified Google Calendar with optional filters for time window, search, event types, attendees inclusion, ordering, and pagination, returning an array of event objects plus pageToken or nextSyncToken for incremental fetch. Call when: you need to enumerate events for a known calendarId, filter by timeMin/timeMax (RFC3339), iCalUID, text query q, eventTypes, or page/sync through results. Do not call when: creating, updating, or deleting events, checking free/busy availability, or fetching a single event by its server-assigned id\u2014use create_calendar_event, update_calendar_event, delete_calendar_event, or get_calendar_event, and use free_busy tools for availability checks. Requires: calendarId (string; 'primary' allowed), optional timeMin and timeMax (RFC3339 timestamps, prefer UTC; timeMin < timeMax; timeMax is upper bound for event start, timeMin is lower bound for event end), timeZone (IANA TZ string), iCalUID (string), q (string), eventTypes (string; one of birthday, default, focusTime, fromGmail, outOfOffice, workingLocation), maxResults (integer up to 2500), orderBy ('startTime' or 'updated'), pageToken (string), updatedMin (RFC3339), singleEvents (boolean), showDeleted (boolean), showHiddenInvitations (boolean), maxAttendees (integer), privateExtendedProperty and sharedExtendedProperty ('propertyName=value' strings), syncToken (string). Rules: If orderBy='startTime', set singleEvents=true; if singleEvents=true, recurring series are expanded into instances; bounds are exclusive; prefer UTC in RFC3339 values; when syncToken is set, do not also set timeMin, timeMax, iCalUID, q, or updatedMin; pagination uses maxResults and pageToken; this is a read-only, idempotent operation. Keywords: google calendar, list events, time range filter, recurring instances, pagination, sync token, attendees, search.",
      "document": {
        "id": "dc2c452e-f7ed-40a4-8a4a-4dc24948dba7",
        "name": "list_calendar_events",
        "appName": "wwwgoogleapiscom",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for listing events in calendar: Retrieves events from a specified Google Calendar with optional filters for time window, search, event types, attendees inclusion, ordering, and pagination, returning an array of event objects plus pageToken or nextSyncToken for incremental fetch. Call when: you need to enumerate events for a known calendarId, filter by timeMin/timeMax (RFC3339), iCalUID, text query q, eventTypes, or page/sync through results. Do not call when: creating, updating, or deleting events, checking free/busy availability, or fetching a single event by its server-assigned id\u2014use create_calendar_event, update_calendar_event, delete_calendar_event, or get_calendar_event, and use free_busy tools for availability checks. Requires: calendarId (string; 'primary' allowed), optional timeMin and timeMax (RFC3339 timestamps, prefer UTC; timeMin < timeMax; timeMax is upper bound for event start, timeMin is lower bound for event end), timeZone (IANA TZ string), iCalUID (string), q (string), eventTypes (string; one of birthday, default, focusTime, fromGmail, outOfOffice, workingLocation), maxResults (integer up to 2500), orderBy ('startTime' or 'updated'), pageToken (string), updatedMin (RFC3339), singleEvents (boolean), showDeleted (boolean), showHiddenInvitations (boolean), maxAttendees (integer), privateExtendedProperty and sharedExtendedProperty ('propertyName=value' strings), syncToken (string). Rules: If orderBy='startTime', set singleEvents=true; if singleEvents=true, recurring series are expanded into instances; bounds are exclusive; prefer UTC in RFC3339 values; when syncToken is set, do not also set timeMin, timeMax, iCalUID, q, or updatedMin; pagination uses maxResults and pageToken; this is a read-only, idempotent operation. Keywords: google calendar, list events, time range filter, recurring instances, pagination, sync token, attendees, search.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_path"
          ],
          "properties": {
            "aint_path": {
              "type": "object",
              "required": [
                "calendarId"
              ],
              "properties": {
                "calendarId": {
                  "type": "string",
                  "description": "Calendar identifier. Use 'primary' for the authenticated user's primary calendar."
                }
              },
              "additionalProperties": false
            },
            "aint_query": {
              "type": "object",
              "properties": {
                "q": {
                  "type": "string",
                  "description": "Free text search across event fields and certain working location properties."
                },
                "iCalUID": {
                  "type": "string",
                  "description": "Event ID in iCalendar format to filter by."
                },
                "orderBy": {
                  "enum": [
                    "startTime",
                    "updated"
                  ],
                  "type": "string",
                  "description": "Order of results."
                },
                "timeMax": {
                  "type": "string",
                  "format": "date-time",
                  "description": "Upper bound (exclusive) for event start time (RFC3339). Must be greater than timeMin if set."
                },
                "timeMin": {
                  "type": "string",
                  "format": "date-time",
                  "description": "Lower bound (exclusive) for event end time (RFC3339). Must be less than timeMax if set."
                },
                "timeZone": {
                  "type": "string",
                  "description": "Time zone used in the response."
                },
                "pageToken": {
                  "type": "string",
                  "description": "Token for the page of results to return."
                },
                "syncToken": {
                  "type": "string",
                  "description": "Token from nextSyncToken to retrieve only entries changed since last sync."
                },
                "eventTypes": {
                  "type": "string",
                  "description": "Event type to return. Acceptable values include: birthday, default, focusTime, fromGmail, outOfOffice, workingLocation. May be repeated by the HTTP client."
                },
                "maxResults": {
                  "type": "integer",
                  "description": "Page size (max 2500). Default 250."
                },
                "updatedMin": {
                  "type": "string",
                  "format": "date-time",
                  "description": "Lower bound for event last modification time (RFC3339)."
                },
                "showDeleted": {
                  "type": "boolean",
                  "description": "Include deleted events. Default false."
                },
                "maxAttendees": {
                  "type": "integer",
                  "description": "Max number of attendees to include per event."
                },
                "singleEvents": {
                  "type": "boolean",
                  "description": "Expand recurring events into instances only. Default false."
                },
                "alwaysIncludeEmail": {
                  "type": "boolean",
                  "description": "Deprecated and ignored."
                },
                "showHiddenInvitations": {
                  "type": "boolean",
                  "description": "Include hidden invitations. Default false."
                },
                "sharedExtendedProperty": {
                  "type": "string",
                  "description": "Constraint propertyName=value. Matches only shared properties. May be repeated."
                },
                "privateExtendedProperty": {
                  "type": "string",
                  "description": "Constraint propertyName=value. Matches only private properties. May be repeated."
                }
              },
              "additionalProperties": false
            }
          },
          "description": "Dynamic inputs for listing events on a calendar.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "www",
              "googleapis",
              "com"
            ],
            "path": [
              "calendar",
              "v3",
              "calendars",
              "$calendarId",
              "events"
            ],
            "protocol": "https"
          },
          "method": "GET",
          "headers": {
            "Accept": "application/json"
          }
        }
      },
      "canonical_data": {
        "name": "list_calendar_events",
        "inputs": {
          "optional": "All other parameters are provided via aint_query and tailor the listing: free text search (q), filter by iCalUID, filter by event type (eventTypes limited to birthday, default, focusTime, fromGmail, outOfOffice, workingLocation; may be repeated by the HTTP client), time window bounds (timeMin/timeMax as RFC3339 timestamps; bounds are exclusive; timeMin < timeMax; prefer UTC; timeMax constrains event start, timeMin constrains event end) and timeZone for response formatting, ordering (orderBy 'startTime' or 'updated'; if 'startTime' is used, singleEvents must be true), pagination (maxResults up to 2500 with default 250, pageToken for next page), incremental sync (syncToken from a prior nextSyncToken; when syncToken is set, do not also set timeMin, timeMax, iCalUID, q, or updatedMin), update-time filter (updatedMin RFC3339), inclusion toggles for deleted events (showDeleted) and hidden invitations (showHiddenInvitations), attendee detail limits (maxAttendees), recurring expansion control (singleEvents; when true, recurring series are expanded into instances), and extended property constraints (privateExtendedProperty or sharedExtendedProperty formatted as 'propertyName=value' and may be repeated). The deprecated alwaysIncludeEmail is accepted but ignored.",
          "required": [
            "aint_path: Required container for path parameters that scopes the request; it must be present to convey which calendar to query.",
            "aint_path.calendarId: The identifier of the calendar whose events are being listed (use 'primary' for the authenticated user's primary calendar); this is needed to target the specific calendar for retrieval."
          ]
        },
        "intent": "Enumerate events from a specified Google Calendar, with optional filters, ordering, and pagination/synchronization support, returning event records and tokens to continue or incrementally sync retrievals.",
        "context": "This tool lists events only; do not use it to create, update, delete, check free/busy, or fetch a single event (use dedicated tools for those operations). Pagination is controlled by maxResults (default 250; max 2500) and pageToken. Incremental synchronization uses syncToken (obtained from nextSyncToken in a prior response) and must not be combined with timeMin, timeMax, iCalUID, q, or updatedMin. Time filters use RFC3339 format and are exclusive bounds; prefer UTC; timeMax applies to event start and timeMin to event end. If orderBy='startTime', singleEvents must be true, which expands recurring series into individual instances. eventTypes and extended property filters may be repeated by the HTTP client. The alwaysIncludeEmail parameter is deprecated and ignored.",
        "outputs": "An array of event objects representing the calendar's events that match the supplied filters and ordering. The response also includes a pagination token (pageToken) to continue listing additional pages of results, or a synchronization token (nextSyncToken) to enable incremental fetches of changes since the last sync. These tokens can be passed back to this tool in subsequent calls.",
        "operation": "list events from a Google Calendar",
        "preconditions": "The aint_path object must be provided and include a valid calendarId (string; 'primary' allowed). If both timeMin and timeMax are supplied, timeMin must be less than timeMax; both are exclusive bounds and must be RFC3339 timestamps (prefer UTC). If orderBy is 'startTime', singleEvents must be true. If syncToken is set, timeMin, timeMax, iCalUID, q, and updatedMin must not be set. eventTypes, if used, must be one of: birthday, default, focusTime, fromGmail, outOfOffice, workingLocation. maxResults must not exceed 2500. The specified calendar must exist and be accessible to the caller.",
        "postconditions": "No changes are made to calendars or events; this is a read-only, idempotent retrieval. Upon success, a set of event objects matching the given filters and ordering is returned. Recurring series are expanded into instances when singleEvents=true. Deleted events and hidden invitations are included only if their respective flags are set. If more results are available, a pageToken is provided to continue pagination; when syncing, a nextSyncToken is returned for incremental subsequent fetches.",
        "business_objects": [
          "Calendar",
          "Calendar Event",
          "Page Token",
          "Sync Token"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "send_email_by_gmail_w_upload",
      "description": "Messaging tool for sending emails in email: Sends an email via the Gmail API media upload endpoint by accepting an RFC 2822 raw MIME message base64url-encoded and returns the Gmail Message metadata (id, threadId, labelIds). Call when: you need to deliver an email as the authenticated Gmail user (userId 'me') with full control over headers and attachments, and optionally attach it to an existing thread or apply labels. Do not call when: you need to read/search/list/modify/delete messages, manage drafts, or send through providers other than Gmail. Requires: user_id (string; 'me' for the authenticated account), raw_mime_base64url (string; RFC 2822 with CRLF line endings, base64url without padding), optional thread_id (string) and label_ids (array of strings); the From address must be authorized for the authenticated user and message size must meet Gmail limits. Rules: sends immediately and is non-idempotent; repeated calls may produce duplicates; if thread_id is set it determines threading; label_ids are applied to the sent message; prefer UTF-8; include valid To, From, and Subject headers. Keywords: gmail api, send email, raw mime, base64url, media upload, message id, thread id, label ids.",
      "document": {
        "id": "24084aa3-4e4c-4e34-86c9-7e2bffd00a9b",
        "name": "send_email_by_gmail_w_upload",
        "appName": "gmailgoogleapiscom",
        "tool_type": "general",
        "transport": "http",
        "description": "Messaging tool for sending emails in email: Sends an email via the Gmail API media upload endpoint by accepting an RFC 2822 raw MIME message base64url-encoded and returns the Gmail Message metadata (id, threadId, labelIds). Call when: you need to deliver an email as the authenticated Gmail user (userId 'me') with full control over headers and attachments, and optionally attach it to an existing thread or apply labels. Do not call when: you need to read/search/list/modify/delete messages, manage drafts, or send through providers other than Gmail. Requires: user_id (string; 'me' for the authenticated account), raw_mime_base64url (string; RFC 2822 with CRLF line endings, base64url without padding), optional thread_id (string) and label_ids (array of strings); the From address must be authorized for the authenticated user and message size must meet Gmail limits. Rules: sends immediately and is non-idempotent; repeated calls may produce duplicates; if thread_id is set it determines threading; label_ids are applied to the sent message; prefer UTF-8; include valid To, From, and Subject headers. Keywords: gmail api, send email, raw mime, base64url, media upload, message id, thread id, label ids.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_path",
            "aint_body"
          ],
          "properties": {
            "aint_body": {
              "type": "object",
              "required": [
                "raw"
              ],
              "properties": {
                "raw": {
                  "type": "string",
                  "description": "RFC 2822 email message, base64url encoded."
                },
                "labelIds": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Labels to add to the sent message."
                },
                "threadId": {
                  "type": "string",
                  "description": "Thread ID to add the message to."
                }
              },
              "description": "Gmail Message to send.",
              "additionalProperties": false
            },
            "aint_path": {
              "type": "object",
              "required": [
                "userId"
              ],
              "properties": {
                "userId": {
                  "type": "string",
                  "description": "Use 'me' for the authenticated user."
                }
              },
              "additionalProperties": false
            },
            "aint_query": {
              "type": "object",
              "additionalProperties": {
                "type": [
                  "string",
                  "number",
                  "boolean"
                ]
              }
            },
            "aint_headers": {
              "type": "object",
              "additionalProperties": {
                "type": [
                  "string",
                  "number",
                  "boolean"
                ]
              }
            }
          },
          "description": "Inputs for Gmail users.messages.send (upload).",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "gmail",
              "googleapis",
              "com"
            ],
            "path": [
              "upload",
              "gmail",
              "v1",
              "users",
              "$userId",
              "messages",
              "send"
            ],
            "protocol": "https"
          },
          "method": "POST",
          "headers": {
            "Content-Type": "application/json"
          }
        }
      },
      "canonical_data": {
        "name": "send_email_by_gmail_w_upload",
        "inputs": {
          "optional": "Within aint_body, 'labelIds' (array of label IDs) can be provided to apply labels to the sent message, and 'threadId' can be provided to attach the message to an existing thread; transport-level 'aint_query' and 'aint_headers' may carry additional query parameters or HTTP headers as supported by the underlying API client. No other fields are accepted beyond those defined.",
          "required": [
            {
              "name": "aint_path",
              "description": "Path parameters identifying the Gmail account to send as, containing userId (use 'me' for the authenticated user). Required to target which Gmail user the message is sent from."
            },
            {
              "name": "aint_body",
              "description": "Body of the request containing the Gmail Message to send. It must include 'raw': the entire email message encoded as base64url (no padding), formatted as RFC 2822 with CRLF line endings, encompassing all headers, body, and any attachments. This provides the actual content that Gmail will deliver."
            }
          ]
        },
        "intent": "Deliver an email through Gmail as the authenticated user by uploading a base64url-encoded raw RFC 2822 MIME message, optionally specifying threading and labels.",
        "context": "This calls Gmail users.messages.send via the media upload endpoint, enabling full control over headers and attachments through a raw MIME payload. Prefer UTF-8 in the message content. The operation sends immediately and is non-idempotent; repeated identical calls can produce duplicates. If threadId is set, threading is determined by that value; labelIds are applied to the sent message. Use 'me' to refer to the authenticated Gmail account. This tool is only for sending messages, not for reading, searching, listing, modifying, deleting messages, or managing drafts, and not for non-Gmail providers.",
        "outputs": "A Gmail Message metadata object for the sent email containing: id (message identifier), threadId (the thread the message belongs to), and labelIds (labels applied to the sent message). These identifiers can be used to reference the message or thread in subsequent Gmail operations.",
        "operation": "Send a Gmail message from a base64url-encoded RFC 2822 MIME payload via the media upload endpoint",
        "preconditions": "The caller must be authenticated as a Gmail user and specify a valid userId (typically 'me'). The 'raw' message must be a valid RFC 2822 email with CRLF line endings, base64url-encoded without padding, and should include valid To, From, and Subject headers. The From address must be authorized for the authenticated user. The total message size and content must meet Gmail limits. If provided, threadId is used by Gmail for threading, and labelIds are strings representing labels to apply.",
        "postconditions": "A new sent message is created and delivered in the specified Gmail account. The message will be attached to the given thread if threadId was provided and will have any specified labelIds applied. The operation is non-idempotent; repeated calls may create duplicate sent messages. No read/search/list/modify or draft management side effects occur.",
        "business_objects": [
          "Gmail Message",
          "RFC 2822 MIME email",
          "Gmail Thread",
          "Gmail Label"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "get_gmail_user_profile",
      "description": "Category tool for retrieval in messaging: Retrieves a Gmail user's profile by user_id and returns structured fields such as email_address, messages_total, threads_total, and history_id for the specified account. Call when you need the signed-in user's Gmail profile or mailbox counts and you have the target user_id (use 'me' for the authenticated user). Do not call when you need to list or read emails, manage threads or labels, or change Gmail settings; use message, thread, label, or settings tools instead. Requires: user_id string as a path parameter (value 'me' allowed), and valid Gmail OAuth authorization with read scope (e.g., gmail.readonly); no body payload or pagination is used. Rules: read-only and idempotent; returns a single profile object; if user_id is 'me' it takes precedence over any other identifier; no side effects beyond network access. Keywords: gmail profile, user identity, email address, mailbox counts, messages total, threads total, history id.",
      "document": {
        "id": "7b486296-7c7f-40a9-b61c-0a3f545dbe68",
        "auth": {
          "provider": "google"
        },
        "name": "get_gmail_user_profile",
        "appName": "gmailgoogleapiscom",
        "tool_type": "general",
        "transport": "http",
        "description": "Category tool for retrieval in messaging: Retrieves a Gmail user's profile by user_id and returns structured fields such as email_address, messages_total, threads_total, and history_id for the specified account. Call when you need the signed-in user's Gmail profile or mailbox counts and you have the target user_id (use 'me' for the authenticated user). Do not call when you need to list or read emails, manage threads or labels, or change Gmail settings; use message, thread, label, or settings tools instead. Requires: user_id string as a path parameter (value 'me' allowed), and valid Gmail OAuth authorization with read scope (e.g., gmail.readonly); no body payload or pagination is used. Rules: read-only and idempotent; returns a single profile object; if user_id is 'me' it takes precedence over any other identifier; no side effects beyond network access. Keywords: gmail profile, user identity, email address, mailbox counts, messages total, threads total, history id.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_path"
          ],
          "properties": {
            "aint_path": {
              "type": "object",
              "required": [
                "userId"
              ],
              "properties": {
                "userId": {
                  "type": "string",
                  "description": "Use 'me' for the authenticated user."
                }
              },
              "additionalProperties": false
            }
          },
          "description": "Dynamic inputs for Gmail users.getProfile.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "gmail",
              "googleapis",
              "com"
            ],
            "path": [
              "gmail",
              "v1",
              "users",
              "$userId",
              "profile"
            ],
            "protocol": "https"
          },
          "method": "GET",
          "headers": {
            "Accept": "application/json"
          }
        }
      },
      "canonical_data": {
        "name": "get_gmail_user_profile",
        "inputs": {
          "optional": "No optional parameters are supported. The schema forbids additional properties, and there is no request body, query string, pagination, or filtering.",
          "required": [
            {
              "name": "aint_path",
              "description": "Container for required path parameters to construct the Gmail users.getProfile request. It is necessary because the API identifies the target account via a path segment rather than a request body."
            },
            {
              "name": "aint_path.userId",
              "description": "The user identifier for the Gmail account whose profile should be retrieved. Use the literal 'me' to target the authenticated user; when 'me' is provided it overrides any other identifier. This value determines which account's profile (email_address, counts, history_id) is returned."
            }
          ]
        },
        "intent": "Retrieve a single Gmail user's profile information, including email address and mailbox counts, using a path-based user identifier.",
        "context": "This is a retrieval-only, idempotent call mapped to Gmail users.getProfile. It returns a single profile object (no pagination). Use 'me' to refer to the authenticated user; this takes precedence over any other identifier. Do not use this tool to list/read emails, manage threads or labels, or change settings\u2014use dedicated message, thread, label, or settings tools instead. The request uses only a path parameter and does not accept a body or additional properties.",
        "outputs": "A single Gmail user profile object containing structured fields such as email_address, messages_total, threads_total, and history_id for the specified account. This object can be used to identify the user (email_address) and to consume mailbox totals and the current history identifier in downstream processes that require these values.",
        "operation": "Retrieve a Gmail user's profile",
        "preconditions": "A valid Gmail OAuth authorization with a read scope (e.g., gmail.readonly) must be present. The request must include the required path parameter userId (within aint_path), where 'me' may be used to refer to the authenticated user. The Gmail API endpoint must be reachable.",
        "postconditions": "Read-only retrieval: no changes are made to the user's Gmail account or settings. After successful execution, exactly one profile object is returned; there are no side effects beyond network access.",
        "business_objects": [
          "Gmail user profile"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "list_google_calendars",
      "description": "Retrieval tool for listing calendars in calendar domain: Retrieves the authenticated user's calendar list entries with optional pagination, access-role filtering, visibility flags, and incremental sync, returning an array of calendars plus paging/sync tokens. Call when you need the set of calendars the user can access, need to paginate through all calendars, or need to fetch only changes since a previous sync token. Do not call when you need calendar events, a specific calendar's details by id, or to create, update, or delete calendars; use event retrieval or calendar mutation tools instead. Requires: active user authorization context and any optional parameters\u2014max_results (integer 1\u2013250), min_access_role (freeBusyReader|reader|writer|owner), page_token (string), show_deleted (boolean), show_hidden (boolean), sync_token (string obtained from a prior successful list). Rules: tokens are opaque; set max_results to control page size; if page_token is provided it continues the current pagination; if sync_token is provided the call returns only changes since that token and may ignore other filters; booleans default false. Keywords: google calendar api, calendar list, list calendars, pagination, sync token, access role, hidden calendars, deleted calendars.",
      "document": {
        "id": "b62da2c0-083e-4867-8cf2-5db836edfbae",
        "name": "list_google_calendars",
        "appName": "wwwgoogleapiscom",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for listing calendars in calendar domain: Retrieves the authenticated user's calendar list entries with optional pagination, access-role filtering, visibility flags, and incremental sync, returning an array of calendars plus paging/sync tokens. Call when you need the set of calendars the user can access, need to paginate through all calendars, or need to fetch only changes since a previous sync token. Do not call when you need calendar events, a specific calendar's details by id, or to create, update, or delete calendars; use event retrieval or calendar mutation tools instead. Requires: active user authorization context and any optional parameters\u2014max_results (integer 1\u2013250), min_access_role (freeBusyReader|reader|writer|owner), page_token (string), show_deleted (boolean), show_hidden (boolean), sync_token (string obtained from a prior successful list). Rules: tokens are opaque; set max_results to control page size; if page_token is provided it continues the current pagination; if sync_token is provided the call returns only changes since that token and may ignore other filters; booleans default false. Keywords: google calendar api, calendar list, list calendars, pagination, sync token, access role, hidden calendars, deleted calendars.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aint_query": {
              "type": "object",
              "properties": {
                "pageToken": {
                  "type": "string",
                  "description": "Token specifying which result page to return."
                },
                "syncToken": {
                  "type": "string",
                  "description": "Token to retrieve only entries changed since the previous list request."
                },
                "maxResults": {
                  "type": "integer",
                  "maximum": 250,
                  "minimum": 1,
                  "description": "Maximum number of entries per page (default 100, max 250)."
                },
                "showHidden": {
                  "type": "boolean",
                  "description": "Whether to include hidden entries (default false)."
                },
                "showDeleted": {
                  "type": "boolean",
                  "description": "Whether to include deleted calendar list entries (default false)."
                },
                "minAccessRole": {
                  "enum": [
                    "freeBusyReader",
                    "owner",
                    "reader",
                    "writer"
                  ],
                  "type": "string",
                  "description": "Minimum access role to filter returned entries."
                }
              },
              "description": "Query parameters.",
              "additionalProperties": false
            }
          },
          "description": "Dynamic inputs for listing the user's calendar list.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "www",
              "googleapis",
              "com"
            ],
            "path": [
              "calendar",
              "v3",
              "users",
              "me",
              "calendarList"
            ],
            "protocol": "https"
          },
          "method": "GET",
          "headers": {
            "Accept": "application/json"
          }
        }
      },
      "canonical_data": {
        "name": "list_google_calendars",
        "inputs": {
          "optional": "All inputs are provided within the optional aint_query object. It can include: pageToken (an opaque token to continue fetching the next page in the current pagination sequence), syncToken (an opaque token to return only entries changed since the last successful list request; when supplied, other filters may be ignored and only changes are returned), maxResults (page size; integer 1\u2013250, default 100), minAccessRole (filter by minimum access role: freeBusyReader|reader|writer|owner), showHidden (boolean; include hidden entries; default false), and showDeleted (boolean; include deleted calendar list entries; default false). These parameters control which calendar list entries are returned and how results are paginated or incrementally synchronized.",
          "required": "none"
        },
        "intent": "Retrieve the authenticated user's list of calendars, with support for pagination, access-role filtering, visibility flags, and incremental synchronization.",
        "context": "This tool lists calendars, not events or specific calendar details. Optional parameters are nested under aint_query; only the defined properties are accepted (no additional properties). Tokens are opaque. Pagination is controlled by maxResults and pageToken; default page size is 100 with a maximum of 250. showHidden and showDeleted default to false. When a syncToken is provided, the call returns only changes since that token and may ignore other filters. minAccessRole restricts results to calendars at or above the specified access level.",
        "outputs": "An array of calendar list entries the user can access, along with paging and sync tokens. The array represents the user's current calendar list (or changes since a provided sync token). The returned pagination token can be used as pageToken to retrieve subsequent pages, and the returned sync token can be used as syncToken for future incremental sync requests.",
        "operation": "List the authenticated user's calendar list entries",
        "preconditions": "An active user authorization context must be present. If provided, maxResults must be between 1 and 250. pageToken and syncToken, if used, must be valid opaque tokens obtained from prior successful responses of this listing operation.",
        "postconditions": "Read-only operation; no calendars are created, updated, or deleted. After success, the client possesses the requested calendar list entries (or changes) and may receive tokens to continue pagination or perform future incremental sync.",
        "business_objects": [
          "calendar list entry",
          "pagination token",
          "sync token"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "get_google_calendar_by_id",
      "description": "Category tool for retrieval in calendar: Retrieves metadata and settings for a specific calendar from the authenticated user's calendar list given a calendar_id, returning fields such as id, summary, description, timeZone, and accessRole. Call when you need to read a single calendar by a known calendar_id or the 'primary' alias to inspect its properties or verify its presence in the user's list. Do not call when you need to enumerate calendars (use list_calendars), modify calendars (use create/update/delete calendar tools), or access events (use event retrieval tools). Requires: calendar_id as a string exactly matching the calendar's identifier (or 'primary'); the user must be authenticated and authorized for the calendar. Rules: read-only and idempotent; operates only on calendars visible to the user; if calendar_id is not found or access is denied, expect a not found or forbidden error; does not return events or change state. Keywords: google calendar, calendar resource, calendarId, retrieve calendar, primary calendar, calendar metadata, access role.",
      "document": {
        "id": "4f6458ea-6573-48e4-8401-856bb07c8002",
        "name": "get_google_calendar_by_id",
        "appName": "wwwgoogleapiscom",
        "tool_type": "general",
        "transport": "http",
        "description": "Category tool for retrieval in calendar: Retrieves metadata and settings for a specific calendar from the authenticated user's calendar list given a calendar_id, returning fields such as id, summary, description, timeZone, and accessRole. Call when you need to read a single calendar by a known calendar_id or the 'primary' alias to inspect its properties or verify its presence in the user's list. Do not call when you need to enumerate calendars (use list_calendars), modify calendars (use create/update/delete calendar tools), or access events (use event retrieval tools). Requires: calendar_id as a string exactly matching the calendar's identifier (or 'primary'); the user must be authenticated and authorized for the calendar. Rules: read-only and idempotent; operates only on calendars visible to the user; if calendar_id is not found or access is denied, expect a not found or forbidden error; does not return events or change state. Keywords: google calendar, calendar resource, calendarId, retrieve calendar, primary calendar, calendar metadata, access role.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_path"
          ],
          "properties": {
            "aint_path": {
              "type": "object",
              "required": [
                "calendarId"
              ],
              "properties": {
                "calendarId": {
                  "type": "string",
                  "description": "Calendar identifier. Use 'primary' for the user's primary calendar."
                }
              },
              "additionalProperties": false
            },
            "aint_query": {
              "type": "object",
              "additionalProperties": {
                "type": [
                  "string",
                  "number",
                  "boolean"
                ]
              }
            },
            "aint_headers": {
              "type": "object",
              "additionalProperties": {
                "type": [
                  "string",
                  "number",
                  "boolean"
                ]
              }
            }
          },
          "description": "Dynamic inputs for CalendarList.get",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "www",
              "googleapis",
              "com"
            ],
            "path": [
              "calendar",
              "v3",
              "users",
              "me",
              "calendarList",
              "$calendarId"
            ],
            "protocol": "https"
          },
          "method": "GET",
          "headers": {
            "Authorization": "Bearer $Authorization"
          }
        }
      },
      "canonical_data": {
        "name": "get_google_calendar_by_id",
        "inputs": {
          "optional": "Optional request-scoped inputs may be supplied via aint_query (arbitrary query parameters) and aint_headers (arbitrary HTTP headers). These are pass-through to the underlying CalendarList.get call and accept string/number/boolean values; none are required for basic retrieval.",
          "required": [
            "aint_path: Object containing the path parameters for the request; it must be provided to form the endpoint path.",
            "aint_path.calendarId: String identifier of the target calendar in the user\u2019s calendar list (use 'primary' for the user\u2019s primary calendar); required to specify which calendar\u2019s metadata to retrieve."
          ]
        },
        "intent": "Retrieve a single calendar\u2019s metadata and settings from the authenticated user\u2019s calendar list by its identifier (including the 'primary' alias).",
        "context": "This maps to Google Calendar CalendarList.get. It returns exactly one calendar list entry (no pagination). The tool operates only on calendars visible to the authenticated user and does not enumerate calendars, modify calendars, or return events. The 'primary' alias is supported as a calendarId. Errors are returned if the calendar is not found or access is denied. Optional aint_query and aint_headers allow pass-through query parameters and headers but are not required.",
        "outputs": "A single calendar list entry object containing calendar metadata and settings (e.g., id, summary, description, timeZone, accessRole). This data represents the calendar as visible in the user\u2019s calendar list and can be used to identify the calendar (via id), inspect its properties, and understand the user\u2019s access level for subsequent operations that require a calendarId.",
        "operation": "retrieve a calendar\u2019s metadata from the user\u2019s calendar list by calendarId",
        "preconditions": "The caller must provide aint_path with a valid calendarId string (or 'primary'). The user must be authenticated and authorized to access the specified calendar, and the calendar must be visible in the user\u2019s calendar list. The underlying Google Calendar API endpoint must be reachable. If the calendarId does not exist for the user or access is not permitted, the call will result in not found or forbidden errors.",
        "postconditions": "Read-only and idempotent: no server-side state is modified. On success, the client receives the calendar\u2019s metadata; no events are returned and no changes are made.",
        "business_objects": [
          "calendar list entry"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "subscribe_google_calendar",
      "description": "Mutation tool for subscribing to calendars in calendar: inserts an existing calendar into the authenticated user's calendar list by creating a subscription entry with optional color, reminder, visibility, and notification settings, and returns the created CalendarList entry resource with applied metadata. Call when the user needs to subscribe to a known calendar by identifier and optionally configure default reminders, email notifications, and display preferences. Do not call when creating a new calendar, unsubscribing/removing a calendar from the list, or updating settings for an already subscribed calendar; use the appropriate create, delete, or update tool instead. Requires calendar_id (string), and if providing background_color or foreground_color use hex format like \"#0088aa\" and set color_rgb_format=true; default_reminders items must have method in [email, popup] and minutes as an integer 0\u201340320 _minutes; notification_settings supports method=email with types eventCreation, eventChange, eventCancellation, eventResponse, or agenda; booleans for hidden and selected must be explicit. Rules: prefer background_color/foreground_color over color_id when both are present; if default_reminders is provided it overrides calendar defaults; ignore color_id when color_rgb_format=true; notification_settings only supports email; operation applies to the authenticated user's calendar list and requires access to the target calendar. Keywords: google calendar api, calendarlist insert, subscribe calendar, calendar subscription, default reminders, notification settings, color rgb format.",
      "document": {
        "id": "eb7542eb-bdca-4389-8224-7fb4fa66d46c",
        "name": "subscribe_google_calendar",
        "appName": "wwwgoogleapiscom",
        "tool_type": "general",
        "transport": "http",
        "description": "Mutation tool for subscribing to calendars in calendar: inserts an existing calendar into the authenticated user's calendar list by creating a subscription entry with optional color, reminder, visibility, and notification settings, and returns the created CalendarList entry resource with applied metadata. Call when the user needs to subscribe to a known calendar by identifier and optionally configure default reminders, email notifications, and display preferences. Do not call when creating a new calendar, unsubscribing/removing a calendar from the list, or updating settings for an already subscribed calendar; use the appropriate create, delete, or update tool instead. Requires calendar_id (string), and if providing background_color or foreground_color use hex format like \"#0088aa\" and set color_rgb_format=true; default_reminders items must have method in [email, popup] and minutes as an integer 0\u201340320 _minutes; notification_settings supports method=email with types eventCreation, eventChange, eventCancellation, eventResponse, or agenda; booleans for hidden and selected must be explicit. Rules: prefer background_color/foreground_color over color_id when both are present; if default_reminders is provided it overrides calendar defaults; ignore color_id when color_rgb_format=true; notification_settings only supports email; operation applies to the authenticated user's calendar list and requires access to the target calendar. Keywords: google calendar api, calendarlist insert, subscribe calendar, calendar subscription, default reminders, notification settings, color rgb format.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_body"
          ],
          "properties": {
            "aint_body": {
              "type": "object",
              "required": [
                "id"
              ],
              "properties": {
                "id": {
                  "type": "string",
                  "description": "Identifier of the calendar."
                },
                "hidden": {
                  "type": "boolean",
                  "description": "Whether the calendar is hidden in the list."
                },
                "colorId": {
                  "type": "string",
                  "description": "Index-based color ID. Superseded by backgroundColor/foregroundColor."
                },
                "selected": {
                  "type": "boolean",
                  "description": "Whether the calendar's content shows in the UI."
                },
                "backgroundColor": {
                  "type": "string",
                  "description": "Hex color like \"#0088aa\". Requires colorRgbFormat=true."
                },
                "foregroundColor": {
                  "type": "string",
                  "description": "Hex color like \"#ffffff\". Requires colorRgbFormat=true."
                },
                "summaryOverride": {
                  "type": "string",
                  "description": "User-defined summary for this calendar."
                },
                "defaultReminders": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "required": [
                      "method",
                      "minutes"
                    ],
                    "properties": {
                      "method": {
                        "enum": [
                          "email",
                          "popup"
                        ],
                        "type": "string",
                        "description": "Reminder delivery method."
                      },
                      "minutes": {
                        "type": "integer",
                        "maximum": 40320,
                        "minimum": 0,
                        "description": "Minutes before event to trigger reminder (0-40320)."
                      }
                    },
                    "additionalProperties": false
                  },
                  "description": "Default reminders for this calendar."
                },
                "notificationSettings": {
                  "type": "object",
                  "properties": {
                    "notifications": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "required": [
                          "method",
                          "type"
                        ],
                        "properties": {
                          "type": {
                            "enum": [
                              "eventCreation",
                              "eventChange",
                              "eventCancellation",
                              "eventResponse",
                              "agenda"
                            ],
                            "type": "string",
                            "description": "Type of notification."
                          },
                          "method": {
                            "enum": [
                              "email"
                            ],
                            "type": "string",
                            "description": "Notification delivery method."
                          }
                        },
                        "additionalProperties": false
                      }
                    }
                  },
                  "description": "Notification settings for this calendar.",
                  "additionalProperties": false
                }
              },
              "description": "CalendarList resource to insert.",
              "additionalProperties": false
            },
            "aint_query": {
              "type": "object",
              "description": "Optional query parameters.",
              "additionalProperties": {
                "type": [
                  "string",
                  "number",
                  "boolean"
                ]
              }
            }
          },
          "description": "Dynamic inputs for CalendarList insert. Optional query parameters and request body resource.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "www",
              "googleapis",
              "com"
            ],
            "path": [
              "calendar",
              "v3",
              "users",
              "me",
              "calendarList"
            ],
            "protocol": "https"
          },
          "method": "POST",
          "headers": {
            "Accept": "application/json",
            "Content-Type": "application/json"
          }
        }
      },
      "canonical_data": {
        "name": "subscribe_google_calendar",
        "inputs": {
          "optional": "Additional fields in aint_body may configure the subscription: hidden and selected booleans to control visibility; summaryOverride for a custom display name; colorId or RGB color fields backgroundColor/foregroundColor (hex like \"#0088aa\"/\"#ffffff\"); when using RGB colors, the query parameter colorRgbFormat=true must be set and colorId is ignored, with background/foreground preferred over colorId if both are supplied. defaultReminders can be provided as an array of objects each with method in [email, popup] and minutes as an integer 0\u201340320; supplying defaultReminders overrides the calendar's defaults. notificationSettings supports only email notifications, with notifications items constrained to type in [eventCreation, eventChange, eventCancellation, eventResponse, agenda] and method=email. aint_query can include optional query parameters (string/number/boolean), such as colorRgbFormat=true, to affect request handling.",
          "required": [
            "aint_body: The request body object representing the CalendarList resource to insert into the user's calendar list. It carries the subscription metadata (e.g., colors, visibility, reminders, notifications) and must at minimum include the target calendar identifier.",
            "aint_body.id: The identifier of the existing calendar to subscribe to; required to specify which calendar is added to the user's CalendarList."
          ]
        },
        "intent": "Subscribe the authenticated user to an existing calendar by inserting a CalendarList entry with optional display, color, reminder, and email notification settings, returning the created subscription resource.",
        "context": "This is a mutating Google Calendar API operation corresponding to CalendarList insert and applies only to the authenticated user's CalendarList. Use it specifically to subscribe to an existing calendar, not to create calendars or to update or remove existing subscriptions. If RGB color fields are used, colorRgbFormat=true must be supplied as a query parameter; when enabled, colorId is ignored and background/foreground colors are preferred. Providing defaultReminders overrides the calendar\u2019s default reminder settings for this subscription. Only email is supported for notificationSettings, with types limited to eventCreation, eventChange, eventCancellation, eventResponse, and agenda. Optional aint_query parameters are accepted as generic string/number/boolean query flags as supported by the API.",
        "outputs": "A created CalendarList entry resource representing the new subscription, including applied metadata such as calendar id, visibility flags, display name override, color settings, default reminders, and email notification settings. This resource can be used by downstream tools that read, update, or delete the CalendarList entry or reference the subscribed calendar by its id.",
        "operation": "Insert a calendar subscription into the user's CalendarList",
        "preconditions": "The caller is authenticated as the user whose CalendarList is being modified. The target calendar identified by aint_body.id exists and the user has access to it. The request body includes aint_body.id and adheres to constraints: if backgroundColor/foregroundColor are provided, they must be valid hex values and the query parameter colorRgbFormat=true must be set; when colorRgbFormat=true, colorId is ignored; if both colorId and background/foreground are present, the RGB colors take precedence. defaultReminders entries, if provided, must each include method in {email, popup} and minutes as an integer within 0\u201340320. notificationSettings.notifications entries, if provided, must each include method=email and type in {eventCreation, eventChange, eventCancellation, eventResponse, agenda}. Any provided hidden and selected fields must be explicit booleans.",
        "postconditions": "A new subscription (CalendarList entry) is created in the authenticated user's CalendarList for the specified calendar, persisted with the provided colors, reminders, notification settings, and visibility preferences. No other calendars are created or removed.",
        "business_objects": [
          "CalendarList entry",
          "Calendar"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "list_google_drive_files",
      "description": "Retrieval tool for listing files in cloud storage: Lists Google Drive files and folders via Drive API v3 with optional search, sorting, spaces, shared drives, and pagination, returning a page of file metadata plus a nextPageToken for continuation. Call when: you need to enumerate or search a user's Google Drive items, filter with a query, scope to a shared drive, or control result order. Do not call when: you need file content download, upload, create, update, delete, or to fetch a single file by id; use the corresponding content or object-specific tool instead. Requires: pass all parameters inside aint_query; use q (string, Google Drive query syntax), corpora ('user'|'domain'|'drive'|'allDrives'), driveId (string) to target a shared drive, includeItemsFromAllDrives (boolean) to include shared drives, orderBy (comma-separated fields with optional ' desc'), pageSize (integer) and pageToken (string) for pagination, spaces ('drive'|'appDataFolder'), supportsAllDrives (boolean) when using shared drive contexts, includePermissionsForView ('published'), includeLabels (comma-separated label IDs). Rules: prefer corpora over deprecated corpus; prefer includeItemsFromAllDrives and supportsAllDrives over deprecated includeTeamDriveItems, supportsTeamDrives, and teamDriveId; if pageSize is set it limits results per page and nextPageToken must be used to iterate; when driveId or includeItemsFromAllDrives is provided, set supportsAllDrives true; orderBy without ' desc' sorts ascending; this operation is read-only and idempotent. Keywords: google drive, files list, search query, shared drives, pagination, order by, corpora, cloud storage.",
      "document": {
        "id": "8051b433-0840-4e06-a9ee-bd2520c26bce",
        "name": "list_google_drive_files",
        "appName": "wwwgoogleapiscom",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for listing files in cloud storage: Lists Google Drive files and folders via Drive API v3 with optional search, sorting, spaces, shared drives, and pagination, returning a page of file metadata plus a nextPageToken for continuation. Call when: you need to enumerate or search a user's Google Drive items, filter with a query, scope to a shared drive, or control result order. Do not call when: you need file content download, upload, create, update, delete, or to fetch a single file by id; use the corresponding content or object-specific tool instead. Requires: pass all parameters inside aint_query; use q (string, Google Drive query syntax), corpora ('user'|'domain'|'drive'|'allDrives'), driveId (string) to target a shared drive, includeItemsFromAllDrives (boolean) to include shared drives, orderBy (comma-separated fields with optional ' desc'), pageSize (integer) and pageToken (string) for pagination, spaces ('drive'|'appDataFolder'), supportsAllDrives (boolean) when using shared drive contexts, includePermissionsForView ('published'), includeLabels (comma-separated label IDs). Rules: prefer corpora over deprecated corpus; prefer includeItemsFromAllDrives and supportsAllDrives over deprecated includeTeamDriveItems, supportsTeamDrives, and teamDriveId; if pageSize is set it limits results per page and nextPageToken must be used to iterate; when driveId or includeItemsFromAllDrives is provided, set supportsAllDrives true; orderBy without ' desc' sorts ascending; this operation is read-only and idempotent. Keywords: google drive, files list, search query, shared drives, pagination, order by, corpora, cloud storage.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aint_query": {
              "type": "object",
              "properties": {
                "q": {
                  "type": "string",
                  "description": "Search query string for filtering files."
                },
                "corpus": {
                  "enum": [
                    "user",
                    "domain"
                  ],
                  "type": "string",
                  "description": "Deprecated: Use corpora instead."
                },
                "spaces": {
                  "enum": [
                    "drive",
                    "appDataFolder"
                  ],
                  "type": "string",
                  "description": "Comma-separated spaces to query."
                },
                "corpora": {
                  "enum": [
                    "user",
                    "domain",
                    "drive",
                    "allDrives"
                  ],
                  "type": "string",
                  "description": "Bodies of items to which the query applies."
                },
                "driveId": {
                  "type": "string",
                  "description": "ID of the shared drive to search."
                },
                "orderBy": {
                  "type": "string",
                  "description": "Comma-separated sort keys; append ' desc' to reverse."
                },
                "pageSize": {
                  "type": "integer",
                  "description": "Maximum number of files per page."
                },
                "pageToken": {
                  "type": "string",
                  "description": "Token to retrieve the next page."
                },
                "teamDriveId": {
                  "type": "string",
                  "description": "Deprecated: Use driveId instead."
                },
                "includeLabels": {
                  "type": "string",
                  "description": "Comma-separated label IDs to include in labelInfo."
                },
                "supportsAllDrives": {
                  "type": "boolean",
                  "description": "Whether the application supports My Drive and shared drives."
                },
                "supportsTeamDrives": {
                  "type": "boolean",
                  "description": "Deprecated: Use supportsAllDrives instead."
                },
                "includeTeamDriveItems": {
                  "type": "boolean",
                  "description": "Deprecated: Use includeItemsFromAllDrives instead."
                },
                "includeItemsFromAllDrives": {
                  "type": "boolean",
                  "description": "Include items from both My Drive and shared drives."
                },
                "includePermissionsForView": {
                  "enum": [
                    "published"
                  ],
                  "type": "string",
                  "description": "Which additional view's permissions to include."
                }
              },
              "description": "Query parameters to filter and paginate file listings.",
              "additionalProperties": false
            }
          },
          "description": "Dynamic input parameters for Google Drive files.list."
        },
        "staticInput": {
          "url": {
            "host": [
              "www",
              "googleapis",
              "com"
            ],
            "path": [
              "drive",
              "v3",
              "files"
            ],
            "protocol": "https"
          },
          "method": "GET",
          "headers": {
            "Accept": "application/json"
          }
        }
      },
      "canonical_data": {
        "name": "list_google_drive_files",
        "inputs": {
          "optional": "All parameters are supplied inside a single aint_query object. It supports Drive API query filtering (search syntax), choosing the item corpus/scope (e.g., user, domain, a specific shared drive, or all drives), selecting spaces (My Drive vs App Data), scoping to a shared drive and optionally including items from shared drives, indicating application support for shared drives when using shared drive contexts, ordering results by specified fields (ascending unless ' desc' is appended), and paginating via page size and continuation token. It can also include extra permission data for the 'published' view and label metadata by specifying label IDs. Deprecated fields for team drives and the single 'corpus' parameter are recognized but should be replaced by the newer shared-drives and 'corpora' parameters.",
          "required": "none"
        },
        "intent": "Provide a read-only, paginated listing of a user's Google Drive items (files and folders) with optional filtering, shared drive scoping, and sorting via Drive API v3.",
        "context": "Listing respects Drive API v3 semantics, including optional query filtering, corpus selection, spaces scoping, and shared drive handling. Prefer modern parameters: corpora over the deprecated corpus, driveId/includeItemsFromAllDrives/supportsAllDrives over the deprecated team drive fields. When driveId or inclusion of shared drive items is used, supportsAllDrives must be true. Sorting via orderBy is ascending by default and reverses only when ' desc' is appended. Pagination is controlled by pageSize; when pageSize limits results, nextPageToken must be used to iterate through subsequent pages. If includeLabels is provided, labelInfo is included in results; if includePermissionsForView='published' is set, published-view permissions are included. The tool is retrieval-only and does not download content or modify files.",
        "outputs": "A single page of Google Drive file metadata records plus a nextPageToken string for continuation. The records represent Drive API v3 Files resource metadata for the requested scope; when requested, they may include labelInfo for specified labels and permissions for the 'published' view. These metadata objects (including file IDs and attributes) can be used as inputs to downstream tools that act on individual files or perform content operations.",
        "operation": "List Google Drive files and folders",
        "preconditions": "Parameters must be provided inside the aint_query object. If querying a shared drive (by specifying a shared drive ID or including items from shared drives), the caller must indicate support for shared drives (supportsAllDrives=true). Enum-constrained inputs must use allowed values (corpora among user|domain|drive|allDrives; spaces among drive|appDataFolder; includePermissionsForView only 'published'). The operation must target accessible Google Drive API v3 endpoints for the user.",
        "postconditions": "No mutation occurs; this is a read-only, idempotent listing. After successful execution, the caller has a page of file metadata representing the current state of matching Drive items and, if more results are available, a nextPageToken to continue pagination.",
        "business_objects": [
          "Google Drive file",
          "Google Drive folder"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "get_gmail_message_by_id",
      "description": "Retrieval tool for fetching a single message in email: Fetches a specific Gmail message by unique ID for a given user, returning headers, body, and metadata in a chosen format (full, metadata, minimal, or raw). Call when you already know the exact message_id and need the precise email content or headers from that user\u2019s mailbox. Do not call when you need to search or list emails, retrieve entire threads, or send/modify messages; use search/list tools, a thread retrieval tool, or send/update tools instead. Requires: user_id (string; use 'me' for the authenticated user) and message_id (string); optional format (enum: full|metadata|minimal|raw) and metadata_headers (comma-separated string of header names). Rules: read-only; if format=raw, the payload is base64url-encoded and metadata_headers is ignored; prefer immutable message_id over subject/snippet; results are scoped to the specified user and are not deduplicated across accounts. Keywords: gmail, email message, get by id, headers, raw format, base64url, retrieval, user mailbox.",
      "document": {
        "id": "71fc705c-7011-4dfd-98d1-2ef5fab2cb33",
        "auth": {
          "provider": "google"
        },
        "name": "get_gmail_message_by_id",
        "appName": "gmailgoogleapiscom",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for fetching a single message in email: Fetches a specific Gmail message by unique ID for a given user, returning headers, body, and metadata in a chosen format (full, metadata, minimal, or raw). Call when you already know the exact message_id and need the precise email content or headers from that user\u2019s mailbox. Do not call when you need to search or list emails, retrieve entire threads, or send/modify messages; use search/list tools, a thread retrieval tool, or send/update tools instead. Requires: user_id (string; use 'me' for the authenticated user) and message_id (string); optional format (enum: full|metadata|minimal|raw) and metadata_headers (comma-separated string of header names). Rules: read-only; if format=raw, the payload is base64url-encoded and metadata_headers is ignored; prefer immutable message_id over subject/snippet; results are scoped to the specified user and are not deduplicated across accounts. Keywords: gmail, email message, get by id, headers, raw format, base64url, retrieval, user mailbox.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_path"
          ],
          "properties": {
            "aint_path": {
              "type": "object",
              "required": [
                "userId",
                "id"
              ],
              "properties": {
                "id": {
                  "type": "string",
                  "description": "Message ID."
                },
                "userId": {
                  "type": "string",
                  "description": "Use 'me' for the authenticated user."
                }
              },
              "additionalProperties": false
            },
            "aint_query": {
              "type": "object",
              "description": "Query parameters.",
              "additionalProperties": {
                "type": [
                  "string",
                  "number",
                  "boolean"
                ]
              }
            }
          },
          "description": "Dynamic inputs for retrieving a Gmail message.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "gmail",
              "googleapis",
              "com"
            ],
            "path": [
              "gmail",
              "v1",
              "users",
              "$userId",
              "messages",
              "$id"
            ],
            "query": {},
            "protocol": "https"
          },
          "method": "GET",
          "headers": {
            "Accept": "application/json"
          }
        }
      },
      "canonical_data": {
        "name": "get_gmail_message_by_id",
        "inputs": {
          "optional": "aint_query may include query parameters that influence the representation of the returned message, notably a 'format' selector (full, metadata, minimal, or raw) and 'metadata_headers' (a comma-separated list of header names to return when requesting metadata). If format=raw, the returned payload is base64url-encoded and metadata_headers is ignored. All optional parameters are passed via aint_query.",
          "required": [
            "aint_path.userId: The identifier of the mailbox owner whose message is being retrieved; use 'me' to target the currently authenticated user's Gmail account. Required to scope the retrieval to the correct user.",
            "aint_path.id: The unique Gmail message ID of the email to fetch. Required because the tool operates only on a known, specific message."
          ]
        },
        "intent": "Retrieve a specific Gmail message for a given user by its unique message ID, returning the email content and/or headers in a selectable representation.",
        "context": "This tool is strictly for fetching a single known message and should not be used for searching, listing emails, retrieving entire threads, or sending/modifying messages. Results are scoped to the specified user and are not deduplicated across accounts. Prefer using the immutable message_id rather than subject or snippet to identify messages. If format=raw, the payload is base64url-encoded and metadata_headers is ignored. metadata_headers is a comma-separated list of header names used to limit returned headers when format=metadata.",
        "outputs": "A single Gmail message in the requested representation. In 'full' format, the message includes headers, body, and metadata; in 'metadata', it returns message metadata (optionally limited to specified headers); in 'minimal', it returns a minimal set of message fields; in 'raw', it returns the raw message payload base64url-encoded. The returned message data can be used by downstream tools that consume Gmail message content, headers, or raw RFC 822 payloads.",
        "operation": "Retrieve a Gmail message by ID",
        "preconditions": "The caller must provide both the userId and the message ID (aint_path.userId and aint_path.id). The caller should already know the exact message_id to target this specific message. The specified user mailbox must be accessible (use 'me' for the authenticated user). Any provided format must be one of full, metadata, minimal, or raw; if raw is chosen, metadata_headers will not apply.",
        "postconditions": "Read-only retrieval; no changes are made to the user's mailbox or message state. Upon success, the specified message is returned in the chosen representation.",
        "business_objects": [
          "Gmail message"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "delete_email_message_by_id",
      "description": "Mutation tool for deleting messages in email: Permanently removes a Gmail message by message_id for a specified user_id and returns no content; use 'me' to target the authenticated user. Call when you must irrevocably delete a specific Gmail message and already have the exact message_id for the intended account. Do not call when you want to move a message to Trash, archive a message, modify labels, delete an entire thread, or retrieve message contents; use trash, archive, modify-labels, thread-delete, or message-retrieval tools instead. Requires: user_id as a string ('me' for the authenticated user or a Gmail user ID), and message_id as a Gmail message identifier string obtained from prior listing or search; both must be correct for the target account and the caller must be authorized. Rules: deletion is immediate and irreversible; operation is idempotent only in the sense that subsequent calls on the same message_id may return not found; returns no body on success; applies only to Gmail messages; prefer 'me' to avoid cross-account errors. Keywords: gmail, permanent delete, email message, message_id, authenticated user, irreversible deletion.",
      "document": {
        "id": "58d6ad4f-3fda-44ba-b61d-c0a03d0c85bb",
        "auth": {
          "provider": "google"
        },
        "name": "delete_email_message_by_id",
        "appName": "gmailgoogleapiscom",
        "tool_type": "general",
        "transport": "http",
        "description": "Mutation tool for deleting messages in email: Permanently removes a Gmail message by message_id for a specified user_id and returns no content; use 'me' to target the authenticated user. Call when you must irrevocably delete a specific Gmail message and already have the exact message_id for the intended account. Do not call when you want to move a message to Trash, archive a message, modify labels, delete an entire thread, or retrieve message contents; use trash, archive, modify-labels, thread-delete, or message-retrieval tools instead. Requires: user_id as a string ('me' for the authenticated user or a Gmail user ID), and message_id as a Gmail message identifier string obtained from prior listing or search; both must be correct for the target account and the caller must be authorized. Rules: deletion is immediate and irreversible; operation is idempotent only in the sense that subsequent calls on the same message_id may return not found; returns no body on success; applies only to Gmail messages; prefer 'me' to avoid cross-account errors. Keywords: gmail, permanent delete, email message, message_id, authenticated user, irreversible deletion.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_path"
          ],
          "properties": {
            "aint_path": {
              "type": "object",
              "required": [
                "userId",
                "id"
              ],
              "properties": {
                "id": {
                  "type": "string",
                  "description": "Message ID to delete."
                },
                "userId": {
                  "type": "string",
                  "description": "Use 'me' for the authenticated user."
                }
              },
              "additionalProperties": false
            }
          },
          "description": "Inputs for deleting a Gmail message.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "gmail",
              "googleapis",
              "com"
            ],
            "path": [
              "gmail",
              "v1",
              "users",
              "$userId",
              "messages",
              "$id"
            ],
            "protocol": "https"
          },
          "method": "DELETE"
        }
      },
      "canonical_data": {
        "name": "delete_email_message_by_id",
        "inputs": {
          "optional": "none",
          "required": [
            "aint_path: Object container for path parameters required to target the resource being deleted; it must include the userId of the Gmail account and the message id to delete.",
            "aint_path.userId: String identifying the Gmail account to operate on; use 'me' for the authenticated user. Needed to ensure the deletion is performed against the correct mailbox.",
            "aint_path.id: String message identifier for the Gmail message to delete. Required to precisely select the single message that will be permanently removed."
          ]
        },
        "intent": "Permanently remove a specific Gmail message from a specified user's mailbox when you already know the exact message ID.",
        "context": "This tool applies only to Gmail messages and performs an immediate, irreversible delete (not Trash, archive, label modification, thread deletion, or message retrieval). Prefer using 'me' for userId to avoid cross-account errors. The operation is idempotent only in the sense that repeating it on the same message ID may return not found. The input schema disallows additional properties beyond the specified path parameters and returns no body on success.",
        "outputs": "No content is returned on success (empty response body). The operation does not produce any data objects; it only confirms deletion via an empty response.",
        "operation": "permanently delete a Gmail message by ID",
        "preconditions": "The caller must be authorized to access the specified Gmail account. The provided userId must refer to a valid Gmail user (or be 'me' for the authenticated user). The provided message id must correspond to a Gmail message in the specified account for the deletion to succeed.",
        "postconditions": "The targeted Gmail message is permanently deleted and cannot be recovered. The operation is mutating; subsequent attempts to delete the same message ID may result in a not-found condition.",
        "business_objects": [
          "Gmail message"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "list_youtube_playlists",
      "description": "Category tool for retrieval in content: Lists YouTube playlists that match a single filter (channelId, id, or mine) and returns the requested resource parts (e.g., snippet, contentDetails, id, localizations, player, status) with pagination support using the YouTube Data API v3. Call when you need to retrieve playlist metadata for a specific channel, a known set of playlist IDs, or the authenticated user\u2019s playlists. Do not call when you need to list videos within a playlist, perform video search, or create/update/delete playlists; use the appropriate videos retrieval or playlist mutation tools instead. Requires: part as a comma-separated string of resource parts; exactly one filter among channelId (string), id (comma-separated playlist IDs), or mine (boolean); maxResults as an integer in 0-50 (default 5); pageToken (string) for pagination; hl as a BCP 47 language code; valid OAuth context when using mine or onBehalfOfContentOwner; if onBehalfOfContentOwner is set, onBehalfOfContentOwnerChannel (string) is also required. Rules: provide only one filter parameter; retrieval is read-only and idempotent; maxResults defaults to 5 and is clamped to 0-50; use pageToken from the prior response to fetch subsequent pages; set hl only when localized fields are needed; if onBehalfOfContentOwner is used, requests act on that content owner\u2019s channel. Keywords: YouTube playlists, list playlists, playlist metadata, pagination, channelId, contentDetails, snippet, YouTube Data API v3.",
      "document": {
        "id": "224b0c90-bb0d-4a72-a12a-914e29a1f143",
        "name": "list_youtube_playlists",
        "appName": "wwwgoogleapiscom",
        "tool_type": "general",
        "transport": "http",
        "description": "Category tool for retrieval in content: Lists YouTube playlists that match a single filter (channelId, id, or mine) and returns the requested resource parts (e.g., snippet, contentDetails, id, localizations, player, status) with pagination support using the YouTube Data API v3. Call when you need to retrieve playlist metadata for a specific channel, a known set of playlist IDs, or the authenticated user\u2019s playlists. Do not call when you need to list videos within a playlist, perform video search, or create/update/delete playlists; use the appropriate videos retrieval or playlist mutation tools instead. Requires: part as a comma-separated string of resource parts; exactly one filter among channelId (string), id (comma-separated playlist IDs), or mine (boolean); maxResults as an integer in 0-50 (default 5); pageToken (string) for pagination; hl as a BCP 47 language code; valid OAuth context when using mine or onBehalfOfContentOwner; if onBehalfOfContentOwner is set, onBehalfOfContentOwnerChannel (string) is also required. Rules: provide only one filter parameter; retrieval is read-only and idempotent; maxResults defaults to 5 and is clamped to 0-50; use pageToken from the prior response to fetch subsequent pages; set hl only when localized fields are needed; if onBehalfOfContentOwner is used, requests act on that content owner\u2019s channel. Keywords: YouTube playlists, list playlists, playlist metadata, pagination, channelId, contentDetails, snippet, YouTube Data API v3.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_query"
          ],
          "properties": {
            "aint_query": {
              "type": "object",
              "required": [
                "part"
              ],
              "properties": {
                "hl": {
                  "type": "string",
                  "description": "Language code for localized metadata."
                },
                "id": {
                  "type": "string",
                  "description": "Comma-separated list of playlist IDs to retrieve."
                },
                "mine": {
                  "type": "boolean",
                  "description": "If true, return playlists owned by the authenticated user."
                },
                "part": {
                  "type": "string",
                  "description": "Comma-separated list of playlist resource parts to include (e.g., snippet, contentDetails, id, localizations, player, status)."
                },
                "channelId": {
                  "type": "string",
                  "description": "Return playlists for this channel ID."
                },
                "pageToken": {
                  "type": "string",
                  "description": "Token identifying the page of results to return."
                },
                "maxResults": {
                  "type": "integer",
                  "maximum": 50,
                  "minimum": 0,
                  "description": "Maximum number of items to return (0-50, default 5)."
                },
                "onBehalfOfContentOwner": {
                  "type": "string",
                  "description": "For content partners: act on behalf of the specified content owner."
                },
                "onBehalfOfContentOwnerChannel": {
                  "type": "string",
                  "description": "Channel ID required when using onBehalfOfContentOwner."
                }
              },
              "additionalProperties": false
            }
          },
          "description": "Dynamic inputs for listing playlists. Provide 'part' and optionally one filter (channelId, id, or mine) plus other optional parameters.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "www",
              "googleapis",
              "com"
            ],
            "path": [
              "youtube",
              "v3",
              "playlists"
            ],
            "protocol": "https"
          },
          "method": "GET",
          "headers": {
            "Accept": "application/json"
          }
        }
      },
      "canonical_data": {
        "name": "list_youtube_playlists",
        "inputs": {
          "optional": "Within aint_query, exactly one filter can be provided among: channelId (string) to list playlists for a specific channel, id (comma-separated playlist IDs) to fetch known playlists, or mine (boolean) to list the authenticated user\u2019s playlists. Pagination is controlled with pageToken (string from a prior response) and maxResults (integer clamped to 0\u201350, default 5). Localization can be requested via hl (BCP 47 language code) to return localized metadata where applicable. For content partners, onBehalfOfContentOwner (string) can be set to act on a content owner\u2019s behalf, and when present, onBehalfOfContentOwnerChannel (string) is also required. A valid OAuth context is required when using mine or onBehalfOfContentOwner.",
          "required": [
            "aint_query: Container object that holds all request parameters; required by the schema as the envelope for the API call and contains the mandatory 'part' plus optional filter, pagination, localization, and partner fields.",
            "part: Comma-separated list of playlist resource parts to include in the response (e.g., snippet, contentDetails, id, localizations, player, status); required to determine which fields of each playlist are returned."
          ]
        },
        "intent": "Retrieve a page of YouTube playlists that match a single filter and return only the requested playlist resource parts, with pagination support.",
        "context": "Only one filter parameter (channelId, id, or mine) may be used per call. The part parameter determines which playlist fields are returned; only the requested parts are included. Pagination uses pageToken from the prior response to retrieve subsequent pages; maxResults defaults to 5 and is clamped to 0\u201350. Use hl only when localized fields are needed. When onBehalfOfContentOwner is set, requests act on that content owner\u2019s channel. This tool is for listing playlists only; use other tools to list videos in a playlist, search videos, or create/update/delete playlists.",
        "outputs": "A page of playlist resources limited to the requested parts, representing playlists for the specified channel, the provided IDs, or the authenticated user. The response includes pagination metadata (including a token to request subsequent pages). These playlist objects and the pagination token can be fed into downstream tools that consume playlist metadata or continue pagination.",
        "operation": "List playlists with specified resource parts",
        "preconditions": "The request must include aint_query with part specified. Exactly one of channelId, id, or mine must be provided as the filter. If mine is used or if onBehalfOfContentOwner is set, a valid OAuth context must be present. If onBehalfOfContentOwner is set, onBehalfOfContentOwnerChannel must also be provided. maxResults, if supplied, must be between 0 and 50. If hl is supplied, it must be a valid BCP 47 language code. If paginating, pageToken should come from a prior response. The YouTube Data API v3 must be reachable.",
        "postconditions": "No resources are created, updated, or deleted; the operation is read-only and idempotent. Upon success, a deterministic page of playlist metadata matching the inputs is returned.",
        "business_objects": [
          "YouTube playlist",
          "page token"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "delete_google_calendar_event",
      "description": "Mutation tool for deleting events in calendar: Permanently removes a Google Calendar event by calendar_id and event_id, optionally notifying attendees via send_updates (all|externalOnly|none), and deletes the event from the specified calendar. Call when you need to cancel or permanently remove an existing Google Calendar event and optionally notify participants. Do not call when you intend to create, update, or list events, to modify a single attendee\u2019s status, or to operate on non-Google calendars; use the corresponding create, update, list, or attendee tools instead. Requires: calendar_id (string; use 'primary' for the authenticated user's primary calendar) and event_id (string) already known from prior retrieval; optional send_updates (string enum: all|externalOnly|none); caller must have write access; Rules: prefer send_updates over deprecated send_notifications (if both provided, ignore send_notifications), deletion is immediate and cannot be undone here, and notifications are sent per send_updates with default 'none'. Keywords: google calendar, delete event, cancel meeting, remove calendar item, attendee notifications, send_updates, eventId, calendarId.",
      "document": {
        "id": "98fa6fb1-42ee-4f98-beb2-a066f7c57a2f",
        "name": "delete_google_calendar_event",
        "appName": "wwwgoogleapiscom",
        "tool_type": "general",
        "transport": "http",
        "description": "Mutation tool for deleting events in calendar: Permanently removes a Google Calendar event by calendar_id and event_id, optionally notifying attendees via send_updates (all|externalOnly|none), and deletes the event from the specified calendar. Call when you need to cancel or permanently remove an existing Google Calendar event and optionally notify participants. Do not call when you intend to create, update, or list events, to modify a single attendee\u2019s status, or to operate on non-Google calendars; use the corresponding create, update, list, or attendee tools instead. Requires: calendar_id (string; use 'primary' for the authenticated user's primary calendar) and event_id (string) already known from prior retrieval; optional send_updates (string enum: all|externalOnly|none); caller must have write access; Rules: prefer send_updates over deprecated send_notifications (if both provided, ignore send_notifications), deletion is immediate and cannot be undone here, and notifications are sent per send_updates with default 'none'. Keywords: google calendar, delete event, cancel meeting, remove calendar item, attendee notifications, send_updates, eventId, calendarId.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_path"
          ],
          "properties": {
            "aint_path": {
              "type": "object",
              "required": [
                "calendarId",
                "eventId"
              ],
              "properties": {
                "eventId": {
                  "type": "string",
                  "description": "Event identifier."
                },
                "calendarId": {
                  "type": "string",
                  "description": "Calendar identifier. Use 'primary' for the authenticated user's primary calendar."
                }
              },
              "description": "Path parameters.",
              "additionalProperties": false
            },
            "aint_query": {
              "type": "object",
              "properties": {
                "sendUpdates": {
                  "enum": [
                    "all",
                    "externalOnly",
                    "none"
                  ],
                  "type": "string",
                  "description": "Guests who should receive notifications about the deletion."
                },
                "sendNotifications": {
                  "type": "boolean",
                  "description": "Deprecated. Whether to send notifications about the deletion."
                }
              },
              "description": "Optional query parameters.",
              "additionalProperties": false
            }
          },
          "description": "Dynamic inputs to delete a calendar event.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "www",
              "googleapis",
              "com"
            ],
            "path": [
              "calendar",
              "v3",
              "calendars",
              "$calendarId",
              "events",
              "$eventId"
            ],
            "protocol": "https"
          },
          "method": "DELETE"
        }
      },
      "canonical_data": {
        "name": "delete_google_calendar_event",
        "inputs": {
          "optional": "aint_query may be provided to control notification behavior. It can include sendUpdates (enum: all|externalOnly|none) specifying which guests receive deletion notifications, and a deprecated sendNotifications (boolean) which should be ignored if sendUpdates is also provided. If neither is provided, notifications default to none.",
          "required": [
            "aint_path: Object containing the path parameters needed to identify the target resource. It must include calendarId (the calendar that owns the event; use 'primary' for the authenticated user's primary calendar) and eventId (the unique identifier of the event to delete). These are required to locate and delete the specific event within the specified calendar."
          ]
        },
        "intent": "Permanently remove an existing Google Calendar event from a specified calendar, with optional attendee notification controls.",
        "context": "This is a mutation (delete) operation, not for creating, updating, or listing events, nor for modifying a single attendee\u2019s status. Prefer sendUpdates over the deprecated sendNotifications; if both are supplied, sendNotifications is ignored. Default notification behavior is none when neither parameter is provided. Use 'primary' for the authenticated user\u2019s primary calendar in calendarId. Input objects disallow unspecified properties (additionalProperties: false).",
        "outputs": "No response payload is defined by the specification. Successful execution signifies the event was deleted; attendees may receive notifications according to sendUpdates, but no event or notification records are returned.",
        "operation": "permanently delete a Google Calendar event",
        "preconditions": "The specified calendarId and eventId must refer to an existing Google Calendar event; the caller must have write access to that calendar. The required input object aint_path must be provided and contain both calendarId and eventId. If sendUpdates is used, its value must be one of all, externalOnly, or none. This tool is intended only for Google Calendars (not third-party calendars).",
        "postconditions": "The targeted event is permanently deleted from the specified Google Calendar. The deletion is immediate and cannot be undone via this tool. If sendUpdates is set, notifications are sent to guests per its value; if not set, no notifications are sent.",
        "business_objects": [
          "Google Calendar event",
          "Google Calendar"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "list_youtube_videos",
      "description": "Retrieval tool for listing videos in content: Fetch YouTube video resources that match specified filters and return a list of videos with requested parts (e.g., snippet, statistics, player), pagination tokens, and optional localized metadata; supports chart, id, or myRating modes. Call when you need to retrieve structured metadata or embed information for popular videos, specific video IDs, or the authenticated user\u2019s liked/disliked videos. Do not call when performing keyword-based discovery (use a YouTube search tool), uploading or editing videos, or retrieving comments/playlists. Requires: part as a comma-separated list of allowed parts (contentDetails, fileDetails, id, liveStreamingDetails, localizations, paidProductPlacementDetails, player, processingDetails, recordingDetails, snippet, statistics, status, suggestions, topicDetails); exactly one of chart (must be \u201cmostPopular\u201d), id (comma-separated video IDs), or myRating (\u201clike\u201d or \u201cdislike\u201d); regionCode as ISO 3166-1 alpha-2 and optional videoCategoryId when using chart; hl as a language code; maxResults integer 1\u201350 (supported with myRating, not supported with id); pageToken string; maxHeight and maxWidth in pixels (72\u20138192) for player.embedHtml sizing; onBehalfOfContentOwner string for partners; valid YouTube Data API authentication is required for myRating and partner operations. Rules: exactly one of chart/id/myRating must be set; if part includes player, maxHeight/maxWidth control embed HTML dimensions; regionCode and videoCategoryId are only valid with chart; maxResults is ignored with id; use pageToken to continue pagination; calls are read-only and idempotent. Keywords: youtube api, videos.list, list videos, video metadata, most popular chart, myRating, localization, pagination.",
      "document": {
        "id": "534ddc3f-3005-40be-9acf-33b6fdc11ad5",
        "name": "list_youtube_videos",
        "appName": "wwwgoogleapiscom",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for listing videos in content: Fetch YouTube video resources that match specified filters and return a list of videos with requested parts (e.g., snippet, statistics, player), pagination tokens, and optional localized metadata; supports chart, id, or myRating modes. Call when you need to retrieve structured metadata or embed information for popular videos, specific video IDs, or the authenticated user\u2019s liked/disliked videos. Do not call when performing keyword-based discovery (use a YouTube search tool), uploading or editing videos, or retrieving comments/playlists. Requires: part as a comma-separated list of allowed parts (contentDetails, fileDetails, id, liveStreamingDetails, localizations, paidProductPlacementDetails, player, processingDetails, recordingDetails, snippet, statistics, status, suggestions, topicDetails); exactly one of chart (must be \u201cmostPopular\u201d), id (comma-separated video IDs), or myRating (\u201clike\u201d or \u201cdislike\u201d); regionCode as ISO 3166-1 alpha-2 and optional videoCategoryId when using chart; hl as a language code; maxResults integer 1\u201350 (supported with myRating, not supported with id); pageToken string; maxHeight and maxWidth in pixels (72\u20138192) for player.embedHtml sizing; onBehalfOfContentOwner string for partners; valid YouTube Data API authentication is required for myRating and partner operations. Rules: exactly one of chart/id/myRating must be set; if part includes player, maxHeight/maxWidth control embed HTML dimensions; regionCode and videoCategoryId are only valid with chart; maxResults is ignored with id; use pageToken to continue pagination; calls are read-only and idempotent. Keywords: youtube api, videos.list, list videos, video metadata, most popular chart, myRating, localization, pagination.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_query"
          ],
          "properties": {
            "aint_query": {
              "type": "object",
              "required": [
                "part"
              ],
              "properties": {
                "hl": {
                  "type": "string",
                  "description": "Language code for localized metadata."
                },
                "id": {
                  "type": "string",
                  "description": "Comma-separated video IDs. Use exactly one of: chart, id, or myRating."
                },
                "part": {
                  "type": "string",
                  "description": "Comma-separated parts: contentDetails, fileDetails, id, liveStreamingDetails, localizations, paidProductPlacementDetails, player, processingDetails, recordingDetails, snippet, statistics, status, suggestions, topicDetails."
                },
                "chart": {
                  "enum": [
                    "mostPopular"
                  ],
                  "type": "string",
                  "description": "Use exactly one of: chart, id, or myRating."
                },
                "maxWidth": {
                  "type": "integer",
                  "maximum": 8192,
                  "minimum": 72,
                  "description": "Max width for player.embedHtml."
                },
                "myRating": {
                  "enum": [
                    "like",
                    "dislike"
                  ],
                  "type": "string",
                  "description": "Authenticated user's rating filter. Use exactly one of: chart, id, or myRating."
                },
                "maxHeight": {
                  "type": "integer",
                  "maximum": 8192,
                  "minimum": 72,
                  "description": "Max height for player.embedHtml."
                },
                "pageToken": {
                  "type": "string",
                  "description": "Page token."
                },
                "maxResults": {
                  "type": "integer",
                  "maximum": 50,
                  "minimum": 1,
                  "description": "Max items to return. Supported with myRating; not supported with id."
                },
                "regionCode": {
                  "type": "string",
                  "description": "ISO 3166-1 alpha-2 country code; use with chart."
                },
                "videoCategoryId": {
                  "type": "string",
                  "description": "Video category ID; use with chart."
                },
                "onBehalfOfContentOwner": {
                  "type": "string",
                  "description": "Content owner ID for partners."
                }
              },
              "description": "Query parameters for videos.list.",
              "additionalProperties": false
            }
          },
          "description": "Inputs for YouTube Videos: list.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "www",
              "googleapis",
              "com"
            ],
            "path": [
              "youtube",
              "v3",
              "videos"
            ],
            "protocol": "https"
          },
          "method": "GET"
        }
      },
      "canonical_data": {
        "name": "list_youtube_videos",
        "inputs": {
          "optional": "All other fields inside aint_query are optional but governed by strict rules: exactly one of chart, id, or myRating must be provided. chart, if used, must be \"mostPopular\" and is valid only with regionCode (ISO 3166-1 alpha-2 required) and an optional videoCategoryId. id is a comma-separated list of video IDs; when id is used, maxResults is not supported and will be ignored. myRating filters by the authenticated user\u2019s rating and must be either \"like\" or \"dislike\"; maxResults (1\u201350) is supported with myRating. hl can request localized metadata. pageToken continues pagination. If part includes player, maxHeight and/or maxWidth (72\u20138192) control the size of player.embedHtml. onBehalfOfContentOwner is for YouTube Content Owner partners and requires appropriate authentication.",
          "required": [
            {
              "name": "aint_query",
              "description": "Container object for all query parameters to the videos.list endpoint; required to convey the part selection and exactly one selection mode (chart, id, or myRating), along with any optional filters and pagination controls."
            },
            {
              "name": "aint_query.part",
              "description": "Comma-separated list specifying which parts of the video resource to include in the response (contentDetails, fileDetails, id, liveStreamingDetails, localizations, paidProductPlacementDetails, player, processingDetails, recordingDetails, snippet, statistics, status, suggestions, topicDetails). Required by the API to define the shape of returned video resources."
            }
          ]
        },
        "intent": "Retrieve YouTube video resources that match specified filters and return their requested metadata parts, with pagination support and optional localization and player embed sizing.",
        "context": "This is a retrieval-only YouTube Data API videos.list call. Use pageToken to paginate through results. maxResults applies only with myRating and is ignored with id. chart supports only \"mostPopular\" and is valid only with regionCode (and optional videoCategoryId). hl requests localized metadata. If part includes player, maxHeight/maxWidth control embed HTML dimensions. Authentication is required for myRating queries and partner operations (onBehalfOfContentOwner). Do not use this tool for keyword-based discovery (use a search tool instead), uploads/edits, or for comments/playlists. Calls are read-only and idempotent.",
        "outputs": "A read-only list (array) of YouTube video resources containing exactly the requested parts, plus pagination tokens for result continuation. Depending on requested parts, items may include fields such as embed HTML (player), localized fields (when hl is set), statistics, snippet, and other specified parts. These video resource objects (notably their video IDs and included metadata) can be used as inputs to downstream tools that accept video identifiers or rely on specific video metadata.",
        "operation": "List video resources based on chart, IDs, or the authenticated user\u2019s rating filter",
        "preconditions": "The caller must provide aint_query.part and exactly one of aint_query.chart, aint_query.id, or aint_query.myRating. If chart is used, it must be \"mostPopular\" and regionCode must be supplied as an ISO 3166-1 alpha-2 code; videoCategoryId is optional but only valid with chart. If myRating is used, the caller must be authenticated and myRating must be either \"like\" or \"dislike\"; maxResults, if provided, must be between 1 and 50. If id is used, it must be a comma-separated list of video IDs and maxResults is not supported. If maxHeight/maxWidth are provided to size player.embedHtml, each must be between 72 and 8192. onBehalfOfContentOwner requires partner credentials and valid YouTube Data API authentication. The API must be accessible.",
        "postconditions": "No server-side state is modified; the operation is read-only and idempotent. Upon success, a page of video resources matching the specified mode and filters is returned along with pagination tokens when more results are available.",
        "business_objects": [
          "YouTube video resource",
          "Pagination token"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "get_google_calendar_event",
      "description": "Retrieval tool for fetching a single event in calendar: retrieves a Google Calendar event resource by calendarId and eventId and returns its details, optionally constrained by maxAttendees and formatted in the specified timeZone. Call when you need the full details of a known event and you already have both the calendarId and eventId. Do not call when you need to list or search events, create/update/delete events, or check availability; use an events listing, search, mutation, or free-busy tool instead. Requires: calendarId (string; 'primary' permitted), eventId (string), optional maxAttendees (integer), optional timeZone (string; IANA TZ like 'UTC' or 'America/Los_Angeles'); do not set alwaysIncludeEmail as it is deprecated and ignored. Rules: read-only and idempotent; if maxAttendees is set, attendee lists are limited to that number; if timeZone is omitted, the calendar\u2019s time zone is used; prefer an explicit timeZone for consistent comparisons across responses. Keywords: google calendar, event retrieval, event details, event id, attendees limit, time zone, calendar api, retrieval..",
      "document": {
        "id": "06b6a2de-cb01-42fe-aaaf-5385fae9f51b",
        "name": "get_google_calendar_event",
        "appName": "wwwgoogleapiscom",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for fetching a single event in calendar: retrieves a Google Calendar event resource by calendarId and eventId and returns its details, optionally constrained by maxAttendees and formatted in the specified timeZone. Call when you need the full details of a known event and you already have both the calendarId and eventId. Do not call when you need to list or search events, create/update/delete events, or check availability; use an events listing, search, mutation, or free-busy tool instead. Requires: calendarId (string; 'primary' permitted), eventId (string), optional maxAttendees (integer), optional timeZone (string; IANA TZ like 'UTC' or 'America/Los_Angeles'); do not set alwaysIncludeEmail as it is deprecated and ignored. Rules: read-only and idempotent; if maxAttendees is set, attendee lists are limited to that number; if timeZone is omitted, the calendar\u2019s time zone is used; prefer an explicit timeZone for consistent comparisons across responses. Keywords: google calendar, event retrieval, event details, event id, attendees limit, time zone, calendar api, retrieval..",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_path"
          ],
          "properties": {
            "aint_path": {
              "type": "object",
              "required": [
                "calendarId",
                "eventId"
              ],
              "properties": {
                "eventId": {
                  "type": "string",
                  "description": "Event identifier."
                },
                "calendarId": {
                  "type": "string",
                  "description": "Calendar identifier. Use 'primary' for the authenticated user's primary calendar."
                }
              },
              "additionalProperties": false
            },
            "aint_query": {
              "type": "object",
              "properties": {
                "timeZone": {
                  "type": "string",
                  "description": "Time zone for the response (defaults to the calendar's time zone)."
                },
                "maxAttendees": {
                  "type": "integer",
                  "description": "Maximum number of attendees to include."
                },
                "alwaysIncludeEmail": {
                  "type": "boolean",
                  "description": "Deprecated and ignored."
                }
              },
              "additionalProperties": {
                "type": [
                  "string",
                  "number",
                  "boolean"
                ]
              }
            }
          },
          "description": "Dynamic inputs for Events: get endpoint.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "www",
              "googleapis",
              "com"
            ],
            "path": [
              "calendar",
              "v3",
              "calendars",
              "$calendarId",
              "events",
              "$eventId"
            ],
            "protocol": "https"
          },
          "method": "GET"
        }
      },
      "canonical_data": {
        "name": "get_google_calendar_event",
        "inputs": {
          "optional": "aint_query: Optional query parameters for the retrieval. Recognized options include timeZone (an IANA time zone identifier such as 'UTC' or 'America/Los_Angeles' that controls how date/time fields are formatted in the response; if omitted, the calendar's time zone is used) and maxAttendees (integer limiting how many attendees are included in the returned event; the attendees list will be truncated to this number if set). The parameter alwaysIncludeEmail is accepted by the schema but is deprecated and ignored. The schema permits additional primitive query parameters, but only the documented options affect behavior for this operation.",
          "required": [
            "aint_path: Object containing the path parameters that locate the event. It must include calendarId (the target calendar identifier; 'primary' is allowed for the authenticated user's primary calendar) and eventId (the identifier of the specific event). These identifiers are necessary to uniquely select the event to retrieve."
          ]
        },
        "intent": "Fetch the full details of a single Google Calendar event by specifying its calendar and event identifiers, with optional control over attendee count and response time zone.",
        "context": "This is a read-only retrieval for a single event (no pagination). Use 'primary' for the authenticated user's primary calendar in calendarId. If timeZone is omitted, the calendar's time zone determines how times are represented; providing an explicit IANA time zone is recommended for consistent comparisons across responses. If maxAttendees is set, the attendees array in the response is limited to that count. The alwaysIncludeEmail parameter is deprecated and ignored. The schema allows extra query fields, but they are not documented to affect this endpoint's behavior.",
        "outputs": "A single Google Calendar event resource object representing the requested event. The object contains the event's details as returned by the Google Calendar API; attendee lists may be limited by maxAttendees, and date/time fields are expressed in the specified timeZone (or the calendar's time zone if none is provided). The returned resource includes identifiers (e.g., calendarId via the call context and eventId within the resource) that can be reused by downstream tools that operate on the same event.",
        "operation": "Retrieve a single Google Calendar event by calendarId and eventId",
        "preconditions": "The caller must provide a valid aint_path object containing both calendarId and eventId. The specified calendar and event must exist and be readable by the authenticated user or service. If provided, timeZone must be a valid IANA time zone string; maxAttendees must be an integer. The parameter alwaysIncludeEmail, if provided, will be ignored.",
        "postconditions": "No state changes occur; this is a read-only, idempotent retrieval. Upon success, the event's details are returned, with attendee lists possibly truncated according to maxAttendees and times formatted per the timeZone rule.",
        "business_objects": [
          "Calendar",
          "Calendar Event"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "get_google_drive_by_id",
      "description": "Category tool for retrieval in content: retrieves Google Drive shared drive metadata by drive_id and optional use_domain_admin_access, returning a structured drive resource (id, name, capabilities, restrictions) without files. Call when you need canonical properties of an existing shared drive and already have its drive_id. Do not call when you need to list or search drives, access personal My Drive, or fetch file, folder, or permission details; use the appropriate listing, search, or file/permission tools instead. Requires: drive_id (string identifier of a Google Drive shared drive) and optional use_domain_admin_access (boolean); provide the exact drive_id from drive discovery or a drive URL and do not pass a file or folder ID. Rules: read-only and idempotent; executes with domain admin privileges only if use_domain_admin_access=true; returns only drive-level metadata and does not include child items or permission membership. Keywords: google drive, shared drive, drive metadata, driveId, admin access, content retrieval.",
      "document": {
        "id": "125659e5-3ef0-4f2b-a4e0-c9c207755590",
        "name": "get_google_drive_by_id",
        "appName": "wwwgoogleapiscom",
        "tool_type": "general",
        "transport": "http",
        "description": "Category tool for retrieval in content: retrieves Google Drive shared drive metadata by drive_id and optional use_domain_admin_access, returning a structured drive resource (id, name, capabilities, restrictions) without files. Call when you need canonical properties of an existing shared drive and already have its drive_id. Do not call when you need to list or search drives, access personal My Drive, or fetch file, folder, or permission details; use the appropriate listing, search, or file/permission tools instead. Requires: drive_id (string identifier of a Google Drive shared drive) and optional use_domain_admin_access (boolean); provide the exact drive_id from drive discovery or a drive URL and do not pass a file or folder ID. Rules: read-only and idempotent; executes with domain admin privileges only if use_domain_admin_access=true; returns only drive-level metadata and does not include child items or permission membership. Keywords: google drive, shared drive, drive metadata, driveId, admin access, content retrieval.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_path"
          ],
          "properties": {
            "aint_path": {
              "type": "object",
              "required": [
                "driveId"
              ],
              "properties": {
                "driveId": {
                  "type": "string",
                  "description": "The ID of the shared drive."
                }
              },
              "additionalProperties": false
            },
            "aint_query": {
              "type": "object",
              "properties": {
                "useDomainAdminAccess": {
                  "type": "boolean",
                  "description": "Issue the request as a domain administrator."
                }
              },
              "additionalProperties": {
                "type": [
                  "string",
                  "number",
                  "boolean"
                ]
              }
            }
          },
          "description": "Dynamic inputs for path and query parameters.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "www",
              "googleapis",
              "com"
            ],
            "path": [
              "drive",
              "v3",
              "drives",
              "$driveId"
            ],
            "protocol": "https"
          },
          "method": "GET",
          "headers": {
            "Authorization": "Bearer $Authorization"
          }
        }
      },
      "canonical_data": {
        "name": "get_google_drive_by_id",
        "inputs": {
          "optional": "aint_query may include query parameters. Specifically, useDomainAdminAccess (boolean) can be set to execute the request with domain administrator privileges; if omitted, the request runs under the caller\u2019s normal permissions. The schema also permits additional query key\u2013value pairs (string, number, or boolean), but no additional semantics are defined.",
          "required": [
            "aint_path: Container for path parameters required to target the resource; it must be provided so the API can resolve which shared drive to retrieve.",
            "aint_path.driveId: The identifier of the target Google Drive shared drive; needed to look up and return that drive\u2019s metadata. It must be an actual shared drive ID (not a file or folder ID and not personal My Drive)."
          ]
        },
        "intent": "Retrieve the canonical metadata of a specific Google Drive shared drive using its drive ID.",
        "context": "This tool is for fetching a single shared drive\u2019s metadata only\u2014do not use it to list or search drives, access personal My Drive, or retrieve files, folders, or permissions. The call is idempotent and read-only. It returns only drive-level fields (no child items). Domain admin privileges are applied only if useDomainAdminAccess=true. Inputs are split into path parameters (aint_path, no additional properties allowed) and query parameters (aint_query, which allows useDomainAdminAccess and other unspecified string/number/boolean parameters). There is no pagination because only one resource is retrieved.",
        "outputs": "A single structured shared drive resource object containing drive-level metadata (e.g., id, name, capabilities, restrictions). It does not include any files, folders, or permission membership. The returned id and properties can be used to reference this shared drive or inform downstream tools that require a driveId or need to respect drive capabilities/restrictions.",
        "operation": "Retrieve shared drive metadata by ID",
        "preconditions": "A valid shared drive ID must be provided in aint_path.driveId (not a file/folder ID and not My Drive). The target shared drive must exist and be accessible under the caller\u2019s context. If useDomainAdminAccess=true is set, the execution environment must support issuing the request with domain administrator privileges. The Google Drive API must be reachable.",
        "postconditions": "Read-only retrieval; no changes are made to any drive, files, or permissions. Upon success, the shared drive\u2019s metadata is returned; no child items or membership details are created or modified.",
        "business_objects": [
          "Google Drive shared drive (Drive resource)"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "delete_google_drive_file_by_id",
      "description": "Mutation tool for deleting files in content storage: permanently removes a Google Drive file by fileId, supporting both My Drive and shared drives when supportsAllDrives=true, and returns no content on success. Call when you need irreversible removal of a specific Drive file and have confirmed user intent; set supportsAllDrives=true for items in shared drives. Do not call when you only need to move a file to Trash, recover an item, or change ownership/permissions; use a trash operation or permission update instead. Requires fileId (string) and, optionally, supportsAllDrives (boolean, default false); caller must already have appropriate Drive permissions on the target. Rules: deletion is permanent and cannot be undone; deprecated flags supportsTeamDrives and enforceSingleParent are ignored; subsequent deletes of the same file may return 404 and should be treated as idempotent in effect. Keywords: google drive, delete file, permanent deletion, shared drives, fileId, supportsAllDrives, content storage.",
      "document": {
        "id": "6c0f35f5-abc3-4e4f-8d67-8834989e4b2c",
        "name": "delete_google_drive_file_by_id",
        "appName": "wwwgoogleapiscom",
        "tool_type": "general",
        "transport": "http",
        "description": "Mutation tool for deleting files in content storage: permanently removes a Google Drive file by fileId, supporting both My Drive and shared drives when supportsAllDrives=true, and returns no content on success. Call when you need irreversible removal of a specific Drive file and have confirmed user intent; set supportsAllDrives=true for items in shared drives. Do not call when you only need to move a file to Trash, recover an item, or change ownership/permissions; use a trash operation or permission update instead. Requires fileId (string) and, optionally, supportsAllDrives (boolean, default false); caller must already have appropriate Drive permissions on the target. Rules: deletion is permanent and cannot be undone; deprecated flags supportsTeamDrives and enforceSingleParent are ignored; subsequent deletes of the same file may return 404 and should be treated as idempotent in effect. Keywords: google drive, delete file, permanent deletion, shared drives, fileId, supportsAllDrives, content storage.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_path"
          ],
          "properties": {
            "aint_path": {
              "type": "object",
              "required": [
                "fileId"
              ],
              "properties": {
                "fileId": {
                  "type": "string",
                  "description": "The ID of the file to delete."
                }
              },
              "additionalProperties": false
            },
            "aint_query": {
              "type": "object",
              "properties": {
                "supportsAllDrives": {
                  "type": "boolean",
                  "description": "Whether the application supports My Drive and shared drives."
                },
                "supportsTeamDrives": {
                  "type": "boolean",
                  "description": "Deprecated. Use supportsAllDrives."
                },
                "enforceSingleParent": {
                  "type": "boolean",
                  "description": "Deprecated behavior for non-shared drives."
                }
              },
              "additionalProperties": false
            }
          },
          "description": "Inputs for Drive files.delete: path and optional query flags.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "www",
              "googleapis",
              "com"
            ],
            "path": [
              "drive",
              "v3",
              "files",
              "$fileId"
            ],
            "protocol": "https"
          },
          "method": "DELETE"
        }
      },
      "canonical_data": {
        "name": "delete_google_drive_file_by_id",
        "inputs": {
          "optional": "aint_query may include query flags. Set supportsAllDrives=true when operating on items in shared drives; by default it is false and applies to My Drive. Deprecated flags supportsTeamDrives and enforceSingleParent may be present in the schema but are ignored. No additional query parameters are accepted.",
          "required": [
            "aint_path: A required path-parameter object that must contain the target file identifier; it routes the delete operation to the specific Drive file resource.",
            "aint_path.fileId: The string ID of the Google Drive file to delete; this uniquely identifies which file will be permanently removed."
          ]
        },
        "intent": "Irreversibly remove a specific Google Drive file identified by its ID.",
        "context": "This is a mutation operation that permanently deletes a file and should only be used when irreversible removal is intended. It supports both My Drive and shared drives when supportsAllDrives=true; by default, supportsAllDrives is false. Deprecated flags supportsTeamDrives and enforceSingleParent are ignored. The API is structured with a path container (aint_path) for fileId and an optional query container (aint_query) for flags, with no additional properties permitted. The tool returns no content on success, and repeated deletes of the same file may result in 404 and should be treated as idempotent in effect.",
        "outputs": "No content is returned on success (empty response body). The absence of a returned object serves as confirmation that the specified file was permanently deleted and can be used by downstream tools to assume the file no longer exists.",
        "operation": "permanently delete a Google Drive file by fileId",
        "preconditions": "The caller must have appropriate Google Drive permissions on the target file. A valid fileId must be provided in the path parameters. If the target resides in a shared drive, the operation should be invoked with supportsAllDrives=true to enable handling of shared drives. The operation must be intentionally called only for permanent deletion (not for trashing, recovery, or permission changes).",
        "postconditions": "On successful execution, the specified Google Drive file is permanently removed and cannot be undone or recovered via Trash. No response content is produced. Subsequent attempts to delete the same file may return a not-found outcome, reflecting that the file no longer exists; the deletion effect is idempotent.",
        "business_objects": [
          "Google Drive file"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "search_youtube_content",
      "description": "Retrieval tool for search in content domain: Searches YouTube for videos, channels, and playlists using a query and structured filters, returning resource IDs and snippet metadata in paginated results. Call when you need to discover YouTube content by keywords, time window, region/language bias, location, or video-specific attributes (e.g., duration, definition, caption) and receive concise snippets. Do not call when you need full item details by ID, channel uploads, or analytics; use a dedicated detail/lookup or listing/analytics tool instead. Requires: part includes 'snippet' at minimum; q (string) for the search query; publishedAfter/publishedBefore as RFC3339 UTC timestamps; location as 'lat,lng' with locationRadius including unit (m, km, ft, mi); type as comma-separated resource types from video,channel,playlist; maxResults 1\u201350 (default 5); regionCode as ISO 3166-1 alpha-2; set forMine, forContentOwner, or forDeveloper only when authorized. Rules: If any video* filter or eventType is used, ensure type includes 'video'; if location is set, also set locationRadius and include type=video; safeSearch defaults to moderate and order defaults to relevance; pagination uses pageToken; read-only with no side effects. Keywords: youtube search, videos channels playlists, content discovery, snippet metadata, filters and facets, RFC3339 timestamps, safe search, pagination.",
      "document": {
        "id": "58c4e367-55af-4441-ac41-745376fb2292",
        "name": "search_youtube_content",
        "appName": "wwwgoogleapiscom",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for search in content domain: Searches YouTube for videos, channels, and playlists using a query and structured filters, returning resource IDs and snippet metadata in paginated results. Call when you need to discover YouTube content by keywords, time window, region/language bias, location, or video-specific attributes (e.g., duration, definition, caption) and receive concise snippets. Do not call when you need full item details by ID, channel uploads, or analytics; use a dedicated detail/lookup or listing/analytics tool instead. Requires: part includes 'snippet' at minimum; q (string) for the search query; publishedAfter/publishedBefore as RFC3339 UTC timestamps; location as 'lat,lng' with locationRadius including unit (m, km, ft, mi); type as comma-separated resource types from video,channel,playlist; maxResults 1\u201350 (default 5); regionCode as ISO 3166-1 alpha-2; set forMine, forContentOwner, or forDeveloper only when authorized. Rules: If any video* filter or eventType is used, ensure type includes 'video'; if location is set, also set locationRadius and include type=video; safeSearch defaults to moderate and order defaults to relevance; pagination uses pageToken; read-only with no side effects. Keywords: youtube search, videos channels playlists, content discovery, snippet metadata, filters and facets, RFC3339 timestamps, safe search, pagination.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_query"
          ],
          "properties": {
            "body": {
              "type": "object",
              "properties": {},
              "description": "Body parameters"
            },
            "path": {
              "type": "object",
              "properties": {},
              "description": "Path parameters"
            },
            "query": {
              "type": "object",
              "properties": {},
              "description": "Query parameters"
            },
            "headers": {
              "type": "object",
              "properties": {},
              "description": "Headers parameters"
            },
            "aint_query": {
              "type": "object",
              "required": [
                "part"
              ],
              "properties": {
                "q": {
                  "type": "string",
                  "description": "Search query. Supports - (NOT) and | (OR)."
                },
                "part": {
                  "type": "string",
                  "default": "snippet",
                  "description": "Comma-separated properties to include (e.g., 'snippet')."
                },
                "type": {
                  "type": "string",
                  "description": "Comma-separated resource types to return. Valid: channel, playlist, video. Default is video,channel,playlist."
                },
                "order": {
                  "enum": [
                    "date",
                    "rating",
                    "relevance",
                    "title",
                    "videoCount",
                    "viewCount"
                  ],
                  "type": "string",
                  "description": "Sort order. Default relevance."
                },
                "forMine": {
                  "type": "boolean",
                  "description": "Restrict to videos owned by the authenticated user. Requires authorization and type=video."
                },
                "topicId": {
                  "type": "string",
                  "description": "Restrict to resources associated with this curated topic ID."
                },
                "location": {
                  "type": "string",
                  "description": "Center point as \"lat,lng\" (e.g., 37.42307,-122.08427). Requires locationRadius and type=video."
                },
                "channelId": {
                  "type": "string",
                  "description": "Only return resources created by this channel ID."
                },
                "eventType": {
                  "enum": [
                    "completed",
                    "live",
                    "upcoming"
                  ],
                  "type": "string",
                  "description": "Restrict to broadcast events. Requires type=video."
                },
                "pageToken": {
                  "type": "string",
                  "description": "Token for a specific results page."
                },
                "videoType": {
                  "enum": [
                    "any",
                    "episode",
                    "movie"
                  ],
                  "type": "string",
                  "description": "Restrict to a video type. Requires type=video."
                },
                "maxResults": {
                  "type": "integer",
                  "maximum": 50,
                  "minimum": 0,
                  "description": "Max items per page. Default 5."
                },
                "regionCode": {
                  "type": "string",
                  "description": "ISO 3166-1 alpha-2 country code for region filtering."
                },
                "safeSearch": {
                  "enum": [
                    "moderate",
                    "none",
                    "strict"
                  ],
                  "type": "string",
                  "description": "Content filtering level. Default moderate."
                },
                "channelType": {
                  "enum": [
                    "any",
                    "show"
                  ],
                  "type": "string",
                  "description": "Restrict to a type of channel."
                },
                "forDeveloper": {
                  "type": "boolean",
                  "description": "Restrict to videos uploaded via the developer's app. Requires authorization."
                },
                "videoCaption": {
                  "enum": [
                    "any",
                    "closedCaption",
                    "none"
                  ],
                  "type": "string",
                  "description": "Filter by caption availability. Requires type=video."
                },
                "videoLicense": {
                  "enum": [
                    "any",
                    "creativeCommon",
                    "youtube"
                  ],
                  "type": "string",
                  "description": "Filter by license. Requires type=video."
                },
                "videoDuration": {
                  "enum": [
                    "any",
                    "long",
                    "medium",
                    "short"
                  ],
                  "type": "string",
                  "description": "Filter by duration. Requires type=video."
                },
                "locationRadius": {
                  "type": "string",
                  "description": "Radius with unit (m, km, ft, mi). Example: 5km. Max 1000km."
                },
                "publishedAfter": {
                  "type": "string",
                  "format": "date-time",
                  "description": "Only resources created at or after this RFC 3339 time."
                },
                "videoDimension": {
                  "enum": [
                    "2d",
                    "3d",
                    "any"
                  ],
                  "type": "string",
                  "description": "Filter by 2D/3D. Requires type=video."
                },
                "forContentOwner": {
                  "type": "boolean",
                  "description": "Restrict to videos owned by the content owner specified by onBehalfOfContentOwner. Requires proper authorization and type=video."
                },
                "publishedBefore": {
                  "type": "string",
                  "format": "date-time",
                  "description": "Only resources created before or at this RFC 3339 time."
                },
                "videoCategoryId": {
                  "type": "string",
                  "description": "Filter by video category ID. Requires type=video."
                },
                "videoDefinition": {
                  "enum": [
                    "any",
                    "high",
                    "standard"
                  ],
                  "type": "string",
                  "description": "Filter by HD/SD. Requires type=video."
                },
                "videoEmbeddable": {
                  "enum": [
                    "any",
                    "true"
                  ],
                  "type": "string",
                  "description": "Only embeddable videos if true. Requires type=video."
                },
                "videoSyndicated": {
                  "enum": [
                    "any",
                    "true"
                  ],
                  "type": "string",
                  "description": "Only videos playable off YouTube if true. Requires type=video."
                },
                "relevanceLanguage": {
                  "type": "string",
                  "description": "Language to bias relevance (e.g., en, zh-Hans, zh-Hant)."
                },
                "onBehalfOfContentOwner": {
                  "type": "string",
                  "description": "CMS content owner ID for authorized partner requests."
                },
                "videoPaidProductPlacement": {
                  "enum": [
                    "any",
                    "true"
                  ],
                  "type": "string",
                  "description": "Filter for videos with paid promotion. Requires type=video."
                }
              },
              "description": "Dynamic query parameters; unset keys use API defaults.",
              "additionalProperties": {
                "type": [
                  "string",
                  "number",
                  "boolean"
                ]
              }
            }
          },
          "description": "Query parameters for YouTube search.list.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "www",
              "googleapis",
              "com"
            ],
            "path": [
              "youtube",
              "v3",
              "search"
            ],
            "query": {
              "part": "snippet"
            },
            "protocol": "https"
          },
          "method": "GET",
          "headers": {
            "Accept": "application/json"
          }
        }
      },
      "canonical_data": {
        "name": "search_youtube_content",
        "inputs": {
          "optional": "All other search parameters are provided within aint_query and are optional with API defaults when unset. These include: q (keyword query supporting '-' for NOT and '|' for OR); type (limits returned resource types: video, channel, playlist; defaults to all three); order (sorting: date, rating, relevance, title, videoCount, viewCount; default relevance); pagination via pageToken and maxResults (default 5, up to 50); regional/language bias via regionCode (ISO 3166-1 alpha-2) and relevanceLanguage; time window via publishedAfter/publishedBefore (RFC3339 UTC); scoping by channelId or topicId; channelType (any, show); eventType (live, upcoming, completed; requires type include video); location-based search with location 'lat,lng' plus locationRadius with units (m, km, ft, mi; max 1000km), which requires type include video; video-specific filters that require type include video: videoType, videoCaption, videoLicense, videoDuration, videoDimension, videoCategoryId, videoDefinition, videoEmbeddable, videoSyndicated, videoPaidProductPlacement; safeSearch (moderate, none, strict; default moderate); and authorization-scoped flags forMine (videos owned by the authenticated user; requires type=video), forContentOwner (videos owned by a CMS content owner, typically with onBehalfOfContentOwner; requires authorization and type=video), and forDeveloper (videos uploaded via the developer's app; requires authorization). Unset keys use API defaults.",
          "required": [
            "aint_query: Required container object that carries all dynamic query parameters for the YouTube search.list request; without this object no search criteria can be provided.",
            "aint_query.part: Comma-separated list of response parts to include; must include 'snippet' at minimum to receive snippet metadata and is required by the API to determine response shape."
          ]
        },
        "intent": "Discover YouTube content by searching across videos, channels, and playlists with structured filters, returning resource IDs and snippet metadata in paginated results.",
        "context": "This is a retrieval-only YouTube search (search.list) interface. Defaults: part commonly set to 'snippet'; type defaults to video,channel,playlist; order defaults to relevance; safeSearch defaults to moderate; maxResults defaults to 5. Pagination is controlled by supplying pageToken to request specific pages. Time parameters use RFC3339 UTC; location must be 'lat,lng' with a radius that includes units. Dynamic query parameters are supported; any omitted parameters use the API's defaults. Use this tool for discovery/snippets, not for full item details, channel uploads listings, or analytics.",
        "outputs": "A paginated collection of YouTube search result items, each representing a video, channel, or playlist and containing its resource ID and corresponding snippet metadata; suitable for downstream tools that fetch full item details by ID or continue pagination.",
        "operation": "Search YouTube for videos, channels, and playlists and return IDs with snippet metadata",
        "preconditions": "The aint_query object must be provided and include a 'part' value that includes 'snippet'. If performing keyword discovery, a 'q' string should be supplied. When any video-specific filter (e.g., videoType, videoCaption, videoLicense, videoDuration, videoDimension, videoCategoryId, videoDefinition, videoEmbeddable, videoSyndicated, videoPaidProductPlacement) or eventType is used, 'type' must include 'video'. If 'location' is set, 'locationRadius' must also be set and 'type' must include 'video'; 'location' must be formatted as 'lat,lng' and 'locationRadius' must include a unit and not exceed 1000km. 'publishedAfter' and 'publishedBefore' must be RFC3339 UTC timestamps. 'regionCode' must be an ISO 3166-1 alpha-2 code. 'maxResults' must be between 1 and 50. Authorization is required to use forMine, forContentOwner (typically alongside onBehalfOfContentOwner), or forDeveloper, and forMine/forContentOwner require 'type' include 'video'.",
        "postconditions": "Read-only operation with no side effects; upon success, a page of search results with resource IDs and snippet metadata is produced.",
        "business_objects": [
          "YouTube video",
          "YouTube channel",
          "YouTube playlist",
          "Search result item",
          "Resource ID",
          "Snippet metadata"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "get_google_drive_metadata",
      "description": "Category tool for retrieval in storage: Retrieves Google Drive About metadata for the authenticated user, including user profile, storageQuota in bytes, import/export formats, limits, and capability flags, returning a JSON partial response containing only the requested fields. Call when you need account-level information, quota usage status, supported formats, maximum upload size, or service capability details to inform subsequent Drive operations. Do not call when you need file or folder contents, listings, changes, or permissions; use file/item retrieval, listing, changes, or permission tools instead. Requires: fields (string) using Google partial response syntax, a comma-separated list of field paths such as \"user,storageQuota,importFormats,exportFormats,maxUploadSizes\"; user must already be authenticated with scopes permitting metadata read. Rules: response is read-only and idempotent; if fields is empty or invalid, the call fails; only the specified fields are returned; pagination does not apply; results reflect the current user context. Keywords: google drive about, storage quota, user info, capabilities, import export formats, metadata retrieval, partial response.",
      "document": {
        "id": "3f436a68-1ad8-4c20-9dcc-7dd794d4241e",
        "name": "get_google_drive_metadata",
        "appName": "wwwgoogleapiscom",
        "tool_type": "general",
        "transport": "http",
        "description": "Category tool for retrieval in storage: Retrieves Google Drive About metadata for the authenticated user, including user profile, storageQuota in bytes, import/export formats, limits, and capability flags, returning a JSON partial response containing only the requested fields. Call when you need account-level information, quota usage status, supported formats, maximum upload size, or service capability details to inform subsequent Drive operations. Do not call when you need file or folder contents, listings, changes, or permissions; use file/item retrieval, listing, changes, or permission tools instead. Requires: fields (string) using Google partial response syntax, a comma-separated list of field paths such as \"user,storageQuota,importFormats,exportFormats,maxUploadSizes\"; user must already be authenticated with scopes permitting metadata read. Rules: response is read-only and idempotent; if fields is empty or invalid, the call fails; only the specified fields are returned; pagination does not apply; results reflect the current user context. Keywords: google drive about, storage quota, user info, capabilities, import export formats, metadata retrieval, partial response.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_query"
          ],
          "properties": {
            "aint_query": {
              "type": "object",
              "required": [
                "fields"
              ],
              "properties": {
                "fields": {
                  "type": "string",
                  "description": "Selector specifying which fields to return. Example: 'user,storageQuota'."
                }
              },
              "additionalProperties": false
            }
          },
          "description": "Dynamic inputs for about.get. Provide the 'fields' selector for partial response.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "www",
              "googleapis",
              "com"
            ],
            "path": [
              "drive",
              "v3",
              "about"
            ],
            "protocol": "https"
          },
          "method": "GET",
          "headers": {
            "Accept": "application/json",
            "Authorization": "Bearer $Authorization"
          }
        }
      },
      "canonical_data": {
        "name": "get_google_drive_metadata",
        "inputs": {
          "optional": "none",
          "required": [
            "aint_query: Container object for the about.get request parameters; it must be supplied and include the 'fields' selector to define the partial response.",
            "fields (inside aint_query): A required string using Google partial response syntax specifying which About fields to return (e.g., 'user,storageQuota,importFormats,exportFormats,maxUploadSizes'); it must be non-empty and valid to successfully retrieve only those fields."
          ]
        },
        "intent": "Retrieve account-level Google Drive \"About\" metadata for the authenticated user, limited to explicitly requested fields, to inform subsequent Drive operations about quotas, supported formats, limits, and capabilities.",
        "context": "Only the fields named in the 'fields' selector are returned (Google partial response). The 'fields' value is a comma-separated list of field paths such as 'user,storageQuota,importFormats,exportFormats,maxUploadSizes'. There is no pagination. The response reflects the current user context and permissions. If the 'fields' selector is empty or invalid, the call fails. The operation returns JSON and is read-only and idempotent.",
        "outputs": "A JSON object containing only the specified Google Drive About fields for the current authenticated user. Depending on the 'fields' selector, this can include user profile information, storageQuota values in bytes, supported importFormats and exportFormats, maxUploadSizes, service limits, and capability flags. These values can be used by downstream tools to determine quota status, validate permissible upload sizes, select supported conversion formats, and check service capabilities before performing Drive operations.",
        "operation": "Retrieve requested fields from the Google Drive About resource",
        "preconditions": "The caller must be authenticated as a Google user with scopes permitting Drive metadata read. The request must provide an aint_query object containing a valid, non-empty 'fields' selector that follows Google partial response syntax. The API endpoint must be accessible. Only the defined schema is allowed (no additional properties).",
        "postconditions": "No data is created, modified, or deleted; the operation is read-only and idempotent. Upon success, a snapshot of the requested About metadata for the current user is returned, restricted to the specified fields.",
        "business_objects": [
          "Google Drive About metadata"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "list_shared_google_drives",
      "description": "Retrieval tool for listing shared drives in content: enumerates Google Drive shared drives accessible to the caller, supporting pagination, domain-admin scope, and query filtering; returns drive metadata (e.g., id, name) and a next page token for continued retrieval. Call when you need a paginated list of shared drives the user or domain administrator can access, optionally filtered by a query. Do not call when you need to list files or folders within a drive, fetch details for a single drive by id, or create/update drives; use the appropriate file/folder listing or drive management tools instead. Requires: page_size integer in 1\u2013100, page_token string from a prior response, q string using Google Drive API v3 query syntax (e.g., name contains 'project'), and use_domain_admin_access boolean; all inputs must be known to the model before calling. Rules: if page_token is provided, continue the previous pagination using the same filter; if use_domain_admin_access is true, ensure the caller has domain admin privileges; if q is omitted, return all reachable shared drives; this operation is read-only and idempotent. Keywords: google drive api, shared drives, pagination, domain admin access, query filter, content listing, retrieval.",
      "document": {
        "id": "205802a2-1c5e-4cb0-b812-29bf5f3aed35",
        "name": "list_shared_google_drives",
        "appName": "wwwgoogleapiscom",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for listing shared drives in content: enumerates Google Drive shared drives accessible to the caller, supporting pagination, domain-admin scope, and query filtering; returns drive metadata (e.g., id, name) and a next page token for continued retrieval. Call when you need a paginated list of shared drives the user or domain administrator can access, optionally filtered by a query. Do not call when you need to list files or folders within a drive, fetch details for a single drive by id, or create/update drives; use the appropriate file/folder listing or drive management tools instead. Requires: page_size integer in 1\u2013100, page_token string from a prior response, q string using Google Drive API v3 query syntax (e.g., name contains 'project'), and use_domain_admin_access boolean; all inputs must be known to the model before calling. Rules: if page_token is provided, continue the previous pagination using the same filter; if use_domain_admin_access is true, ensure the caller has domain admin privileges; if q is omitted, return all reachable shared drives; this operation is read-only and idempotent. Keywords: google drive api, shared drives, pagination, domain admin access, query filter, content listing, retrieval.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aint_query": {
              "type": "object",
              "properties": {
                "q": {
                  "type": "string",
                  "description": "Query string to filter shared drives."
                },
                "pageSize": {
                  "type": "integer",
                  "description": "Maximum number of shared drives to return per page."
                },
                "pageToken": {
                  "type": "string",
                  "description": "Token to retrieve the next page of results."
                },
                "useDomainAdminAccess": {
                  "type": "boolean",
                  "description": "List all shared drives of the domain as a domain administrator."
                }
              },
              "description": "Query parameters for listing shared drives.",
              "additionalProperties": false
            }
          },
          "description": "Inputs for the drives.list endpoint.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "www",
              "googleapis",
              "com"
            ],
            "path": [
              "drive",
              "v3",
              "drives"
            ],
            "protocol": "https"
          },
          "method": "GET",
          "headers": {
            "Accept": "application/json"
          }
        }
      },
      "canonical_data": {
        "name": "list_shared_google_drives",
        "inputs": {
          "optional": "All inputs are provided within the aint_query object. It may include: q (a Google Drive API v3 query string to filter shared drives); pageSize (integer limit for results per page, constrained to 1\u2013100); pageToken (a token from a prior response to retrieve the next page, continuing with the same filter as when the token was issued); and useDomainAdminAccess (boolean to list all shared drives in the domain using domain administrator privileges). If q is omitted, the tool returns all reachable shared drives. These parameters control filtering and pagination only; none are mandatory.",
          "required": "none"
        },
        "intent": "Retrieve a paginated list of Google Drive shared drives accessible to the caller, optionally filtered by a Drive API query and with optional domain-admin scope.",
        "context": "Pagination is controlled via pageSize and pageToken; the response includes a next page token to continue retrieval. If a pageToken is supplied, the request must continue with the same filter used to obtain that token. If q is omitted, all reachable shared drives are returned. Setting useDomainAdminAccess expands scope to domain-wide listing when the caller has domain admin privileges. Inputs are nested under the aint_query container. This tool is only for listing shared drives, not for listing files/folders within a drive or fetching a single drive by ID.",
        "outputs": "A page of shared drive metadata (e.g., each shared drive record with fields such as id and name) and a next page token string for continued pagination. The drive records identify shared drives the caller can access (or all domain drives if domain-admin access is used), and the next page token can be passed back as pageToken to retrieve subsequent pages.",
        "operation": "List accessible shared drives",
        "preconditions": "The caller must have access to the Google Drive API and permission to view the shared drives being listed. If useDomainAdminAccess is true, the caller must have domain administrator privileges. If provided, pageSize must be an integer between 1 and 100. If provided, pageToken must be a valid token obtained from a prior response. If provided, q must use Google Drive API v3 query syntax.",
        "postconditions": "No resources are created, updated, or deleted; the operation is read-only and idempotent. Upon success, a list page of shared drives and an optional next page token are returned to the caller.",
        "business_objects": [
          "shared drive",
          "page token"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "create_shared_google_drive",
      "description": "Mutation tool for creating shared drives in content: Creates a Google Drive shared drive via Drive API v3 and returns the created Drive resource (id, name, capabilities, restrictions). Call when: provisioning a new shared drive for a team, project, or department within Google Drive. Do not call when: you need to create folders or files, list or update existing drives, or change membership/permissions; use the corresponding folder/file, list/update, or permissions tool instead. Requires: an OAuth access token authorized with scope https://www.googleapis.com/auth/drive; aint_query.requestId as a unique string (UUID recommended) for idempotency; aint_body.name as a non-empty string; additional aint_body Drive resource fields and aint_query parameters may be included as needed. Rules: if requestId is reused the operation is idempotent and returns the same drive; pass only valid Google Drive Drive resource fields in aint_body; this creates a shared drive (not a personal My Drive folder); the caller must have permission to create shared drives in the Google Workspace domain. Keywords: google drive api, shared drive, team drive, create drive, content management, oauth scope, requestId, gdrive.",
      "document": {
        "id": "53918902-a806-45a7-b0a4-a1e9eb70417e",
        "name": "create_shared_google_drive",
        "appName": "wwwgoogleapiscom",
        "tool_type": "general",
        "transport": "http",
        "description": "Mutation tool for creating shared drives in content: Creates a Google Drive shared drive via Drive API v3 and returns the created Drive resource (id, name, capabilities, restrictions). Call when: provisioning a new shared drive for a team, project, or department within Google Drive. Do not call when: you need to create folders or files, list or update existing drives, or change membership/permissions; use the corresponding folder/file, list/update, or permissions tool instead. Requires: an OAuth access token authorized with scope https://www.googleapis.com/auth/drive; aint_query.requestId as a unique string (UUID recommended) for idempotency; aint_body.name as a non-empty string; additional aint_body Drive resource fields and aint_query parameters may be included as needed. Rules: if requestId is reused the operation is idempotent and returns the same drive; pass only valid Google Drive Drive resource fields in aint_body; this creates a shared drive (not a personal My Drive folder); the caller must have permission to create shared drives in the Google Workspace domain. Keywords: google drive api, shared drive, team drive, create drive, content management, oauth scope, requestId, gdrive.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_body"
          ],
          "properties": {
            "aint_body": {
              "type": "object",
              "properties": {
                "name": {
                  "type": "string",
                  "description": "Name of the shared drive."
                }
              },
              "description": "Drive resource fields for the shared drive to create.",
              "additionalProperties": true
            },
            "aint_query": {
              "type": "object",
              "description": "Query parameters.",
              "additionalProperties": {
                "type": [
                  "string",
                  "number",
                  "boolean"
                ]
              }
            }
          },
          "description": "Dynamic inputs for creating a shared drive.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "www",
              "googleapis",
              "com"
            ],
            "path": [
              "drive",
              "v3",
              "drives"
            ],
            "protocol": "https"
          },
          "method": "POST",
          "headers": {
            "Accept": "application/json",
            "Content-Type": "application/json",
            "Authorization": "Bearer $Authorization"
          }
        }
      },
      "canonical_data": {
        "name": "create_shared_google_drive",
        "inputs": {
          "optional": "aint_query may include query parameters accepted by the Drive API v3 for drive creation, notably a requestId (a unique string, UUID recommended) to make the operation idempotent; additional query parameters may also be provided as strings, numbers, or booleans. The aint_body may include additional valid Google Drive Drive resource fields beyond name, as supported by the API.",
          "required": [
            {
              "name": "aint_body",
              "description": "Object containing the Drive resource fields for the shared drive to create. It defines the properties of the new shared drive (e.g., name) and is sent as the request body to the Drive API v3."
            }
          ]
        },
        "intent": "Programmatically create a new Google Drive shared drive and return its Drive resource metadata.",
        "context": "- This is a mutating operation that creates a shared drive (not a personal My Drive folder) via Google Drive API v3.\n- Idempotency is enforced via aint_query.requestId; reusing the same value returns the original result.\n- Only valid Drive resource fields should be passed in aint_body; top-level inputs are limited to aint_body and aint_query (no other top-level properties allowed).\n- aint_query supports dynamic query parameters (string, number, boolean types) as recognized by the Drive API.\n- Use this tool only for creating shared drives; use other tools for folders/files, listing/updating drives, or managing permissions.",
        "outputs": "A single Google Drive Drive resource object representing the created shared drive. The resource includes fields such as id, name, capabilities, and restrictions, which can be used to reference and operate on the shared drive in downstream tools (e.g., by using the id).",
        "operation": "create a shared drive",
        "preconditions": "- A valid OAuth access token authorized with scope https://www.googleapis.com/auth/drive is available.\n- The caller has permission within the Google Workspace domain to create shared drives.\n- aint_body contains valid Google Drive Drive resource fields and includes a non-empty name string.\n- aint_query.requestId is provided as a unique string (UUID recommended) to ensure idempotency.\n- The Google Drive API v3 is accessible.",
        "postconditions": "- If the requestId has not been used before, a new shared drive is created in Google Drive and its Drive resource is returned.\n- If the same requestId is reused, no duplicate shared drive is created; the operation is idempotent and returns the same Drive resource as the original call.\n- No membership, permissions, files, or folders are created or modified by this operation.",
        "business_objects": [
          "Google Drive shared drive"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "delete_shared_google_drive",
      "description": "Mutation tool for deletion in content: Permanently deletes a shared drive by its drive_id, optionally deleting items inside when executed with domain admin access; inputs are drive_id (string), use_domain_admin_access (boolean), and allow_item_deletion (boolean), and the result is a successful deletion or an error if preconditions are not met. Call when you need to irrevocably remove an entire shared drive and you have organizer permissions (or domain admin capabilities) and the drive has no untrashed items unless you explicitly allow item deletion. Do not call when you want to delete individual files or folders, empty trash, modify drive settings, or change membership; use file deletion, trash, settings, or membership tools instead. Requires: drive_id as an opaque string identifier; organizer role on the target shared drive; if allow_item_deletion=true, set use_domain_admin_access=true; if allow_item_deletion=false or not set, the drive must contain no untrashed items. Rules: Operation is permanent and cannot be undone; if allow_item_deletion=true with domain admin access, all items inside the shared drive are also deleted; the request is idempotent\u2014repeating after a successful deletion yields a not found; allow_item_deletion is only valid when use_domain_admin_access is true. Keywords: shared drive deletion, Google Drive, domain admin access, organizer role, permanent delete, content management, API mutation, drive removal.",
      "document": {
        "id": "d4983ffc-36d1-4454-bec1-73525f4525f1",
        "name": "delete_shared_google_drive",
        "appName": "wwwgoogleapiscom",
        "tool_type": "general",
        "transport": "http",
        "description": "Mutation tool for deletion in content: Permanently deletes a shared drive by its drive_id, optionally deleting items inside when executed with domain admin access; inputs are drive_id (string), use_domain_admin_access (boolean), and allow_item_deletion (boolean), and the result is a successful deletion or an error if preconditions are not met. Call when you need to irrevocably remove an entire shared drive and you have organizer permissions (or domain admin capabilities) and the drive has no untrashed items unless you explicitly allow item deletion. Do not call when you want to delete individual files or folders, empty trash, modify drive settings, or change membership; use file deletion, trash, settings, or membership tools instead. Requires: drive_id as an opaque string identifier; organizer role on the target shared drive; if allow_item_deletion=true, set use_domain_admin_access=true; if allow_item_deletion=false or not set, the drive must contain no untrashed items. Rules: Operation is permanent and cannot be undone; if allow_item_deletion=true with domain admin access, all items inside the shared drive are also deleted; the request is idempotent\u2014repeating after a successful deletion yields a not found; allow_item_deletion is only valid when use_domain_admin_access is true. Keywords: shared drive deletion, Google Drive, domain admin access, organizer role, permanent delete, content management, API mutation, drive removal.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_path"
          ],
          "properties": {
            "aint_path": {
              "type": "object",
              "required": [
                "driveId"
              ],
              "properties": {
                "driveId": {
                  "type": "string",
                  "description": "The ID of the shared drive."
                }
              },
              "description": "Dynamic path parameters.",
              "additionalProperties": false
            },
            "aint_query": {
              "type": "object",
              "properties": {
                "allowItemDeletion": {
                  "type": "boolean",
                  "description": "Also delete items inside the shared drive; only supported when useDomainAdminAccess is true."
                },
                "useDomainAdminAccess": {
                  "type": "boolean",
                  "description": "Issue the request as a domain administrator."
                }
              },
              "description": "Optional query parameters.",
              "additionalProperties": false
            }
          },
          "description": "Dynamic inputs for deleting a shared drive.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "www",
              "googleapis",
              "com"
            ],
            "path": [
              "drive",
              "v3",
              "drives",
              "$driveId"
            ],
            "protocol": "https"
          },
          "method": "DELETE"
        }
      },
      "canonical_data": {
        "name": "delete_shared_google_drive",
        "inputs": {
          "optional": "Optional query parameters control execution context and scope of deletion: useDomainAdminAccess (boolean) issues the request as a domain administrator; allowItemDeletion (boolean) requests cascading deletion of all items inside the shared drive. allowItemDeletion is only valid when useDomainAdminAccess is true; if allowItemDeletion is false or unset, the shared drive must have no untrashed items. These options are supplied via the aint_query object.",
          "required": [
            "driveId (string, path parameter): The opaque ID of the target shared drive to delete; it uniquely identifies which shared drive the operation will permanently remove."
          ]
        },
        "intent": "Permanently remove a Google Drive shared drive, with an option (when using domain admin access) to also delete all items it contains.",
        "context": "This is a mutating Google Drive operation targeting shared drives. It uses a path parameter (driveId) and optional query parameters (useDomainAdminAccess, allowItemDeletion). Deletion is permanent and cannot be undone. When not allowing item deletion, the drive must be free of untrashed items (trashed items may remain). If item deletion is allowed, it requires domain admin access and causes all items within the shared drive to be deleted as well. The endpoint is idempotent\u2014subsequent calls after success will report the drive as not found. Do not use this for deleting individual files/folders, emptying trash, changing settings, or managing memberships.",
        "outputs": "On success, the operation completes with no response body (deletion of the specified shared drive is effected). If preconditions are not met (e.g., permission or state constraints), an error is returned instead. The absence of the drive thereafter can serve as a signal to downstream tools that the drive and, if requested, its contents no longer exist.",
        "operation": "permanently delete a shared drive",
        "preconditions": "The target shared drive identified by driveId must exist. The caller must have organizer role on the shared drive or have domain admin capabilities. If allowItemDeletion is true, useDomainAdminAccess must be true. If allowItemDeletion is false or not set, the shared drive must contain no untrashed items. allowItemDeletion is invalid when useDomainAdminAccess is false. The Google Drive API must be accessible.",
        "postconditions": "The shared drive is permanently deleted. If invoked with useDomainAdminAccess=true and allowItemDeletion=true, all items inside that shared drive are also permanently deleted. The operation is irreversible. The request is idempotent: repeating it after a successful deletion results in the drive being not found.",
        "business_objects": [
          "shared drive",
          "drive items"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "retrieve_google_drive_file_by_id",
      "description": "Retrieval tool for fetching file metadata or content in content storage: given a Google Drive fileId, it returns JSON metadata by default or raw file bytes when query alt='media', with optional inclusion of labels and published permissions views. Call when you need to obtain a known Google Drive file\u2019s metadata or download its contents by fileId; do not call when you need to search/list files, upload/update/delete files, or access non-Google Drive storage. Requires fileId (string); optional alt='media' to stream content bytes, supportsAllDrives (boolean) for shared drives, acknowledgeAbuse (boolean) when downloading flagged content, includeLabels (comma-separated label IDs), and includePermissionsForView='published'; HTTP headers may be provided as needed. Rules: GET is idempotent; if alt='media' is set, the response is raw file content and metadata fields are omitted; prefer supportsAllDrives over deprecated supportsTeamDrives; downloading abusive files requires acknowledgeAbuse=true. Keywords: google drive, drive api v3, files.get, file metadata, download file, shared drives, alt=media, acknowledge abuse.",
      "document": {
        "id": "2a2c34fc-7423-4b89-86dc-76cd285d471b",
        "name": "retrieve_google_drive_file_by_id",
        "appName": "wwwgoogleapiscom",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for fetching file metadata or content in content storage: given a Google Drive fileId, it returns JSON metadata by default or raw file bytes when query alt='media', with optional inclusion of labels and published permissions views. Call when you need to obtain a known Google Drive file\u2019s metadata or download its contents by fileId; do not call when you need to search/list files, upload/update/delete files, or access non-Google Drive storage. Requires fileId (string); optional alt='media' to stream content bytes, supportsAllDrives (boolean) for shared drives, acknowledgeAbuse (boolean) when downloading flagged content, includeLabels (comma-separated label IDs), and includePermissionsForView='published'; HTTP headers may be provided as needed. Rules: GET is idempotent; if alt='media' is set, the response is raw file content and metadata fields are omitted; prefer supportsAllDrives over deprecated supportsTeamDrives; downloading abusive files requires acknowledgeAbuse=true. Keywords: google drive, drive api v3, files.get, file metadata, download file, shared drives, alt=media, acknowledge abuse.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_path"
          ],
          "properties": {
            "aint_path": {
              "type": "object",
              "required": [
                "fileId"
              ],
              "properties": {
                "fileId": {
                  "type": "string",
                  "description": "The ID of the file."
                }
              },
              "description": "Path parameters.",
              "additionalProperties": false
            },
            "aint_query": {
              "type": "object",
              "properties": {
                "alt": {
                  "type": "string",
                  "description": "Use 'media' to return file contents."
                },
                "includeLabels": {
                  "type": "string",
                  "description": "Comma-separated label IDs to include."
                },
                "acknowledgeAbuse": {
                  "type": "boolean",
                  "description": "Acknowledge risk when downloading known malware or abusive files."
                },
                "supportsAllDrives": {
                  "type": "boolean",
                  "description": "Whether the application supports both My Drives and shared drives."
                },
                "supportsTeamDrives": {
                  "type": "boolean",
                  "description": "Deprecated: Use supportsAllDrives instead."
                },
                "includePermissionsForView": {
                  "enum": [
                    "published"
                  ],
                  "type": "string",
                  "description": "Only 'published' is supported."
                }
              },
              "description": "Query parameters.",
              "additionalProperties": false
            },
            "aint_headers": {
              "type": "object",
              "description": "Optional HTTP headers.",
              "additionalProperties": {
                "type": [
                  "string",
                  "number",
                  "boolean"
                ]
              }
            }
          },
          "description": "Dynamic inputs for Drive files.get.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "www",
              "googleapis",
              "com"
            ],
            "path": [
              "drive",
              "v3",
              "files",
              "$fileId"
            ],
            "protocol": "https"
          },
          "method": "GET"
        }
      },
      "canonical_data": {
        "name": "retrieve_google_drive_file_by_id",
        "inputs": {
          "optional": "Query parameters and headers that modify retrieval behavior: alt='media' returns raw file bytes and omits metadata; includeLabels accepts a comma-separated list of label IDs to include in the metadata; includePermissionsForView supports only 'published' to include the published permissions view; supportsAllDrives indicates the application supports accessing files in both My Drive and shared drives (preferred over the deprecated supportsTeamDrives); acknowledgeAbuse must be set to true to download files flagged as abusive or malware; optional HTTP headers may be supplied. Only the defined path and query parameters are accepted; unspecified extra parameters are not allowed.",
          "required": [
            "aint_path: Path parameters container that must be provided; it encapsulates the fileId used to route and identify the target file.",
            "aint_path.fileId: The unique Google Drive file identifier specifying which file to retrieve; required for both metadata and content retrieval."
          ]
        },
        "intent": "Fetch a specific Google Drive file either as JSON metadata or as raw content bytes, identified by its fileId.",
        "context": "Implements Google Drive API v3 files.get via an idempotent GET. Default behavior returns JSON metadata; alt='media' switches the response to raw content and omits metadata. includeLabels is a comma-separated list, and includePermissionsForView only accepts 'published'. supportsAllDrives should be preferred over deprecated supportsTeamDrives when working with shared drives. Downloading abusive content requires acknowledgeAbuse=true. Optional HTTP headers may be supplied. The schema disallows unspecified path/query parameters (additionalProperties=false).",
        "outputs": "By default, a JSON object representing the specified Google Drive file\u2019s metadata (Drive API v3 files.get), optionally including requested labels and the 'published' permissions view. If alt='media' is provided, the response is the raw file content bytes stream and metadata fields are omitted. The returned metadata can provide identifiers and attributes for downstream tools; the raw bytes can be used where file content ingestion is required.",
        "operation": "Retrieve file metadata or content by fileId",
        "preconditions": "A valid Google Drive fileId must be provided in the path parameters. The caller must have access permissions to the file via the Google Drive API. To download content for files flagged as abusive or malware, acknowledgeAbuse must be true; otherwise content download will be blocked. If accessing files in shared drives, the application should indicate supportsAllDrives as appropriate.",
        "postconditions": "Read-only operation; no changes are made to the file or Drive state. After success, the caller receives either the file\u2019s JSON metadata or the raw file content bytes, depending on the query parameters.",
        "business_objects": [
          "Google Drive file",
          "Google Drive file metadata",
          "File content bytes"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "download_google_drive_file_by_id",
      "description": "Category tool for retrieval in content: Downloads the binary content of a Google Drive file by ID, optionally exporting Google Workspace documents to a specified MIME type or returning the bytes of a specific revision; inputs include file_id (string), optional mime_type (MIME string like application/pdf), and optional revision_id (string), and the output is raw file bytes. Call when: you need to fetch file contents from Google Drive given a known file ID, export Docs/Sheets/Slides to a target format, or retrieve the content of a particular revision. Do not call when: listing or searching files, reading metadata or permissions, uploading or updating content, deleting items, or downloading from non-Google Drive sources; use listing, metadata, mutation, or external storage tools instead. Requires: file_id as a Google Drive file ID string; if exporting, provide mime_type as a valid MIME type; if targeting a revision, provide revision_id; caller must already have access rights to the file and be prepared to handle a binary response stream. Rules: mime_type applies only to Google Workspace documents and is ignored for non-Workspace files which return original bytes; if revision_id is set, that revision is downloaded and takes precedence over the current version; operation is read-only and idempotent, returning full content in a single response. Keywords: google drive, file download, export mime type, revision id, binary content, google workspace.",
      "document": {
        "id": "64723e5d-67eb-4ce0-8984-d2a6d58ffc66",
        "name": "download_google_drive_file_by_id",
        "appName": "wwwgoogleapiscom",
        "tool_type": "general",
        "transport": "http",
        "description": "Category tool for retrieval in content: Downloads the binary content of a Google Drive file by ID, optionally exporting Google Workspace documents to a specified MIME type or returning the bytes of a specific revision; inputs include file_id (string), optional mime_type (MIME string like application/pdf), and optional revision_id (string), and the output is raw file bytes. Call when: you need to fetch file contents from Google Drive given a known file ID, export Docs/Sheets/Slides to a target format, or retrieve the content of a particular revision. Do not call when: listing or searching files, reading metadata or permissions, uploading or updating content, deleting items, or downloading from non-Google Drive sources; use listing, metadata, mutation, or external storage tools instead. Requires: file_id as a Google Drive file ID string; if exporting, provide mime_type as a valid MIME type; if targeting a revision, provide revision_id; caller must already have access rights to the file and be prepared to handle a binary response stream. Rules: mime_type applies only to Google Workspace documents and is ignored for non-Workspace files which return original bytes; if revision_id is set, that revision is downloaded and takes precedence over the current version; operation is read-only and idempotent, returning full content in a single response. Keywords: google drive, file download, export mime type, revision id, binary content, google workspace.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_path"
          ],
          "properties": {
            "aint_path": {
              "type": "object",
              "required": [
                "fileId"
              ],
              "properties": {
                "fileId": {
                  "type": "string",
                  "description": "The ID of the file to download."
                }
              },
              "additionalProperties": false
            },
            "aint_query": {
              "type": "object",
              "properties": {
                "mimeType": {
                  "type": "string",
                  "description": "Optional MIME type for exporting Google Workspace files."
                },
                "revisionId": {
                  "type": "string",
                  "description": "Optional revision ID to download."
                }
              },
              "additionalProperties": false
            },
            "aint_headers": {
              "type": "object",
              "additionalProperties": {
                "type": [
                  "string",
                  "number",
                  "boolean"
                ]
              }
            }
          },
          "description": "Dynamic inputs for Google Drive files.download.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "www",
              "googleapis",
              "com"
            ],
            "path": [
              "drive",
              "v3",
              "files",
              "$fileId",
              "download"
            ],
            "protocol": "https"
          },
          "method": "POST",
          "headers": {
            "Authorization": "Bearer $Authorization"
          }
        }
      },
      "canonical_data": {
        "name": "download_google_drive_file_by_id",
        "inputs": {
          "optional": "Query parameters may include mimeType to export Google Workspace documents (e.g., Docs/Sheets/Slides) to a specified MIME type like application/pdf, and revisionId to download the bytes of a particular revision (which takes precedence over the current version). Headers may be supplied as arbitrary key-value pairs. The mimeType is ignored for non-Google Workspace files, which return their original bytes.",
          "required": [
            "aint_path: Container for path parameters; must include the fileId that identifies which Google Drive file to download.",
            "fileId: The Google Drive file ID of the target file whose content will be fetched; it uniquely specifies the resource to download."
          ]
        },
        "intent": "Retrieve the raw binary content of a specific Google Drive file by its ID, with optional export of Google Workspace documents to a requested MIME type or download of a specific revision.",
        "context": "This tool targets Google Drive files.download behavior. The response is a single, complete binary stream (not paginated). The mimeType option applies only to Google Workspace documents and is ignored for non-Workspace files. If revisionId is provided, that revision is downloaded and overrides the current version. Use this tool only for content retrieval (not for listing, searching, metadata, permissions, mutation, deletion, or non-Google Drive sources). Inputs are structured with aint_path for path parameters and aint_query for query parameters; aint_headers may include arbitrary headers.",
        "outputs": "A single binary payload (raw file bytes) representing the file\u2019s content. For non-Google Workspace files, these are the original bytes. For Google Workspace documents, if a mimeType is provided, the returned bytes are the exported content in that format. If a revisionId is provided, the bytes correspond to that specific revision. These bytes can be consumed by downstream tools that accept binary data (e.g., storage, conversion, parsing, or upload utilities).",
        "operation": "download file content",
        "preconditions": "A valid Google Drive file ID must be provided in aint_path.fileId. The caller must have access rights to read the file. If exporting a Google Workspace document, the mimeType must be a valid export MIME type for that document type. If a revisionId is provided, it must refer to an existing revision of the file. The Google Drive API must be reachable.",
        "postconditions": "No changes are made to Google Drive or the file; the operation is read-only and idempotent. Upon success, the full file content is returned in a single response, either as the original bytes or as exported bytes if a valid mimeType for a Google Workspace document is supplied, and as the specified revision\u2019s bytes if revisionId is set.",
        "business_objects": [
          "Google Drive file",
          "file revision"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "upload_google_drive_file",
      "description": "Mutation tool for uploading files in content: creates a new Google Drive file via the /upload endpoint using media, multipart, or resumable modes; accepts upload parameters, headers, and payload and returns either the created file metadata or a resumable session URL. Call when you need to add a new binary or multipart file to Google Drive or start a resumable upload session. Do not call when updating an existing file\u2019s metadata, listing or searching files, or downloading content; use the appropriate metadata update, listing, or download tools instead. Requires: uploadType set to one of media|multipart|resumable in query, a valid Content-Type header, and aint_body containing raw bytes for media, a complete multipart/related payload with boundary for multipart, or JSON metadata for resumable initiation; include optional name and parents in JSON metadata; set X-Upload-Content-Type and X-Upload-Content-Length (integer bytes) headers when starting resumable. Rules: repeated calls are not idempotent and create duplicates; for media uploads metadata sent via query is limited\u2014prefer multipart for metadata + content; if uploadType is resumable this call only initiates the session and does not send chunks; ensure byte sizes are in _bytes and any timestamps in metadata use RFC3339 UTC. Keywords: Google Drive, file upload, media upload, multipart upload, resumable session, cloud storage, content-type headers, JSON metadata.",
      "document": {
        "id": "62a8416e-cb1e-4bbb-a392-6b990c923b8c",
        "name": "upload_google_drive_file",
        "appName": "wwwgoogleapiscom",
        "tool_type": "general",
        "transport": "http",
        "description": "Mutation tool for uploading files in content: creates a new Google Drive file via the /upload endpoint using media, multipart, or resumable modes; accepts upload parameters, headers, and payload and returns either the created file metadata or a resumable session URL. Call when you need to add a new binary or multipart file to Google Drive or start a resumable upload session. Do not call when updating an existing file\u2019s metadata, listing or searching files, or downloading content; use the appropriate metadata update, listing, or download tools instead. Requires: uploadType set to one of media|multipart|resumable in query, a valid Content-Type header, and aint_body containing raw bytes for media, a complete multipart/related payload with boundary for multipart, or JSON metadata for resumable initiation; include optional name and parents in JSON metadata; set X-Upload-Content-Type and X-Upload-Content-Length (integer bytes) headers when starting resumable. Rules: repeated calls are not idempotent and create duplicates; for media uploads metadata sent via query is limited\u2014prefer multipart for metadata + content; if uploadType is resumable this call only initiates the session and does not send chunks; ensure byte sizes are in _bytes and any timestamps in metadata use RFC3339 UTC. Keywords: Google Drive, file upload, media upload, multipart upload, resumable session, cloud storage, content-type headers, JSON metadata.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aint_body": {
              "type": "string",
              "description": "Upload payload. For uploadType=media, provide raw file bytes. For uploadType=multipart, provide the full multipart/related payload. For uploadType=resumable (initial request), provide JSON metadata."
            },
            "aint_path": {
              "type": "object",
              "description": "Path parameters.",
              "additionalProperties": {
                "type": [
                  "string",
                  "number",
                  "boolean"
                ]
              }
            },
            "aint_query": {
              "type": "object",
              "description": "Upload query parameters.",
              "additionalProperties": {
                "type": [
                  "string",
                  "number",
                  "boolean"
                ]
              }
            },
            "aint_headers": {
              "type": "object",
              "description": "Headers for media/multipart content.",
              "additionalProperties": {
                "type": [
                  "string",
                  "number",
                  "boolean"
                ]
              }
            }
          },
          "description": "Dynamic inputs for files.create upload requests via /upload."
        },
        "staticInput": {
          "url": {
            "host": [
              "www",
              "googleapis",
              "com"
            ],
            "path": [
              "upload",
              "drive",
              "v3",
              "files"
            ],
            "protocol": "https"
          },
          "method": "POST",
          "headers": {
            "Accept": "application/json"
          }
        }
      },
      "canonical_data": {
        "name": "upload_google_drive_file",
        "inputs": {
          "optional": "Accepts dynamic request components for Google Drive /upload: aint_query for upload parameters (including the uploadType value: media, multipart, or resumable); aint_headers for content-related headers (e.g., Content-Type for all uploads; X-Upload-Content-Type and X-Upload-Content-Length in bytes when initiating resumable); aint_body for the actual upload payload (raw file bytes for media uploads; a complete multipart/related payload with boundary for multipart; JSON file metadata for resumable initiation, optionally including name and parents); and aint_path for any path parameters. Metadata constraints include byte sizes expressed in bytes and any timestamps in RFC3339 UTC. For media uploads, metadata provided via query is limited; multipart should be used when sending both metadata and content.",
          "required": "none"
        },
        "intent": "Create a new file in Google Drive or start a resumable upload session via the /upload endpoint using media, multipart, or resumable modes.",
        "context": "Operates against the Google Drive /upload endpoint. Supports three modes: media (raw bytes, limited metadata via query), multipart (both metadata and content in multipart/related), and resumable (initializes a session; chunks are sent later). Proper headers are required per mode, including Content-Type and, for resumable initiation, X-Upload-Content-Type and X-Upload-Content-Length. Metadata should observe RFC3339 UTC for timestamps and use byte counts for sizes. Repeated calls create duplicates. This tool performs creation/upload only and should not be used for metadata updates, listing/search, or download.",
        "outputs": "Either the created Google Drive file metadata (for media and multipart uploads) or a resumable upload session URL (for resumable initiation). The file metadata represents the newly created Drive file and can be used by other tools that reference file IDs or attributes. The resumable session URL is used by subsequent chunked upload requests to complete the file content transfer.",
        "operation": "create a Google Drive file or initiate a resumable upload session",
        "preconditions": "The uploadType query parameter must be set to one of media, multipart, or resumable; a valid Content-Type header must be provided. The request body must match the selected mode: raw file bytes for media, a full multipart/related payload with a boundary for multipart, or JSON file metadata for resumable initiation. When initiating a resumable upload, X-Upload-Content-Type and X-Upload-Content-Length (integer bytes) headers must be set. Any metadata timestamps must use RFC3339 UTC, and byte sizes must be expressed in bytes. This tool is not for updating existing metadata, listing/searching files, or downloading content.",
        "postconditions": "For media or multipart uploads, a new Google Drive file is created and its metadata is returned. For resumable uploads, a resumable session is initiated and a session URL is returned; content chunks are not uploaded by this call. Calls are not idempotent\u2014repeated invocations create duplicate files or sessions.",
        "business_objects": [
          "Google Drive file",
          "resumable upload session"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "create_google_drive_file_metadata",
      "description": "Category tool for mutation in content: Creates a new Google Drive file resource with metadata only (no media upload) via files.create (POST https://www.googleapis.com/drive/v3/files), accepting optional query parameters and a metadata object (name, mimeType, parents, description), and returning the created file\u2019s id and metadata. Call when you need to create a file, folder, or shortcut entry in Google Drive without uploading content, or when pre-creating a placeholder for later content upload. Do not call when you need to upload file bytes or update an existing file\u2019s metadata; instead use a media upload endpoint (multipart/resumable files.create with an uploadType) for content or a metadata update tool (files.update) for changes to an existing item. Requires: aint_body object with name (string; include a meaningful extension) and optionally mimeType (string; required for Google-native types such as application/vnd.google-apps.folder or application/vnd.google-apps.shortcut); parents is an array of folder_ids (strings); description is optional; aint_query may include valid Drive v3 parameters such as supportsAllDrives or fields. Rules: this operation is metadata-only and will not upload bytes; if parents is omitted the item is created in the My Drive root; duplicate names are allowed and do not overwrite existing items; multiple parent ids place the item in all specified folders where Drive permits. Keywords: google drive, files.create, metadata only, mimeType, folder creation, shortcut, parents array, placeholder file.",
      "document": {
        "id": "5ad0ade4-fc2b-4204-b191-ac7d16bc7408",
        "name": "create_google_drive_file_metadata",
        "appName": "wwwgoogleapiscom",
        "tool_type": "general",
        "transport": "http",
        "description": "Category tool for mutation in content: Creates a new Google Drive file resource with metadata only (no media upload) via files.create (POST https://www.googleapis.com/drive/v3/files), accepting optional query parameters and a metadata object (name, mimeType, parents, description), and returning the created file\u2019s id and metadata. Call when you need to create a file, folder, or shortcut entry in Google Drive without uploading content, or when pre-creating a placeholder for later content upload. Do not call when you need to upload file bytes or update an existing file\u2019s metadata; instead use a media upload endpoint (multipart/resumable files.create with an uploadType) for content or a metadata update tool (files.update) for changes to an existing item. Requires: aint_body object with name (string; include a meaningful extension) and optionally mimeType (string; required for Google-native types such as application/vnd.google-apps.folder or application/vnd.google-apps.shortcut); parents is an array of folder_ids (strings); description is optional; aint_query may include valid Drive v3 parameters such as supportsAllDrives or fields. Rules: this operation is metadata-only and will not upload bytes; if parents is omitted the item is created in the My Drive root; duplicate names are allowed and do not overwrite existing items; multiple parent ids place the item in all specified folders where Drive permits. Keywords: google drive, files.create, metadata only, mimeType, folder creation, shortcut, parents array, placeholder file.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_body"
          ],
          "properties": {
            "aint_body": {
              "type": "object",
              "properties": {
                "name": {
                  "type": "string",
                  "description": "File name. Include an appropriate extension, e.g., 'document.pdf'."
                },
                "parents": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "IDs of parent folders to contain the file."
                },
                "mimeType": {
                  "type": "string",
                  "description": "MIME type of the file or special Google type (e.g., application/vnd.google-apps.folder, application/vnd.google-apps.shortcut)."
                },
                "description": {
                  "type": "string",
                  "description": "File description."
                }
              },
              "description": "File metadata object. Common fields include name, mimeType, parents, description."
            },
            "aint_query": {
              "type": "object",
              "description": "Query parameters.",
              "additionalProperties": {
                "type": [
                  "string",
                  "number",
                  "boolean"
                ]
              }
            }
          },
          "description": "Dynamic inputs for files.create metadata-only requests.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "www",
              "googleapis",
              "com"
            ],
            "path": [
              "drive",
              "v3",
              "files"
            ],
            "protocol": "https"
          },
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer $Authorization"
          }
        }
      },
      "canonical_data": {
        "name": "create_google_drive_file_metadata",
        "inputs": {
          "optional": "All properties within aint_body are optional per schema and can include: name to set the item\u2019s title, mimeType to declare the file type (required when creating Google-native items like folders or shortcuts), parents to place the item into one or more folders, and description for additional details. The aint_query object may include any valid Drive v3 query parameters, such as supportsAllDrives and fields. Behavioral rules: this call is metadata-only (no media bytes are uploaded); if parents is omitted, the item is created in the My Drive root; duplicate names are allowed and do not overwrite existing items; multiple parent IDs place the item into all specified folders where Drive permits.",
          "required": [
            "aint_body: The file metadata object defining the item to create. It carries fields such as name (recommended with a meaningful extension), mimeType (must be a Google-native type when creating folders or shortcuts, e.g., application/vnd.google-apps.folder or application/vnd.google-apps.shortcut), parents (folder IDs to contain the item), and description. This object is necessary to specify the new resource\u2019s properties for files.create."
          ]
        },
        "intent": "Create a new Google Drive item (file, folder, or shortcut) as a metadata-only resource without uploading any content.",
        "context": "Implements POST https://www.googleapis.com/drive/v3/files for metadata-only creation (no uploadType/media). Use this to create files, folders, shortcuts, or placeholders for later content upload. aint_query can include valid Drive v3 parameters (e.g., supportsAllDrives, fields) to influence behavior and partial responses. Rules: parents omitted creates in My Drive root; duplicate names are allowed; multiple parents are supported where Drive permits; Google-native types require the appropriate mimeType; including a meaningful filename extension is recommended. For uploading file bytes use multipart/resumable files.create with an uploadType; for modifying existing items use files.update.",
        "outputs": "A Google Drive file resource metadata object for the newly created item, including its id and other metadata fields (subject to any fields selection in the query). This id and metadata can be used by downstream tools for later content upload or further metadata updates.",
        "operation": "Create a metadata-only Google Drive file resource",
        "preconditions": "The aint_body object must be provided. If creating a Google-native item (e.g., folder or shortcut), mimeType must be set to the corresponding Google type. The operation must be a creation of a new item without media upload (do not use this for uploading file bytes or updating existing items). The Google Drive API v3 files.create endpoint must be accessible.",
        "postconditions": "A new Google Drive file resource is created with the specified metadata and no content uploaded. It exists in the specified parent folders or, if none provided, in the My Drive root. Duplicate names may now exist. If multiple parents were provided and permitted, the item is placed into all those folders.",
        "business_objects": [
          "Google Drive file resource",
          "File metadata"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "list_github_organizations",
      "description": "Retrieval tool for listing organizations in devops: Enumerates GitHub organizations and returns a paginated array of organization records, using integer cursor-based pagination via aint_query.since (organization_id) and aint_query.per_page (page size). Call when you need to enumerate or page through all GitHub organizations in ascending ID order. Do not call when you need to search by name, filter by attributes, get a specific organization's details, or list organizations for a particular user; use a dedicated search or organization detail/membership tool instead. Requires: aint_query.since as an integer organization_id greater than 0 (omit to start from the first page) and aint_query.per_page as an integer count in range 1\u2013100 (defaults to 30 if omitted). Rules: per_page values above 100 are capped at 100; use the last returned organization id as the next since value to continue pagination; unknown keys in aint_query are ignored; responses are read-only and idempotent. Keywords: GitHub organizations, pagination, since cursor, per_page limit, enumeration, devops, source control.",
      "document": {
        "id": "42c4aa46-f56e-42ce-b266-5cc722aa22a6",
        "name": "list_github_organizations",
        "appName": "apigithubcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for listing organizations in devops: Enumerates GitHub organizations and returns a paginated array of organization records, using integer cursor-based pagination via aint_query.since (organization_id) and aint_query.per_page (page size). Call when you need to enumerate or page through all GitHub organizations in ascending ID order. Do not call when you need to search by name, filter by attributes, get a specific organization's details, or list organizations for a particular user; use a dedicated search or organization detail/membership tool instead. Requires: aint_query.since as an integer organization_id greater than 0 (omit to start from the first page) and aint_query.per_page as an integer count in range 1\u2013100 (defaults to 30 if omitted). Rules: per_page values above 100 are capped at 100; use the last returned organization id as the next since value to continue pagination; unknown keys in aint_query are ignored; responses are read-only and idempotent. Keywords: GitHub organizations, pagination, since cursor, per_page limit, enumeration, devops, source control.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aint_query": {
              "type": "object",
              "properties": {
                "since": {
                  "type": "integer",
                  "description": "Only return organizations with an ID greater than this."
                },
                "per_page": {
                  "type": "integer",
                  "description": "Results per page (max 100). Default is 30."
                }
              },
              "description": "Query parameters.",
              "additionalProperties": {
                "type": [
                  "string",
                  "number",
                  "boolean"
                ]
              }
            }
          },
          "description": "Dynamic inputs for listing organizations. Fixed: aint_query now uses additionalProperties with simple types; explicit keys retained. Root additionalProperties is valid in Draft 2020-12.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "github",
              "com"
            ],
            "path": [
              "organizations"
            ],
            "protocol": "https"
          },
          "method": "GET",
          "headers": {
            "Accept": "application/vnd.github+json",
            "X-GitHub-Api-Version": "2022-11-28"
          }
        }
      },
      "canonical_data": {
        "name": "list_github_organizations",
        "inputs": {
          "optional": "Accepts a single top-level object with an aint_query object. aint_query.since (integer) limits results to organizations with IDs greater than this value; omit to start from the first page. aint_query.per_page (integer) sets the page size with a default of 30 and a hard cap of 100 (values above 100 are capped). Unknown keys inside aint_query are allowed but ignored; aint_query otherwise supports simple-typed additional properties. The top-level input must not include any properties other than aint_query. Use the last returned organization ID as the next aint_query.since value to continue pagination.",
          "required": "none"
        },
        "intent": "Enumerate GitHub organizations by returning a paginated list ordered by ascending organization ID using an integer cursor.",
        "context": "Integer cursor-based pagination using since (organization ID) and per_page (page size). Default per_page is 30; maximum effective per_page is 100 (larger values are capped). Omit since to start from the first page. Unknown keys in aint_query are ignored. Results are returned strictly for enumeration (not for search, filtering, user-specific memberships, or detailed organization data). Responses are read-only and idempotent.",
        "outputs": "A paginated array of organization records (each representing a GitHub organization) ordered by ascending organization ID. The records include organization identifiers, enabling the last organization\u2019s ID to be used as the since cursor for subsequent calls.",
        "operation": "List GitHub organizations with integer cursor-based pagination",
        "preconditions": "Top-level input must only contain the aint_query object. If provided, aint_query.since must be an integer greater than 0. If provided, aint_query.per_page must be an integer; values above 100 will be capped to 100. The API endpoint must be accessible. Filtering or searching beyond the since/per_page cursor semantics is not supported by this tool.",
        "postconditions": "Read-only, idempotent retrieval; no state is modified. On success, a page of organizations is returned in ascending ID order, and the last returned organization\u2019s ID can be used as the since cursor for the next page.",
        "business_objects": [
          "GitHub organization"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "get_github_organization_by_id",
      "description": "Retrieval tool for organization lookup in developer: Retrieves public metadata for a GitHub organization by its login name and returns fields such as id, login, name, description, avatar_url, html_url, created_at, and visibility. Call when: you need to resolve or verify a GitHub organization and obtain its profile details or identifiers for subsequent operations. Do not call when: you need repositories, members, teams, billing, or user profiles; use repository listing, membership, team, billing, or user tools instead. Requires: org (string, GitHub organization login, case-insensitive; do not include '@' or a URL; trim whitespace). Rules: read-only and idempotent; lookup is case-insensitive; returns not-found for missing orgs; no side effects; subject to GitHub rate limits; if the value refers to a user account, this tool does not return user data. Keywords: github organization, org metadata, developer api, organization profile, login lookup, read-only idempotent.",
      "document": {
        "id": "63a08306-dd5e-42f9-aee6-c53894412a9f",
        "name": "get_github_organization_by_id",
        "appName": "apigithubcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for organization lookup in developer: Retrieves public metadata for a GitHub organization by its login name and returns fields such as id, login, name, description, avatar_url, html_url, created_at, and visibility. Call when: you need to resolve or verify a GitHub organization and obtain its profile details or identifiers for subsequent operations. Do not call when: you need repositories, members, teams, billing, or user profiles; use repository listing, membership, team, billing, or user tools instead. Requires: org (string, GitHub organization login, case-insensitive; do not include '@' or a URL; trim whitespace). Rules: read-only and idempotent; lookup is case-insensitive; returns not-found for missing orgs; no side effects; subject to GitHub rate limits; if the value refers to a user account, this tool does not return user data. Keywords: github organization, org metadata, developer api, organization profile, login lookup, read-only idempotent.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_path"
          ],
          "properties": {
            "aint_path": {
              "type": "object",
              "required": [
                "org"
              ],
              "properties": {
                "org": {
                  "type": "string",
                  "description": "Organization name (case-insensitive)."
                }
              },
              "additionalProperties": false
            }
          },
          "description": "Dynamic inputs for retrieving an organization.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "github",
              "com"
            ],
            "path": [
              "orgs",
              "$org"
            ],
            "protocol": "https"
          },
          "method": "GET",
          "headers": {
            "Accept": "application/vnd.github+json",
            "X-GitHub-Api-Version": "2022-11-28"
          }
        }
      },
      "canonical_data": {
        "name": "get_github_organization_by_id",
        "inputs": {
          "optional": "No optional inputs are accepted; the schema disallows additional properties beyond aint_path with its required org.",
          "required": [
            "aint_path: Container object for path parameters required by the tool. It must be provided and contains the organization identifier used to perform the lookup.",
            "aint_path.org: The GitHub organization login name (string). Required to identify which organization to look up; the value is case-insensitive, must not include '@' or a URL, and should be trimmed of whitespace."
          ]
        },
        "intent": "Resolve a GitHub organization by its login and return its public profile metadata for verification or use in subsequent operations.",
        "context": "Lookup is case-insensitive. The tool returns not-found for missing organizations and does not return user data if the provided login refers to a user account. It is subject to GitHub rate limits. Inputs must not include '@' or a URL and should be trimmed. The tool is strictly read-only and has no side effects.",
        "outputs": "A single organization metadata record containing public fields such as id, login, name, description, avatar_url, html_url, created_at, and visibility. If the organization is missing, a not-found response is returned. These identifiers and URLs can be used by other tools that require an organization\u2019s ID or login.",
        "operation": "Retrieve a GitHub organization\u2019s public metadata by login",
        "preconditions": "The caller must supply the required aint_path object containing a valid org login string (case-insensitive, without '@' or a URL, trimmed). The GitHub API must be accessible and the request must not exceed GitHub\u2019s rate limits. The organization must exist to receive a non-not-found result.",
        "postconditions": "Read-only and idempotent: no resources are created, updated, or deleted. On success, the organization\u2019s public metadata is retrieved and returned; if the organization does not exist, a not-found result is produced.",
        "business_objects": [
          "GitHub organization"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "update_github_organization_by_id",
      "description": "Mutation tool for updating organization settings in source_control: updates a GitHub organization\u2019s profile metadata (name, company, public email, billing_email, blog, twitter_username, location, description), project/repository policies (has_organization_projects, has_repository_projects, default_repository_permission), member capabilities (members_can_create_repositories, members_allowed_repository_creation_type, members_can_create_internal/private/public_repositories, members_can_fork_private_repositories, members_can_create_pages/public_pages/private_pages), commit signoff, security defaults for new repositories (advanced security, Dependabot alerts/security updates, dependency graph, secret scanning, push protection), and deploy key policy via partial update to the specified org. Call when: you need to change org-level profile fields, default repository permissions, member creation/forking/pages privileges, or enable/disable org-wide security defaults for new repositories. Do not call when: you want to fetch organization details, manage individual repositories, teams, or members, or modify repository-specific settings; use read or repository/team/member management tools instead. Requires: org (string, organization login, case-insensitive) and one or more fields to update; default_repository_permission must be one of read|write|admin|none; twitter_username without '@'; description max 160 characters; URLs such as blog or custom link must be absolute https URLs; emails must be valid addresses. Rules: only provided fields are changed (others remain unchanged); if members_allowed_repository_creation_type is set, it takes precedence over members_can_create_internal/private/public_repositories; if members_can_create_repositories is false, creation-type settings are ignored; if secret_scanning_push_protection_custom_link is provided, also set secret_scanning_push_protection_custom_link_enabled=true; changes are idempotent and apply to the entire organization. Keywords: github organization, org settings, member permissions, repository defaults, security policies, secret scanning, dependabot, push protection.",
      "document": {
        "id": "f6b43bd4-d13f-4b68-94fd-8ea000dfaf23",
        "name": "update_github_organization_by_id",
        "appName": "apigithubcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Mutation tool for updating organization settings in source_control: updates a GitHub organization\u2019s profile metadata (name, company, public email, billing_email, blog, twitter_username, location, description), project/repository policies (has_organization_projects, has_repository_projects, default_repository_permission), member capabilities (members_can_create_repositories, members_allowed_repository_creation_type, members_can_create_internal/private/public_repositories, members_can_fork_private_repositories, members_can_create_pages/public_pages/private_pages), commit signoff, security defaults for new repositories (advanced security, Dependabot alerts/security updates, dependency graph, secret scanning, push protection), and deploy key policy via partial update to the specified org. Call when: you need to change org-level profile fields, default repository permissions, member creation/forking/pages privileges, or enable/disable org-wide security defaults for new repositories. Do not call when: you want to fetch organization details, manage individual repositories, teams, or members, or modify repository-specific settings; use read or repository/team/member management tools instead. Requires: org (string, organization login, case-insensitive) and one or more fields to update; default_repository_permission must be one of read|write|admin|none; twitter_username without '@'; description max 160 characters; URLs such as blog or custom link must be absolute https URLs; emails must be valid addresses. Rules: only provided fields are changed (others remain unchanged); if members_allowed_repository_creation_type is set, it takes precedence over members_can_create_internal/private/public_repositories; if members_can_create_repositories is false, creation-type settings are ignored; if secret_scanning_push_protection_custom_link is provided, also set secret_scanning_push_protection_custom_link_enabled=true; changes are idempotent and apply to the entire organization. Keywords: github organization, org settings, member permissions, repository defaults, security policies, secret scanning, dependabot, push protection.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_path",
            "aint_body"
          ],
          "properties": {
            "aint_body": {
              "type": "object",
              "properties": {
                "blog": {
                  "type": "string",
                  "description": "Blog URL."
                },
                "name": {
                  "type": "string",
                  "description": "Shorthand name of the company."
                },
                "email": {
                  "type": "string",
                  "description": "Publicly visible email address."
                },
                "company": {
                  "type": "string",
                  "description": "Company name."
                },
                "location": {
                  "type": "string",
                  "description": "Location."
                },
                "description": {
                  "type": "string",
                  "description": "Company description (max 160 characters)."
                },
                "billing_email": {
                  "type": "string",
                  "description": "Billing email address (not public)."
                },
                "twitter_username": {
                  "type": "string",
                  "description": "Company Twitter username."
                },
                "has_repository_projects": {
                  "type": "boolean",
                  "description": "Enable repository projects."
                },
                "members_can_create_pages": {
                  "type": "boolean",
                  "description": "Allow members to create GitHub Pages sites."
                },
                "has_organization_projects": {
                  "type": "boolean",
                  "description": "Enable organization projects."
                },
                "web_commit_signoff_required": {
                  "type": "boolean",
                  "description": "Require web commit signoff."
                },
                "default_repository_permission": {
                  "enum": [
                    "read",
                    "write",
                    "admin",
                    "none"
                  ],
                  "type": "string",
                  "description": "Default permission level for org repositories."
                },
                "members_can_create_public_pages": {
                  "type": "boolean",
                  "description": "Allow members to create public Pages sites."
                },
                "members_can_create_repositories": {
                  "type": "boolean",
                  "description": "Allow non-admin members to create repositories."
                },
                "members_can_create_private_pages": {
                  "type": "boolean",
                  "description": "Allow members to create private Pages sites."
                },
                "deploy_keys_enabled_for_repositories": {
                  "type": "boolean",
                  "description": "Allow deploy keys for repositories in the organization."
                },
                "members_can_fork_private_repositories": {
                  "type": "boolean",
                  "description": "Allow members to fork private repositories."
                },
                "members_can_create_public_repositories": {
                  "type": "boolean",
                  "description": "Allow members to create public repositories."
                },
                "members_can_create_private_repositories": {
                  "type": "boolean",
                  "description": "Allow members to create private repositories."
                },
                "members_allowed_repository_creation_type": {
                  "enum": [
                    "all",
                    "private",
                    "none"
                  ],
                  "type": "string",
                  "description": "Repository types non-admin members can create."
                },
                "members_can_create_internal_repositories": {
                  "type": "boolean",
                  "description": "Allow members to create internal repositories."
                },
                "secret_scanning_push_protection_custom_link": {
                  "type": "string",
                  "description": "Custom URL shown when push protection blocks a secret."
                },
                "secret_scanning_enabled_for_new_repositories": {
                  "type": "boolean",
                  "description": "Enable secret scanning by default (closing down notice)."
                },
                "dependency_graph_enabled_for_new_repositories": {
                  "type": "boolean",
                  "description": "Enable dependency graph by default (closing down notice)."
                },
                "advanced_security_enabled_for_new_repositories": {
                  "type": "boolean",
                  "description": "Enable GHAS by default for new repos (closing down notice)."
                },
                "dependabot_alerts_enabled_for_new_repositories": {
                  "type": "boolean",
                  "description": "Enable Dependabot alerts by default (closing down notice)."
                },
                "secret_scanning_push_protection_custom_link_enabled": {
                  "type": "boolean",
                  "description": "Show a custom link for push protection blocks."
                },
                "dependabot_security_updates_enabled_for_new_repositories": {
                  "type": "boolean",
                  "description": "Enable Dependabot security updates by default (closing down notice)."
                },
                "secret_scanning_push_protection_enabled_for_new_repositories": {
                  "type": "boolean",
                  "description": "Enable push protection by default (closing down notice)."
                }
              },
              "additionalProperties": false
            },
            "aint_path": {
              "type": "object",
              "required": [
                "org"
              ],
              "properties": {
                "org": {
                  "type": "string",
                  "description": "The organization name (case-insensitive)."
                }
              },
              "additionalProperties": false
            }
          },
          "description": "Dynamic inputs for updating an organization.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "github",
              "com"
            ],
            "path": [
              "orgs",
              "$org"
            ],
            "protocol": "https"
          },
          "method": "PATCH",
          "headers": {
            "Accept": "application/vnd.github+json",
            "Authorization": "$Authorization",
            "X-GitHub-Api-Version": "2022-11-28"
          }
        }
      },
      "canonical_data": {
        "name": "update_github_organization_by_id",
        "inputs": {
          "optional": "Within aint_body, all individual settings are optional and may be provided in any combination for a partial update. These include profile metadata (name, company, public email, billing_email, blog URL, twitter_username without '@', location, description up to 160 chars), project/repository policies (has_organization_projects, has_repository_projects, default_repository_permission constrained to read|write|admin|none), member capabilities and creation controls (members_can_create_repositories, members_allowed_repository_creation_type constrained to all|private|none, and per-type create flags for internal/private/public repos, forking of private repos, and Pages creation for public/private), commit signoff (web_commit_signoff_required), deploy key policy (deploy_keys_enabled_for_repositories), and security defaults for new repositories (advanced security, Dependabot alerts/security updates, dependency graph, secret scanning, push protection, plus an optional absolute https custom link shown when push protection blocks a secret with a corresponding enable flag). Only fields supplied are considered for update; omitted fields are left unchanged.",
          "required": [
            "aint_path: Object containing the path parameter that identifies the target organization. It must include org (the organization login, case-insensitive), which specifies which GitHub organization to update.",
            "aint_body: Object containing one or more fields to update on the organization. This request body holds the patchable settings (e.g., profile fields, project/repository policy flags, member permissions, deploy key policy, and security defaults for new repositories). At least one updatable field must be provided."
          ]
        },
        "intent": "Partially update a GitHub organization\u2019s org-wide settings and defaults across profile metadata, repository policies, member capabilities, and security defaults for new repositories.",
        "context": "This is a partial update (PATCH-like) to organization-level configuration: supply only the fields you want to change. The organization login is case-insensitive. Settings categories include profile metadata, project/repository policies, member permissions (including fork and Pages capabilities), deploy key enablement, and org-wide security defaults that apply to new repositories only (advanced security, dependency graph, Dependabot alerts/security updates, secret scanning, and push protection). Precedence rules apply for repository creation controls as described; only provided fields change, making the operation idempotent. Use this tool to modify organization-level settings, not to retrieve information or manage individual repositories, teams, or members.",
        "outputs": "The specification does not define a response schema. Treat this as a side-effecting update; any returned body or structure is unspecified and should not be relied upon as input to other tools.",
        "operation": "partially update organization settings",
        "preconditions": "The target organization must be specified via aint_path.org (case-insensitive). The request body (aint_body) must include at least one field to update. Input value constraints must be respected: default_repository_permission must be one of read, write, admin, or none; twitter_username must not include '@'; description must be at most 160 characters; URLs such as blog and any custom link must be absolute https URLs; email fields must be valid email addresses.",
        "postconditions": "On success, only the provided organization fields are updated; all other settings remain unchanged. The changes apply org-wide and are idempotent. If secret_scanning_push_protection_custom_link is supplied, secret_scanning_push_protection_custom_link_enabled will also be set to true. Effective member repository-creation policy reflects precedence rules (members_allowed_repository_creation_type, if set, overrides per-type booleans; if members_can_create_repositories is false, creation-type settings are ignored). Security default flags affect only new repositories.",
        "business_objects": [
          "GitHub organization",
          "organization settings"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "get_github_user_profile",
      "description": "Retrieval tool for fetching the current user's profile in identity: returns the authenticated account\u2019s public and private profile object, including identifiers, display fields, contact information, roles, and settings. Call when: you need the currently logged-in user\u2019s complete profile data (\u201cme\u201d context) for personalization, authorization checks, or account display. Do not call when: you need another user\u2019s profile by ID, to search users, or to modify profile data; use a user lookup or update tool instead. Requires: a valid authenticated session or token bound to the request; no explicit parameters are needed; ignore framework-specific aint_path and aint_query placeholders. Rules: read-only and idempotent; returns only the caller\u2019s profile regardless of any provided parameters; any extraneous inputs are ignored. Keywords: identity, user profile, me endpoint, authenticated user, account info, read-only, private fields, session token.",
      "document": {
        "id": "f3c998b0-1702-4021-bd9e-31f18aac9457",
        "name": "get_github_user_profile",
        "appName": "apigithubcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for fetching the current user's profile in identity: returns the authenticated account\u2019s public and private profile object, including identifiers, display fields, contact information, roles, and settings. Call when: you need the currently logged-in user\u2019s complete profile data (\u201cme\u201d context) for personalization, authorization checks, or account display. Do not call when: you need another user\u2019s profile by ID, to search users, or to modify profile data; use a user lookup or update tool instead. Requires: a valid authenticated session or token bound to the request; no explicit parameters are needed; ignore framework-specific aint_path and aint_query placeholders. Rules: read-only and idempotent; returns only the caller\u2019s profile regardless of any provided parameters; any extraneous inputs are ignored. Keywords: identity, user profile, me endpoint, authenticated user, account info, read-only, private fields, session token.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aint_path": {
              "type": "object",
              "properties": {},
              "additionalProperties": false
            },
            "aint_query": {
              "type": "object",
              "additionalProperties": {
                "type": [
                  "string",
                  "number",
                  "boolean"
                ]
              }
            }
          },
          "description": "No dynamic inputs required.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "github",
              "com"
            ],
            "path": [
              "user"
            ],
            "protocol": "https"
          },
          "method": "GET",
          "headers": {
            "Accept": "application/vnd.github+json",
            "Authorization": "Bearer $Authorization",
            "X-GitHub-Api-Version": "2022-11-28"
          }
        }
      },
      "canonical_data": {
        "name": "get_github_user_profile",
        "inputs": {
          "optional": "No explicit parameters are used. Framework placeholders may be present but are ignored: aint_path (if provided, must be an empty object) and aint_query (may contain arbitrary string/number/boolean key\u2013value pairs). Any supplied values do not affect behavior; the tool always returns the caller\u2019s own profile based on the bound authentication context.",
          "required": "none"
        },
        "intent": "Retrieve the currently authenticated user's complete account profile for identity-aware personalization, authorization checks, or account display.",
        "context": "This is a 'me' endpoint: it always returns only the caller\u2019s own profile and cannot be used to fetch other users. Extraneous or optional inputs are ignored. No pagination or filtering applies; the response is a single profile object. Schema constraints: top-level allows only aint_path and aint_query; aint_path cannot contain any properties (must be empty if present), and aint_query may include arbitrary string/number/boolean parameters, all of which are ignored. The operation is idempotent and read-only, returning both public and private profile fields due to the authenticated context.",
        "outputs": "A single user profile object for the authenticated account, including public and private fields such as identifiers, display attributes, contact information, roles, and settings. This object can provide downstream tools with the user\u2019s identifiers, roles, or configuration data for authorization, personalization, or messaging.",
        "operation": "retrieve the authenticated user's profile",
        "preconditions": "A valid authenticated session or token must be bound to the request to identify the caller. The identity service must be reachable. No other inputs are required.",
        "postconditions": "Read-only and idempotent: no resources are created, modified, or deleted. After success, the caller has the authenticated user\u2019s profile data.",
        "business_objects": [
          "user profile"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "update_github_user_profile",
      "description": "Mutation tool for updating profiles in identity: updates the authenticated user's public profile fields and returns the updated user profile record; inputs include user_id set to 'me' and any subset of fields: name (string), email (public email string), blog (absolute http(s) URL), twitter_username (string without '@' or null to clear), company (string), location (string), hireable (boolean), and bio (string). Call when modifying the logged-in user's public profile attributes. Do not call when reading profile data, updating passwords or private settings, managing other users, or creating/deleting accounts; use the appropriate retrieval or administrative tools instead. Requires: authenticated context; user_id must be exactly 'me'; provide at least one updatable field; use valid formats (email per common syntax, URL must be absolute http/https); booleans must be true/false. Rules: only provided fields are updated and unspecified fields remain unchanged; unknown fields are rejected; setting twitter_username to null removes the handle; repeated calls with the same payload are idempotent; updates affect only the caller\u2019s public profile. Keywords: user profile, identity, update profile, authenticated user, patch, public email, social username, bio.",
      "document": {
        "id": "4bdcfb56-c6fc-4e3b-b588-22a5330dfd62",
        "name": "update_github_user_profile",
        "appName": "apigithubcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Mutation tool for updating profiles in identity: updates the authenticated user's public profile fields and returns the updated user profile record; inputs include user_id set to 'me' and any subset of fields: name (string), email (public email string), blog (absolute http(s) URL), twitter_username (string without '@' or null to clear), company (string), location (string), hireable (boolean), and bio (string). Call when modifying the logged-in user's public profile attributes. Do not call when reading profile data, updating passwords or private settings, managing other users, or creating/deleting accounts; use the appropriate retrieval or administrative tools instead. Requires: authenticated context; user_id must be exactly 'me'; provide at least one updatable field; use valid formats (email per common syntax, URL must be absolute http/https); booleans must be true/false. Rules: only provided fields are updated and unspecified fields remain unchanged; unknown fields are rejected; setting twitter_username to null removes the handle; repeated calls with the same payload are idempotent; updates affect only the caller\u2019s public profile. Keywords: user profile, identity, update profile, authenticated user, patch, public email, social username, bio.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aint_body": {
              "type": "object",
              "properties": {
                "bio": {
                  "type": "string",
                  "description": "Short biography."
                },
                "blog": {
                  "type": "string",
                  "description": "New blog URL."
                },
                "name": {
                  "type": "string",
                  "description": "New name of the user."
                },
                "email": {
                  "type": "string",
                  "description": "Publicly visible email address."
                },
                "company": {
                  "type": "string",
                  "description": "New company."
                },
                "hireable": {
                  "type": "boolean",
                  "description": "Hiring availability."
                },
                "location": {
                  "type": "string",
                  "description": "New location."
                },
                "twitter_username": {
                  "type": [
                    "string",
                    "null"
                  ],
                  "description": "New Twitter username."
                }
              },
              "description": "User profile fields to update.",
              "additionalProperties": false
            },
            "aint_query": {
              "type": "object",
              "additionalProperties": {
                "type": [
                  "string",
                  "number",
                  "boolean"
                ]
              }
            }
          },
          "description": "Provide fields to update the authenticated user's profile."
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "github",
              "com"
            ],
            "path": [
              "user"
            ],
            "protocol": "https"
          },
          "method": "PATCH",
          "headers": {
            "Accept": "application/vnd.github+json",
            "Content-Type": "application/json",
            "Authorization": "Bearer $Authorization",
            "X-GitHub-Api-Version": "2022-11-28"
          }
        }
      },
      "canonical_data": {
        "name": "update_github_user_profile",
        "inputs": {
          "optional": "Provide a body object (aint_body) containing any subset of updatable profile fields: name (string), email (public email string, must follow common email syntax), blog (absolute http or https URL), twitter_username (string without '@' or null to clear), company (string), location (string), hireable (boolean), and bio (string). Only these keys are permitted (additionalProperties: false); unknown fields are rejected. At least one of these fields must be supplied for an update to occur; unspecified fields remain unchanged. An optional query object (aint_query) may include arbitrary string/number/boolean key-value pairs, though no specific query parameters are defined by the specification.",
          "required": "none"
        },
        "intent": "Modify the authenticated user's public profile by applying partial updates to allowed fields and return the resulting profile record.",
        "context": "This is a mutation (patch-like) operation that updates only supplied fields and rejects unknown fields. Repeated calls with the same payload produce the same result (idempotent). Use this tool solely for updating public profile attributes of the logged-in user; do not use it for reading profiles, changing passwords, altering private settings, managing other users, or account creation/deletion. Inputs must respect the specified format constraints. An optional query parameters object exists but has no defined semantics in this specification.",
        "outputs": "A single updated user profile record representing the authenticated user's public profile after applying the requested changes. This record can be used by downstream tools that require the user's current public profile attributes.",
        "operation": "update the authenticated user's public profile fields",
        "preconditions": "Caller must be authenticated. The operation targets only the authenticated user's profile (user_id must be exactly 'me' in the underlying API). At least one permitted profile field must be provided in aint_body. Field values must meet format constraints: email follows common email syntax; blog is an absolute http(s) URL; twitter_username is a string without '@' or null to remove it; hireable is a boolean. Only recognized fields are allowed (aint_body additionalProperties: false). The API endpoint must be reachable.",
        "postconditions": "On success, only the provided public profile fields of the authenticated user are updated; unspecified fields are unchanged. If twitter_username was set to null, the Twitter handle is cleared. The operation is idempotent for identical payloads. No other users' profiles are affected. The updated user profile record is returned.",
        "business_objects": [
          "user profile"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "get_github_public_user_by_id",
      "description": "Retrieval tool for fetching public user information in identity: Retrieves publicly available profile attributes for a user identified by a durable numeric account_id and returns a read-only user record. Call when: you need public user details given a known account_id and no mutation is required. Do not call when: you need to update a user, access private or sensitive fields, or you only possess other identifiers such as email or username; use a separate search or mapping tool instead. Requires: aint_path.account_id set to a positive base-10 integer (e.g., 12345); do not supply personally identifiable information beyond the ID; aint_query may be omitted. Rules: The operation is idempotent and read-only; only account_id is used\u2014ignore aint_query parameters; prefer account_id over other identifiers; if account_id is missing or non-integer, do not call. Keywords: user profile, identity, public data, account_id, directory lookup, read-only retrieval, user record.",
      "document": {
        "id": "362a62cd-6b04-4214-a429-2340097af5e4",
        "name": "get_github_public_user_by_id",
        "appName": "apigithubcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for fetching public user information in identity: Retrieves publicly available profile attributes for a user identified by a durable numeric account_id and returns a read-only user record. Call when: you need public user details given a known account_id and no mutation is required. Do not call when: you need to update a user, access private or sensitive fields, or you only possess other identifiers such as email or username; use a separate search or mapping tool instead. Requires: aint_path.account_id set to a positive base-10 integer (e.g., 12345); do not supply personally identifiable information beyond the ID; aint_query may be omitted. Rules: The operation is idempotent and read-only; only account_id is used\u2014ignore aint_query parameters; prefer account_id over other identifiers; if account_id is missing or non-integer, do not call. Keywords: user profile, identity, public data, account_id, directory lookup, read-only retrieval, user record.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_path"
          ],
          "properties": {
            "aint_path": {
              "type": "object",
              "required": [
                "account_id"
              ],
              "properties": {
                "account_id": {
                  "type": "integer",
                  "description": "Durable account ID of the user."
                }
              },
              "additionalProperties": false
            },
            "aint_query": {
              "type": "object",
              "additionalProperties": {
                "type": [
                  "string",
                  "number",
                  "boolean"
                ]
              }
            }
          },
          "description": "Provide the user's account_id as a path parameter.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "github",
              "com"
            ],
            "path": [
              "user",
              "$account_id"
            ],
            "protocol": "https"
          },
          "method": "GET",
          "headers": {
            "Accept": "application/vnd.github+json",
            "Authorization": "Bearer $Authorization",
            "X-GitHub-Api-Version": "2022-11-28"
          }
        }
      },
      "canonical_data": {
        "name": "get_github_public_user_by_id",
        "inputs": {
          "optional": "aint_query: An optional object that may include arbitrary key-value pairs (string, number, or boolean). These query parameters are ignored by this operation and do not affect behavior or results; they can be omitted entirely.",
          "required": [
            "aint_path: Object containing the path parameters for the request. It must be provided and cannot include unspecified properties. It serves as the container for the identifying account_id used to select the user.",
            "aint_path.account_id: Durable numeric identifier of the user (positive base-10 integer). This is the sole selector used to look up the user and is required to fetch the corresponding public, read-only user record."
          ]
        },
        "intent": "Retrieve a user's publicly available profile information by their durable numeric account_id without performing any mutations.",
        "context": "Only account_id is used to perform the lookup; any aint_query parameters are ignored. The call is idempotent and read-only, intended solely for retrieving public user details. The input schema allows only two top-level properties (aint_path and aint_query); aint_path itself disallows additional properties beyond account_id, while aint_query may contain arbitrary scalar-typed keys but they do not influence results. Prefer account_id over other identifiers; if only other identifiers (e.g., email or username) are available, a separate mapping/search tool should be used instead.",
        "outputs": "A single read-only user record containing the user's publicly available profile attributes corresponding to the provided account_id. This record represents public identity/profile data and can be used by downstream tools that accept public user details or the same account_id as input.",
        "operation": "retrieve public user profile by account_id",
        "preconditions": "A valid aint_path.account_id must be present and must be a positive base-10 integer. Only the account_id should be supplied as identifying information; no additional personally identifiable information should be provided. The endpoint must be accessible. If account_id is missing or non-integer, the tool should not be called.",
        "postconditions": "No server-side state is modified; the operation is read-only and idempotent. After successful execution, the caller has a public, read-only user record for the specified account_id.",
        "business_objects": [
          "user",
          "public user profile",
          "account_id"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "retrieve_github_user_profile_by_username",
      "description": "Retrieval tool for fetching public user profiles in identity: Retrieves publicly available GitHub user profile information by username and returns core account fields (e.g., login, name, bio, avatar URL, public counts, and created_at/updated_at timestamps) as JSON. Call when you need public account details for a specific GitHub user and you already know the exact username. Do not call when you need repositories, gists, events, organizations, private data, or when you only have a real name or email\u2014use a user search or repository retrieval tool instead. Requires: username (string) as the GitHub login without a leading '@'; timestamps, if returned, are RFC3339 UTC. Rules: read-only and idempotent; case-insensitive username lookup; returns only public fields; if the user does not exist, expect a not-found response; ignore extraneous query parameters unless explicitly documented. Keywords: github user, user profile, username lookup, public account data, identity, developer platform, account info, user details.",
      "document": {
        "id": "1117c25e-195b-48d8-8098-b79de6c23ea6",
        "name": "retrieve_github_user_profile_by_username",
        "appName": "apigithubcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for fetching public user profiles in identity: Retrieves publicly available GitHub user profile information by username and returns core account fields (e.g., login, name, bio, avatar URL, public counts, and created_at/updated_at timestamps) as JSON. Call when you need public account details for a specific GitHub user and you already know the exact username. Do not call when you need repositories, gists, events, organizations, private data, or when you only have a real name or email\u2014use a user search or repository retrieval tool instead. Requires: username (string) as the GitHub login without a leading '@'; timestamps, if returned, are RFC3339 UTC. Rules: read-only and idempotent; case-insensitive username lookup; returns only public fields; if the user does not exist, expect a not-found response; ignore extraneous query parameters unless explicitly documented. Keywords: github user, user profile, username lookup, public account data, identity, developer platform, account info, user details.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_path"
          ],
          "properties": {
            "aint_path": {
              "type": "object",
              "required": [
                "username"
              ],
              "properties": {
                "username": {
                  "type": "string",
                  "description": "GitHub username."
                }
              },
              "additionalProperties": false
            },
            "aint_query": {
              "type": "object",
              "additionalProperties": {
                "type": [
                  "string",
                  "number",
                  "boolean"
                ]
              }
            }
          },
          "description": "Provide the user's username as a path parameter.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "github",
              "com"
            ],
            "path": [
              "users",
              "$username"
            ],
            "protocol": "https"
          },
          "method": "GET",
          "headers": {
            "Accept": "application/vnd.github+json",
            "Authorization": "Bearer $Authorization",
            "X-GitHub-Api-Version": "2022-11-28"
          }
        }
      },
      "canonical_data": {
        "name": "retrieve_github_user_profile_by_username",
        "inputs": {
          "optional": "An optional aint_query object may include arbitrary query parameters (string, number, or boolean values), but these are ignored unless explicitly documented. There are no other optional path or body fields.",
          "required": [
            "aint_path: Container for path parameters. It is required because it carries the route-scoped values needed by the endpoint, specifically the username used to look up the profile.",
            "username: The target GitHub login name (provided inside aint_path) without a leading '@'. It specifies which user\u2019s public profile to retrieve; lookup is case-insensitive."
          ]
        },
        "intent": "Fetch a specific GitHub user\u2019s public profile using their username.",
        "context": "Username lookup is case-insensitive. The tool returns only publicly available fields. Timestamp fields, when present, use RFC3339 UTC format. Extraneous query parameters are accepted in aint_query but ignored unless documented. The operation returns a single resource (no pagination). The tool is not intended for repositories, gists, events, organizations, or private data.",
        "outputs": "On success, a JSON object containing public GitHub user account fields, including core profile attributes such as login (username), name, bio, avatar_url, public counts, and created_at/updated_at timestamps (RFC3339 UTC). These fields can be used by downstream tools that require a GitHub username (login), avatar URL, or profile metadata. If the user does not exist, the call returns a not-found response instead of a profile object.",
        "operation": "retrieve public GitHub user profile by username",
        "preconditions": "The request must include aint_path with a username string that represents the GitHub login (without a leading '@'). The input must conform to the schema (aint_path is required; aint_path must include username; additional properties in aint_path or at the top level are not allowed). Only public profile information is retrievable; private data is out of scope for this tool.",
        "postconditions": "Read-only and idempotent: no server-side state is created or modified. After a successful call, the caller has the user\u2019s public profile data in JSON form, or a not-found outcome if the user does not exist.",
        "business_objects": [
          "GitHub user profile"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "list_github_users",
      "description": "Category tool for retrieval in identity: Returns a paginated list of users ordered by sign-up time ascending; inputs are since (integer user_id threshold) and per_page (integer 1\u2013100, default 30), and the result is an array of user records for the requested page. Call when you need to browse users chronologically, iterate through all users page by page, or fetch the next page after the last seen user_id. Do not call when you need a specific user by identifier, to search/filter by attributes, or to compute aggregates; use a user detail, search, or analytics tool instead. Requires: since as an integer user_id (optional, returns users with id strictly greater than this) and per_page as an integer in 1\u2013100 (optional, defaults to 30); provide parameters as integers without formatting. Rules: results are read-only and idempotent; ordering is by sign-up time ascending; if per_page is omitted the default is applied; values outside the allowed range are not accepted and should be corrected before calling. Keywords: users, pagination, identity, account directory, browse users, chronological listing, retrieval.",
      "document": {
        "id": "cb42a716-06c9-4db2-8a81-abf85d5b9fc2",
        "name": "list_github_users",
        "appName": "apigithubcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Category tool for retrieval in identity: Returns a paginated list of users ordered by sign-up time ascending; inputs are since (integer user_id threshold) and per_page (integer 1\u2013100, default 30), and the result is an array of user records for the requested page. Call when you need to browse users chronologically, iterate through all users page by page, or fetch the next page after the last seen user_id. Do not call when you need a specific user by identifier, to search/filter by attributes, or to compute aggregates; use a user detail, search, or analytics tool instead. Requires: since as an integer user_id (optional, returns users with id strictly greater than this) and per_page as an integer in 1\u2013100 (optional, defaults to 30); provide parameters as integers without formatting. Rules: results are read-only and idempotent; ordering is by sign-up time ascending; if per_page is omitted the default is applied; values outside the allowed range are not accepted and should be corrected before calling. Keywords: users, pagination, identity, account directory, browse users, chronological listing, retrieval.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aint_path": {
              "type": "object",
              "additionalProperties": false
            },
            "aint_query": {
              "type": "object",
              "properties": {
                "since": {
                  "type": "integer",
                  "description": "Only return users with an ID greater than this."
                },
                "per_page": {
                  "type": "integer",
                  "description": "Results per page (max 100). Default 30."
                }
              },
              "additionalProperties": false
            }
          },
          "description": "Optional pagination parameters.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "github",
              "com"
            ],
            "path": [
              "users"
            ],
            "protocol": "https"
          },
          "method": "GET",
          "headers": {
            "Accept": "application/vnd.github+json",
            "Authorization": "Bearer $Authorization",
            "X-GitHub-Api-Version": "2022-11-28"
          }
        }
      },
      "canonical_data": {
        "name": "list_github_users",
        "inputs": {
          "optional": "Query parameters support pagination: 'since' is an integer user_id threshold that returns only users with an id strictly greater than this (used to fetch the next page after the last seen user_id); 'per_page' is an integer page size between 1 and 100 (default 30). Both must be provided as plain integers without formatting. No other query or path parameters are accepted.",
          "required": "none"
        },
        "intent": "Retrieve a chronologically ordered, paginated list of users for browsing or iterating through the user directory.",
        "context": "Results are paginated and ordered by sign-up time ascending. If 'per_page' is omitted, 30 is used by default; the maximum is 100. Use the last seen user's id as 'since' to iterate to the next page (strictly greater-than semantics). Parameters must be integers without formatting. This tool is for browsing users chronologically and not for fetching a specific user, searching/filtering by attributes, or computing aggregates.",
        "outputs": "An array of user records for the requested page, ordered by sign-up time ascending. These records can be used to continue pagination (e.g., use the last returned user's id as the 'since' value for the next call) or as inputs to downstream tools that operate on individual users.",
        "operation": "retrieve a paginated chronological list of users",
        "preconditions": "The endpoint must be accessible. If provided, 'since' must be an integer user_id and 'per_page' must be an integer within 1\u2013100; values outside allowed ranges are not accepted. Only the defined query parameters are permitted; additional parameters are not allowed.",
        "postconditions": "No resources are created or modified; the operation is read-only and idempotent. After success, the caller has a page of users ordered by sign-up time ascending.",
        "business_objects": [
          "user record"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "retrieve_github_user_context_by_username",
      "description": "Retrieval tool for contextual identity metadata in identity: returns public context fields about a GitHub user, optionally scoped to a specific organization, repository, issue, or pull request, based on a username and optional subject parameters, yielding lightweight user-in-context information. Call when you need contextual metadata for a known GitHub username, optionally relative to a given subject to understand the user\u2019s relationships or presence in that context. Do not call when you need full profile details, repository listings, issue or pull request content, or to modify accounts or permissions; use the appropriate profile, repositories, issues, PRs, or admin tools instead. Requires username (string GitHub handle without '@'), and optionally subject_type (enum: organization, repository, issue, pull_request) with subject_id (string ID for the chosen subject_type); provide both subject_type and subject_id together to apply context. Rules: read-only and idempotent; if subject_type is omitted, ignore subject_id; if subject_id is provided without a valid subject_type, it is ignored; usernames are case-insensitive and must be known ahead of time; returns public contextual fields only. Keywords: github user, identity context, contextual metadata, organization scope, repository scope, issue context, pull request context.",
      "document": {
        "id": "f211759c-903f-4770-8c6d-78df981e07e6",
        "name": "retrieve_github_user_context_by_username",
        "appName": "apigithubcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for contextual identity metadata in identity: returns public context fields about a GitHub user, optionally scoped to a specific organization, repository, issue, or pull request, based on a username and optional subject parameters, yielding lightweight user-in-context information. Call when you need contextual metadata for a known GitHub username, optionally relative to a given subject to understand the user\u2019s relationships or presence in that context. Do not call when you need full profile details, repository listings, issue or pull request content, or to modify accounts or permissions; use the appropriate profile, repositories, issues, PRs, or admin tools instead. Requires username (string GitHub handle without '@'), and optionally subject_type (enum: organization, repository, issue, pull_request) with subject_id (string ID for the chosen subject_type); provide both subject_type and subject_id together to apply context. Rules: read-only and idempotent; if subject_type is omitted, ignore subject_id; if subject_id is provided without a valid subject_type, it is ignored; usernames are case-insensitive and must be known ahead of time; returns public contextual fields only. Keywords: github user, identity context, contextual metadata, organization scope, repository scope, issue context, pull request context.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_path"
          ],
          "properties": {
            "aint_path": {
              "type": "object",
              "required": [
                "username"
              ],
              "properties": {
                "username": {
                  "type": "string",
                  "description": "GitHub username."
                }
              },
              "additionalProperties": false
            },
            "aint_query": {
              "type": "object",
              "properties": {
                "subject_id": {
                  "type": "string",
                  "description": "ID corresponding to the chosen subject_type."
                },
                "subject_type": {
                  "enum": [
                    "organization",
                    "repository",
                    "issue",
                    "pull_request"
                  ],
                  "type": "string",
                  "description": "Additional context type."
                }
              },
              "additionalProperties": false
            }
          },
          "description": "Provide the username, and optionally subject_type and subject_id for contextual info.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "github",
              "com"
            ],
            "path": [
              "users",
              "$username",
              "hovercard"
            ],
            "protocol": "https"
          },
          "method": "GET",
          "headers": {
            "Accept": "application/vnd.github+json",
            "Authorization": "Bearer $Authorization",
            "X-GitHub-Api-Version": "2022-11-28"
          }
        }
      },
      "canonical_data": {
        "name": "retrieve_github_user_context_by_username",
        "inputs": {
          "optional": "aint_query may include subject_type (one of: organization, repository, issue, pull_request) and subject_id (a string identifier for the chosen subject_type) to scope the returned context; both should be provided together for scoping to take effect. If subject_type is omitted or invalid, any subject_id is ignored. No other query or path properties are accepted.",
          "required": [
            "aint_path: Required path-parameter object that must contain the username used to route the request.",
            "aint_path.username: The GitHub username (handle without '@', case-insensitive) identifying the user whose public context is being retrieved; this is necessary to look up and return that user\u2019s contextual metadata."
          ]
        },
        "intent": "Fetch public, lightweight contextual identity metadata for a specified GitHub user, optionally scoped to a particular organization, repository, issue, or pull request.",
        "context": "- Returns public contextual fields only; not full profiles, repository listings, or issue/PR content.\n- Read-only and idempotent behavior.\n- Usernames are case-insensitive and should be provided without the '@' prefix.\n- If subject_type is omitted, any provided subject_id is ignored; if subject_type is invalid, subject_id is ignored.\n- Optional scoping supports exactly four subject types: organization, repository, issue, pull_request.\n- Input structure is split into path parameters (aint_path) and query parameters (aint_query), with no additional properties permitted.",
        "outputs": "A JSON object containing public contextual identity metadata about the specified GitHub user; when subject_type and subject_id are provided, the metadata is scoped to that subject (organization, repository, issue, or pull request). The response is lightweight (not a full profile) and can be used by downstream tools that consume a user handle and optional subject scope to reason about the user\u2019s presence or relationships in that context.",
        "operation": "Retrieve user-in-context public metadata",
        "preconditions": "- A GitHub username is provided via aint_path.username (case-insensitive, known ahead of time).\n- To apply contextual scoping, both subject_type (must be one of: organization, repository, issue, pull_request) and subject_id must be supplied together; otherwise scoping is not applied and any lone subject_id is ignored.\n- Only the defined path and query properties are allowed (no additional properties).\n- The tool only returns public contextual fields (non-public data is not returned).",
        "postconditions": "Read-only, idempotent retrieval; no accounts, permissions, repositories, issues, or pull requests are created, modified, or deleted. The only effect is returning public user-in-context metadata.",
        "business_objects": [
          "GitHub user",
          "organization",
          "repository",
          "issue",
          "pull request",
          "user-in-context metadata"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "search_github_code",
      "description": "Category tool for retrieval in content: Performs GitHub code search across repositories using a keyword-and-qualifier query, returning paginated matches (up to 100 per page) with file and repository metadata. Call when you need to locate source code files in GitHub by terms and qualifiers such as in:file, language:, repo:, path:, or filename:, and you already know the search query and any sorting/paging preferences. Do not call when you need to search repositories, issues, users, or download raw file contents; use dedicated tools for those GitHub resources instead. Requires: aint_query object with q (string using GitHub search syntax), optional sort='indexed', optional order in {'asc','desc'} when sort is set, optional per_page integer 1-100 (default 30), optional page integer >=1 (default 1). Rules: order is applied only if sort is provided; per_page values over 100 are clamped to 100; results are paginated and may vary as GitHub indexing updates; prefer specific qualifiers (repo, language, path) to narrow scope; idempotent for identical queries and paging. Keywords: github code search, source code, query qualifiers, repository files, pagination, language filters, path filters, search API.",
      "document": {
        "id": "afa02347-0c85-4930-8eca-c302e48363e4",
        "name": "search_github_code",
        "appName": "apigithubcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Category tool for retrieval in content: Performs GitHub code search across repositories using a keyword-and-qualifier query, returning paginated matches (up to 100 per page) with file and repository metadata. Call when you need to locate source code files in GitHub by terms and qualifiers such as in:file, language:, repo:, path:, or filename:, and you already know the search query and any sorting/paging preferences. Do not call when you need to search repositories, issues, users, or download raw file contents; use dedicated tools for those GitHub resources instead. Requires: aint_query object with q (string using GitHub search syntax), optional sort='indexed', optional order in {'asc','desc'} when sort is set, optional per_page integer 1-100 (default 30), optional page integer >=1 (default 1). Rules: order is applied only if sort is provided; per_page values over 100 are clamped to 100; results are paginated and may vary as GitHub indexing updates; prefer specific qualifiers (repo, language, path) to narrow scope; idempotent for identical queries and paging. Keywords: github code search, source code, query qualifiers, repository files, pagination, language filters, path filters, search API.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_query"
          ],
          "properties": {
            "aint_query": {
              "type": "object",
              "required": [
                "q"
              ],
              "properties": {
                "q": {
                  "type": "string",
                  "description": "Search query with keywords and qualifiers (e.g., addClass in:file language:js repo:jquery/jquery)."
                },
                "page": {
                  "type": "integer",
                  "description": "Page number of results. Default 1."
                },
                "sort": {
                  "enum": [
                    "indexed"
                  ],
                  "type": "string",
                  "description": "Sort order by how recently a file was indexed."
                },
                "order": {
                  "enum": [
                    "desc",
                    "asc"
                  ],
                  "type": "string",
                  "description": "Order of results if sort is provided."
                },
                "per_page": {
                  "type": "integer",
                  "description": "Results per page (max 100). Default 30."
                }
              },
              "description": "Query parameters for GitHub code search.",
              "additionalProperties": false
            }
          },
          "description": "Fixed structure: removed nested schema-within-schema, dropped the invalid 'type' data property/const, and defined aint_query directly with proper required/additionalProperties.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "github",
              "com"
            ],
            "path": [
              "search",
              "code"
            ],
            "protocol": "https"
          },
          "method": "GET",
          "headers": {
            "Accept": "application/vnd.github+json",
            "X-GitHub-Api-Version": "2022-11-28"
          }
        }
      },
      "canonical_data": {
        "name": "search_github_code",
        "inputs": {
          "optional": "Within aint_query, you may provide: page (integer, default 1) to select a results page; per_page (integer, default 30, clamped to a maximum of 100) to control page size; sort (only the value 'indexed') to sort by how recently a file was indexed; and order ('asc' or 'desc') which is applied only if sort is provided. All other fields are disallowed. These options shape pagination and the presentation of results but do not change which files match the query.",
          "required": [
            "aint_query (object): Container for all code-search parameters. It is required to perform the search and must include the query string and may include optional paging/sorting controls.",
            "aint_query.q (string): The GitHub Search syntax query (keywords plus qualifiers such as in:file, language:, repo:, path:, filename:). This is the core input used to find matching source code files."
          ]
        },
        "intent": "Locate GitHub source code files that match a keyword-and-qualifier query and return the matching files with related metadata, with optional sorting and pagination.",
        "context": "Results are paginated with defaults page=1 and per_page=30; per_page cannot exceed 100 (values above are clamped). At most 100 matches are returned per page. Sorting supports only sort=indexed, with order applied only when sort is set. Queries use GitHub\u2019s code search qualifiers (e.g., in:file, language:, repo:, path:, filename:); using specific qualifiers is recommended to narrow scope. Returned results and their order can change over time due to ongoing GitHub indexing. This tool is solely for code search (not for searching repositories, issues, or users, and not for downloading raw file contents).",
        "outputs": "A paginated set of GitHub code search matches (up to per_page items per page), each representing a source code file that matched the query, accompanied by file and repository metadata. These returned records can be used by other tools to follow up on repositories or files (e.g., to fetch repository details or file contents) using the provided identifiers/paths.",
        "operation": "execute a GitHub code search query and return matching files",
        "preconditions": "An aint_query object must be supplied and contain a non-empty q string using valid GitHub search syntax. If sort is provided, it must be 'indexed'; if order is provided, it must be 'asc' or 'desc' and is only applied when sort is present. page must be an integer >= 1. per_page must be an integer; values above 100 are accepted but effectively clamped to 100. The intended task must be code search (not repository, issue, or user search, and not raw file download). The GitHub Search API must be reachable.",
        "postconditions": "Read-only retrieval; no repositories or files are modified. On success, a page of code search results is returned. The operation is idempotent for identical query and pagination inputs, though result composition can change over time as GitHub\u2019s indexing updates.",
        "business_objects": [
          "GitHub code search query",
          "source code file match",
          "repository metadata"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "search_github_commits",
      "description": "Retrieval tool for searching commits in version_control: finds commit records on a repository\u2019s default branch using keyword terms and GitHub search qualifiers, returning a paginated list of commit summaries (sha, author, committer, dates, message, URLs). Call when you need to locate commits by text or qualifiers and optionally sort by author-date or committer-date and paginate through results. Do not call when you need code content search, a single commit by SHA, or commits from a non-default branch; use a code search or a specific commit/branch listing tool instead. Requires: q string with keywords and qualifiers (e.g., repo:owner/name, author:username, committer:username); optional sort in ['author-date','committer-date'], optional order in ['asc','desc'] only when sort is set; per_page integer 1\u2013100 (default 30); page integer >=1 (default 1). Rules: searches only the default branch; if per_page > 100 it is capped at 100; if sort is omitted, order is ignored; combining keywords and qualifiers narrows results; operation is read-only and idempotent. Keywords: commit search, GitHub commits, repository default branch, search qualifiers, pagination, author-date sorting, committer-date sorting, version control.",
      "document": {
        "id": "8dee1381-d3d5-4e5f-bceb-c850853e0252",
        "name": "search_github_commits",
        "appName": "apigithubcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for searching commits in version_control: finds commit records on a repository\u2019s default branch using keyword terms and GitHub search qualifiers, returning a paginated list of commit summaries (sha, author, committer, dates, message, URLs). Call when you need to locate commits by text or qualifiers and optionally sort by author-date or committer-date and paginate through results. Do not call when you need code content search, a single commit by SHA, or commits from a non-default branch; use a code search or a specific commit/branch listing tool instead. Requires: q string with keywords and qualifiers (e.g., repo:owner/name, author:username, committer:username); optional sort in ['author-date','committer-date'], optional order in ['asc','desc'] only when sort is set; per_page integer 1\u2013100 (default 30); page integer >=1 (default 1). Rules: searches only the default branch; if per_page > 100 it is capped at 100; if sort is omitted, order is ignored; combining keywords and qualifiers narrows results; operation is read-only and idempotent. Keywords: commit search, GitHub commits, repository default branch, search qualifiers, pagination, author-date sorting, committer-date sorting, version control.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_query"
          ],
          "properties": {
            "aint_query": {
              "type": "object",
              "required": [
                "q"
              ],
              "properties": {
                "q": {
                  "type": "string",
                  "description": "Search query with keywords and qualifiers (e.g., repo:octocat/Spoon-Knife css)."
                },
                "page": {
                  "type": "integer",
                  "description": "Page number of results. Default 1."
                },
                "sort": {
                  "enum": [
                    "author-date",
                    "committer-date"
                  ],
                  "type": "string",
                  "description": "Sort by author-date or committer-date."
                },
                "order": {
                  "enum": [
                    "desc",
                    "asc"
                  ],
                  "type": "string",
                  "description": "Order of results if sort is provided."
                },
                "per_page": {
                  "type": "integer",
                  "description": "Results per page (max 100). Default 30."
                }
              },
              "additionalProperties": false
            }
          },
          "description": "Dynamic inputs for GitHub commit search.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "github",
              "com"
            ],
            "path": [
              "search",
              "commits"
            ],
            "protocol": "https"
          },
          "method": "GET",
          "headers": {
            "Accept": "application/vnd.github+json",
            "X-GitHub-Api-Version": "2022-11-28"
          }
        }
      },
      "canonical_data": {
        "name": "search_github_commits",
        "inputs": {
          "optional": "Within aint_query, you may provide pagination and sorting controls: page (integer, default 1) to select a results page; per_page (integer, default 30, capped at 100) to set page size; sort ('author-date' or 'committer-date') to choose the sort field; and order ('asc' or 'desc') to set sort direction, which is only applied when sort is provided. If sort is omitted, any order value is ignored.",
          "required": [
            {
              "name": "aint_query",
              "description": "Object that encapsulates the commit search parameters. It is required to convey the search query and any optional pagination/sorting controls the tool needs to execute the search."
            },
            {
              "name": "aint_query.q",
              "description": "The search query string containing keywords and GitHub search qualifiers (e.g., repo:owner/name, author:username, committer:username). This is the core term set the tool uses to locate matching commits on the repository\u2019s default branch."
            }
          ]
        },
        "intent": "Find commit records on a repository\u2019s default branch by applying a keyword-and-qualifier search with optional sorting and pagination.",
        "context": "Searches only the repository\u2019s default branch; it does not return code content or commits from non-default branches. Combining keywords with GitHub search qualifiers narrows results (e.g., repo:owner/name, author:, committer:). Pagination defaults: page=1 and per_page=30; per_page values above 100 are capped at 100. Sorting can be by author-date or committer-date; order is applied only when sort is specified, otherwise order is ignored. Use other tools for code content search, retrieving a single commit by SHA, or listing commits from a specific non-default branch.",
        "outputs": "A paginated list (array) of commit summary objects for the default branch matching the query. Each summary includes fields such as commit SHA, author and committer identities, author/committer dates, commit message, and related URLs. These SHAs and URLs can be used by downstream tools that fetch a specific commit or navigate to related resources.",
        "operation": "search commit records by query on the default branch",
        "preconditions": "A valid aint_query object must be provided and must include a q string containing the search terms and/or GitHub qualifiers. If provided, sort must be one of 'author-date' or 'committer-date'. If provided, order must be 'asc' or 'desc' and is only meaningful when sort is set. Page should be an integer >= 1. The API must be reachable.",
        "postconditions": "No server-side state is changed; the operation is read-only and idempotent. Upon success, a page of commit summaries matching the query on the default branch is returned.",
        "business_objects": [
          "commit record"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "search_github_users",
      "description": "Retrieval tool for searching user accounts in developer domain: performs GitHub user search using a q string with keywords and GitHub search qualifiers and returns a paginated list of matching users (up to 100 per page) along with relevance-based ordering. Call when you need to discover, filter, or enumerate GitHub users by name, login, or profile attributes using qualifiers and require multiple results. Do not call when searching repositories, code, issues, or topics, or when retrieving a specific user by exact login; use repository/code/issue search tools or a get_user tool instead. Requires: q string (UTF-8) with keywords and qualifiers; optional page integer >=1 (default 1); optional per_page integer 1\u2013100 (default 30); optional sort='indexed'; optional order in {'asc','desc'} which only applies when sort is provided. Rules: clamp per_page to 100; default order is 'desc' when sort is set; if sort is omitted results are ranked by relevance; order must not be set without sort; repeated calls with identical parameters are idempotent aside from index freshness. Keywords: github users, user search, search qualifiers, pagination, developer directory, relevance ranking, per_page, asc desc.",
      "document": {
        "id": "c841fa27-6bdc-485c-bed4-b606c66391e0",
        "name": "search_github_users",
        "appName": "apigithubcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for searching user accounts in developer domain: performs GitHub user search using a q string with keywords and GitHub search qualifiers and returns a paginated list of matching users (up to 100 per page) along with relevance-based ordering. Call when you need to discover, filter, or enumerate GitHub users by name, login, or profile attributes using qualifiers and require multiple results. Do not call when searching repositories, code, issues, or topics, or when retrieving a specific user by exact login; use repository/code/issue search tools or a get_user tool instead. Requires: q string (UTF-8) with keywords and qualifiers; optional page integer >=1 (default 1); optional per_page integer 1\u2013100 (default 30); optional sort='indexed'; optional order in {'asc','desc'} which only applies when sort is provided. Rules: clamp per_page to 100; default order is 'desc' when sort is set; if sort is omitted results are ranked by relevance; order must not be set without sort; repeated calls with identical parameters are idempotent aside from index freshness. Keywords: github users, user search, search qualifiers, pagination, developer directory, relevance ranking, per_page, asc desc.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_query"
          ],
          "properties": {
            "body": {
              "type": "object",
              "properties": {},
              "description": "Body parameters"
            },
            "path": {
              "type": "object",
              "properties": {},
              "description": "Path parameters"
            },
            "query": {
              "type": "object",
              "properties": {},
              "description": "Query parameters"
            },
            "headers": {
              "type": "object",
              "properties": {},
              "description": "Headers parameters"
            },
            "aint_query": {
              "type": "object",
              "required": [
                "q"
              ],
              "properties": {
                "q": {
                  "type": "string",
                  "description": "Search query with keywords and qualifiers (e.g., addClass in:file language:js repo:jquery/jquery)."
                },
                "page": {
                  "type": "integer",
                  "description": "Page number of results. Default 1."
                },
                "sort": {
                  "enum": [
                    "indexed"
                  ],
                  "type": "string",
                  "description": "Sort order by how recently a file was indexed."
                },
                "order": {
                  "enum": [
                    "desc",
                    "asc"
                  ],
                  "type": "string",
                  "description": "Order of results if sort is provided."
                },
                "per_page": {
                  "type": "integer",
                  "description": "Results per page (max 100). Default 30."
                }
              },
              "description": "Query parameters for GitHub user search.",
              "additionalProperties": false
            }
          },
          "description": "Fixed structure: removed nested schema-within-schema, dropped the invalid 'type' data property/const, and defined aint_query directly with proper required/additionalProperties.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "github",
              "com"
            ],
            "path": [
              "search",
              "users"
            ],
            "protocol": "https"
          },
          "method": "GET",
          "headers": {
            "Accept": "application/vnd.github+json",
            "X-GitHub-Api-Version": "2022-11-28"
          }
        }
      },
      "canonical_data": {
        "name": "search_github_users",
        "inputs": {
          "optional": "Within aint_query, callers may provide pagination and sorting controls: page (integer, >=1; default 1) to select the results page; per_page (integer, 1\u2013100; default 30; clamped to 100) to limit results per page; sort ('indexed' only) to order by most recently indexed; and order ('asc' or 'desc') which applies only when sort is provided (default 'desc' when sort is set). If sort is omitted, results are ranked by relevance and 'order' must not be provided. Top-level body, path, query, and headers objects exist but have no defined properties in this specification.",
          "required": [
            "aint_query: Container object for all search-specific query parameters. It is required because the API expects the search query and any pagination/sorting controls to be provided within this object.",
            "aint_query.q: UTF-8 search query string containing keywords and GitHub search qualifiers that define which users to match. This is required to drive the search and determine the result set."
          ]
        },
        "intent": "Discover and retrieve GitHub user accounts that match a keyword-and-qualifier search, returning a paginated, relevance-ordered list.",
        "context": "This tool searches only GitHub users (not repositories, code, issues, or topics). Results are paginated with defaults of page=1 and per_page=30 and are capped at 100 per page. If sort is omitted, results are ranked by relevance; when sort='indexed', the default order is 'desc' and 'order' applies only in that case. Per_page values above 100 are clamped. Calls with the same parameters yield consistent results except for changes due to index freshness.",
        "outputs": "A paginated list (array) of GitHub user accounts that match the provided q search, ordered by relevance by default or by indexing recency when sort='indexed'. Each page contains up to per_page users (maximum 100). The returned user list can be consumed by downstream tools that operate on or require references to GitHub users.",
        "operation": "search GitHub user accounts",
        "preconditions": "A valid aint_query object must be provided and include q (UTF-8 keywords and GitHub search qualifiers). Optional parameters must respect constraints: page >= 1; per_page 1\u2013100; sort may only be 'indexed'; order must be provided only if sort is set and must be 'asc' or 'desc'. The underlying GitHub user search endpoint must be reachable.",
        "postconditions": "Read-only retrieval: no data is modified. On success, a list of matching GitHub users is returned in deterministic order for the given parameters, subject to index freshness (repeated calls with identical inputs are idempotent aside from potential indexing updates).",
        "business_objects": [
          "GitHub user accounts",
          "search query string"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "search_github_issues",
      "description": "Retrieval tool for searching issues and pull requests in source control: Executes GitHub\u2019s Search Issues API (GET /search/issues) with a query string and returns paginated items (issues and PRs) with total_count, optionally including text_matches when the Accept header is set. Call when: you need to find issues or pull requests by keywords and GitHub qualifiers (e.g., repo:owner/name, is:issue|pr, label:, author:, state:) across one or multiple repositories. Do not call when: you need a single issue by number, a simple list for one repository, code/commit/topic search, or comments/timeline data\u2014use dedicated detail/listing or code/commit/topic tools instead. Requires: q as a plain string of keywords and qualifiers, optional page integer >=1 (default 1), per_page integer 1\u2013100 (default 30), sort='indexed' if sorting is desired, order in {'asc','desc'} only when sort is provided, and Accept header exactly application/vnd.github.text-match+json to include text_matches. Rules: if sort is absent results are by relevance; if sort is set only 'indexed' is allowed and order controls direction; order is ignored when sort is absent; scope with repo:owner/name or org: as needed; q is a single string (client handles URL encoding); pagination uses page starting at 1 and per_page caps at 100. Keywords: github issues search, pull request search, text match metadata, query qualifiers, cross-repository discovery, pagination, source control, developer tooling.",
      "document": {
        "id": "2027a510-dfd2-4415-9a17-8f3d11a1e480",
        "name": "search_github_issues",
        "appName": "apigithubcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for searching issues and pull requests in source control: Executes GitHub\u2019s Search Issues API (GET /search/issues) with a query string and returns paginated items (issues and PRs) with total_count, optionally including text_matches when the Accept header is set. Call when: you need to find issues or pull requests by keywords and GitHub qualifiers (e.g., repo:owner/name, is:issue|pr, label:, author:, state:) across one or multiple repositories. Do not call when: you need a single issue by number, a simple list for one repository, code/commit/topic search, or comments/timeline data\u2014use dedicated detail/listing or code/commit/topic tools instead. Requires: q as a plain string of keywords and qualifiers, optional page integer >=1 (default 1), per_page integer 1\u2013100 (default 30), sort='indexed' if sorting is desired, order in {'asc','desc'} only when sort is provided, and Accept header exactly application/vnd.github.text-match+json to include text_matches. Rules: if sort is absent results are by relevance; if sort is set only 'indexed' is allowed and order controls direction; order is ignored when sort is absent; scope with repo:owner/name or org: as needed; q is a single string (client handles URL encoding); pagination uses page starting at 1 and per_page caps at 100. Keywords: github issues search, pull request search, text match metadata, query qualifiers, cross-repository discovery, pagination, source control, developer tooling.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_query"
          ],
          "properties": {
            "aint_query": {
              "type": "object",
              "required": [
                "q"
              ],
              "properties": {
                "q": {
                  "type": "string",
                  "description": "Search query keywords and qualifiers."
                },
                "page": {
                  "type": "integer",
                  "minimum": 1,
                  "description": "Page number. Default 1."
                },
                "sort": {
                  "enum": [
                    "indexed"
                  ],
                  "type": "string",
                  "description": "Sort mode. Only 'indexed' supported."
                },
                "order": {
                  "enum": [
                    "desc",
                    "asc"
                  ],
                  "type": "string",
                  "description": "Sort order when sort is set."
                },
                "per_page": {
                  "type": "integer",
                  "maximum": 100,
                  "minimum": 1,
                  "description": "Results per page (1-100). Default 30."
                }
              },
              "description": "Query parameters.",
              "additionalProperties": false
            },
            "aint_headers": {
              "type": "object",
              "description": "Optional headers. Set Accept to application/vnd.github.text-match+json to include text_matches.",
              "additionalProperties": {
                "type": [
                  "string",
                  "number",
                  "boolean"
                ]
              }
            }
          },
          "description": "Inputs for GitHub issue or pull request search.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "github",
              "com"
            ],
            "path": [
              "search",
              "issues"
            ],
            "protocol": "https"
          },
          "method": "GET",
          "headers": {
            "Accept": "application/vnd.github+json",
            "X-GitHub-Api-Version": "2022-11-28"
          }
        }
      },
      "canonical_data": {
        "name": "search_github_issues",
        "inputs": {
          "optional": "Within aint_query: page (integer, >=1; default 1) to select the results page; per_page (integer, 1\u2013100; default 30) to control page size; sort (only 'indexed' allowed) to enable sorting; order ('asc' or 'desc') which only applies when sort is provided and is ignored otherwise. At the top level, aint_headers can include arbitrary HTTP headers; setting Accept exactly to application/vnd.github.text-match+json requests inclusion of text_matches in returned items.",
          "required": [
            {
              "name": "aint_query",
              "description": "Required container for all query parameters sent to GET /search/issues. Without this object, no search can be formed."
            },
            {
              "name": "aint_query.q",
              "description": "The required search query string containing keywords and GitHub search qualifiers (e.g., repo:owner/name, is:issue|pr, label:, author:, state:). This is the core input the API uses to find matching issues and pull requests."
            }
          ]
        },
        "intent": "Perform a keyword- and qualifier-based search across GitHub issues and pull requests and return a paginated result set from the GitHub Search Issues API.",
        "context": "If sort is absent, results are ordered by relevance. If sort is set, only 'indexed' is allowed, and order controls ascending or descending order; order is ignored when sort is not set. Pagination uses page starting at 1 with per_page capped at 100 (default 30). The q parameter is a single string that combines keywords and GitHub qualifiers (e.g., repo:, org:, is:, label:, author:, state:); URL encoding is handled by the client. Setting Accept to application/vnd.github.text-match+json augments items with text_matches. This tool is for searching issues and pull requests across one or multiple repositories; it is not for fetching a single issue by number, simple per-repository listings, code/commit/topic search, or comments/timeline data.",
        "outputs": "A search result set from GitHub containing total_count and a paginated list of items (issues and pull requests). When the Accept header is application/vnd.github.text-match+json, items may include text_matches metadata. These returned issue and pull request records can be used downstream wherever identifiers or metadata about the found items are required.",
        "operation": "execute a GitHub Search Issues API query to retrieve matching issues and pull requests",
        "preconditions": "The GitHub Search Issues API (GET /search/issues) must be reachable. The input must include aint_query with a non-empty q string. If provided, page must be >= 1 and per_page must be between 1 and 100. If sort is provided, it must be 'indexed'. If order is provided, it must be 'asc' or 'desc' and is only meaningful when sort is set. To receive text_matches, the Accept header must be exactly application/vnd.github.text-match+json.",
        "postconditions": "Read-only operation; no GitHub issues or pull requests are created or modified. After successful execution, a paginated set of matching items is returned according to the provided query, pagination, and sorting parameters.",
        "business_objects": [
          "issue",
          "pull request",
          "search result set"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "search_github_repositories",
      "description": "Retrieval tool for keyword and qualifier search in developer: Performs searches of GitHub repositories using a required q string and optional pagination (page, per_page), sort ('indexed') and order ('asc'|'desc'), returning a paginated list of matching repositories with up to 100 results per page. Call when you need to discover repositories by name, description, language, topics, stars, forks, or organization using GitHub search qualifiers. Do not call when searching code files, issues, pull requests, users, or when you already know the exact owner/repo and need its details; use the appropriate GitHub code/issue search or a repository lookup tool instead. Requires q (UTF-8 string using GitHub qualifier syntax, e.g., language:js stars:>100 org:apache), optional page (integer >=1, default 1), per_page (integer 1\u2013100, default 30), sort ('indexed' only), and order ('asc' or 'desc' used only when sort is provided). Rules: if sort is omitted ignore order; per_page is capped at 100; repeated calls with identical parameters are idempotent and return the same page; queries are case-insensitive and must be URL-safe (the tool handles encoding). Keywords: GitHub repositories, search qualifiers, pagination, language filter, stars filter, topics, organization, sort order.",
      "document": {
        "id": "a45372b7-269c-4d2d-9357-1366b1e11d0f",
        "name": "search_github_repositories",
        "appName": "apigithubcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for keyword and qualifier search in developer: Performs searches of GitHub repositories using a required q string and optional pagination (page, per_page), sort ('indexed') and order ('asc'|'desc'), returning a paginated list of matching repositories with up to 100 results per page. Call when you need to discover repositories by name, description, language, topics, stars, forks, or organization using GitHub search qualifiers. Do not call when searching code files, issues, pull requests, users, or when you already know the exact owner/repo and need its details; use the appropriate GitHub code/issue search or a repository lookup tool instead. Requires q (UTF-8 string using GitHub qualifier syntax, e.g., language:js stars:>100 org:apache), optional page (integer >=1, default 1), per_page (integer 1\u2013100, default 30), sort ('indexed' only), and order ('asc' or 'desc' used only when sort is provided). Rules: if sort is omitted ignore order; per_page is capped at 100; repeated calls with identical parameters are idempotent and return the same page; queries are case-insensitive and must be URL-safe (the tool handles encoding). Keywords: GitHub repositories, search qualifiers, pagination, language filter, stars filter, topics, organization, sort order.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_query"
          ],
          "properties": {
            "body": {
              "type": "object",
              "properties": {},
              "description": "Body parameters"
            },
            "path": {
              "type": "object",
              "properties": {},
              "description": "Path parameters"
            },
            "query": {
              "type": "object",
              "properties": {},
              "description": "Query parameters"
            },
            "headers": {
              "type": "object",
              "properties": {},
              "description": "Headers parameters"
            },
            "aint_query": {
              "type": "object",
              "required": [
                "q"
              ],
              "properties": {
                "q": {
                  "type": "string",
                  "description": "Search query with keywords and qualifiers (e.g., addClass in:file language:js repo:jquery/jquery)."
                },
                "page": {
                  "type": "integer",
                  "description": "Page number of results. Default 1."
                },
                "sort": {
                  "enum": [
                    "indexed"
                  ],
                  "type": "string",
                  "description": "Sort order by how recently a file was indexed."
                },
                "order": {
                  "enum": [
                    "desc",
                    "asc"
                  ],
                  "type": "string",
                  "description": "Order of results if sort is provided."
                },
                "per_page": {
                  "type": "integer",
                  "description": "Results per page (max 100). Default 30."
                }
              },
              "description": "Query parameters for GitHub repository search.",
              "additionalProperties": false
            }
          },
          "description": "Fixed structure: removed nested schema-within-schema, dropped the invalid 'type' data property/const, and defined aint_query directly with proper required/additionalProperties.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "github",
              "com"
            ],
            "path": [
              "search",
              "repositories"
            ],
            "protocol": "https"
          },
          "method": "GET",
          "headers": {
            "Accept": "application/vnd.github+json",
            "X-GitHub-Api-Version": "2022-11-28"
          }
        }
      },
      "canonical_data": {
        "name": "search_github_repositories",
        "inputs": {
          "optional": "Within aint_query, callers may provide pagination and sorting controls: page (integer, default 1, must be >= 1) to select a results page; per_page (integer, default 30, capped at 100) to set page size; sort (only the value 'indexed') to sort by how recently content was indexed; and order ('asc' or 'desc') which is honored only if sort is provided. Queries are case-insensitive and must be URL-safe; the tool performs necessary encoding. Repeated calls with identical parameters are idempotent and return the same page. The top-level optional sections body, path, query, and headers exist in the schema but have no defined parameters for this operation; functional inputs are carried exclusively in aint_query.",
          "required": [
            "aint_query: Container object that holds the repository search parameters; it must be present to convey the query and any pagination/sort options.",
            "aint_query.q: UTF-8 search string using GitHub search qualifier syntax (e.g., language:js stars:>100 org:apache) that defines which repositories to match; this is the fundamental criterion the tool uses to find results."
          ]
        },
        "intent": "Discover GitHub repositories that match a qualifier-based search query, returning a paginated set of repository results.",
        "context": "This tool is limited to repository search and should not be used for searching code files, issues, pull requests, or users, nor for fetching details of a known owner/repo. Pagination defaults are page=1 and per_page=30, with per_page capped at 100. Sorting supports only 'indexed'; order is ignored if sort is omitted. Queries are case-insensitive and URL encoding is handled by the tool. Calls with identical parameters are idempotent and return the same page of results.",
        "outputs": "A paginated list of matching GitHub repository records (up to 100 per page), representing repositories that satisfy the provided query and qualifiers. These records can be used downstream wherever repository results or identifiers are needed.",
        "operation": "Search for repositories using a keyword-and-qualifier query",
        "preconditions": "The input must include the aint_query object with a non-empty q string using GitHub repository search qualifier syntax. If provided, page must be an integer >= 1; per_page must be an integer between 1 and 100; sort, if present, must be 'indexed'; order, if present, must be 'asc' or 'desc' and is only applied when sort is specified. The aint_query object must not include properties other than q, page, sort, order, and per_page (additionalProperties is false). The top-level input object must not include properties beyond those defined in the schema. The GitHub Search API must be accessible for the query to execute.",
        "postconditions": "No resources are created or modified; the operation is read-only. After successful execution, the specified page of repository search results is returned deterministically for the given parameters.",
        "business_objects": [
          "GitHub repository"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "update_github_repository_by_owner",
      "description": "Mutation tool for updating repository settings in source_control: Modifies an existing repository\u2019s metadata, visibility, merge policies, issue/project/wiki features, default branch, archival state, forking policy, homepage URL, and security/analysis options; inputs include owner and repo identifiers plus optional fields (name, description, visibility public|private|internal, booleans for features and merge behaviors, and security_and_analysis status objects), returning the updated repository configuration. Call when you need to change repository configuration such as renaming, editing description/homepage, toggling issues/projects/wiki, enabling or disabling squash/rebase/merge commits, setting delete_branch_on_merge, updating default_branch, archiving/unarchiving, allowing private forks, or adjusting security and secret scanning settings. Do not call when creating or deleting repositories, retrieving repository details, updating collaborators or branch protection, editing repository topics (use the replace_all_repository_topics endpoint instead), or managing pull request content and merges. Requires: owner and repo as case-insensitive strings; at least one field to update; for security_and_analysis changes you must have admin permissions on the repository or be an organization owner/security manager; visibility changes may be blocked by organizational policy; default_branch must name an existing branch; enums must be one of the documented values; booleans use true/false. Rules: if visibility is set, prefer it over private; when squash_merge_commit_message is provided you must also set squash_merge_commit_title, and when merge_commit_message is provided you must also set merge_commit_title; unspecified fields remain unchanged; archiving is reversible (archived=false unarchives); PATCH behavior is idempotent; topics cannot be edited via this tool. Keywords: repository update, source control settings, GitHub Enterprise Server, visibility and merge policies, default branch, security and analysis, secret scanning, archive unarchive.",
      "document": {
        "id": "93796bc4-c32a-41f1-b163-72a34b4fedd5",
        "name": "update_github_repository_by_owner",
        "appName": "apigithubcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Mutation tool for updating repository settings in source_control: Modifies an existing repository\u2019s metadata, visibility, merge policies, issue/project/wiki features, default branch, archival state, forking policy, homepage URL, and security/analysis options; inputs include owner and repo identifiers plus optional fields (name, description, visibility public|private|internal, booleans for features and merge behaviors, and security_and_analysis status objects), returning the updated repository configuration. Call when you need to change repository configuration such as renaming, editing description/homepage, toggling issues/projects/wiki, enabling or disabling squash/rebase/merge commits, setting delete_branch_on_merge, updating default_branch, archiving/unarchiving, allowing private forks, or adjusting security and secret scanning settings. Do not call when creating or deleting repositories, retrieving repository details, updating collaborators or branch protection, editing repository topics (use the replace_all_repository_topics endpoint instead), or managing pull request content and merges. Requires: owner and repo as case-insensitive strings; at least one field to update; for security_and_analysis changes you must have admin permissions on the repository or be an organization owner/security manager; visibility changes may be blocked by organizational policy; default_branch must name an existing branch; enums must be one of the documented values; booleans use true/false. Rules: if visibility is set, prefer it over private; when squash_merge_commit_message is provided you must also set squash_merge_commit_title, and when merge_commit_message is provided you must also set merge_commit_title; unspecified fields remain unchanged; archiving is reversible (archived=false unarchives); PATCH behavior is idempotent; topics cannot be edited via this tool. Keywords: repository update, source control settings, GitHub Enterprise Server, visibility and merge policies, default branch, security and analysis, secret scanning, archive unarchive.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aint_body": {
              "type": "object",
              "properties": {
                "name": {
                  "type": "string",
                  "description": "The name of the repository."
                },
                "private": {
                  "type": "boolean",
                  "default": false,
                  "description": "Either `true` to make the repository private or `false` to make it public. Default: `false`.  \n**Note**: You will get a `422` error if the organization restricts [changing repository visibility](https://docs.github.com/enterprise-server@3.18/articles/repository-permission-levels-for-an-organization#changing-the-visibility-of-repositories) to organization owners and a non-owner tries to change the value of private."
                },
                "archived": {
                  "type": "boolean",
                  "default": false,
                  "description": "Whether to archive this repository. `false` will unarchive a previously archived repository."
                },
                "has_wiki": {
                  "type": "boolean",
                  "default": true,
                  "description": "Either `true` to enable the wiki for this repository or `false` to disable it."
                },
                "homepage": {
                  "type": "string",
                  "description": "A URL with more information about the repository."
                },
                "has_issues": {
                  "type": "boolean",
                  "default": true,
                  "description": "Either `true` to enable issues for this repository or `false` to disable them."
                },
                "visibility": {
                  "enum": [
                    "public",
                    "private",
                    "internal"
                  ],
                  "type": "string",
                  "description": "The visibility of the repository."
                },
                "description": {
                  "type": "string",
                  "description": "A short description of the repository."
                },
                "is_template": {
                  "type": "boolean",
                  "default": false,
                  "description": "Either `true` to make this repo available as a template repository or `false` to prevent it."
                },
                "has_projects": {
                  "type": "boolean",
                  "default": true,
                  "description": "Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error."
                },
                "allow_forking": {
                  "type": "boolean",
                  "default": false,
                  "description": "Either `true` to allow private forks, or `false` to prevent private forks."
                },
                "default_branch": {
                  "type": "string",
                  "description": "Updates the default branch for this repository."
                },
                "allow_merge_commit": {
                  "type": "boolean",
                  "default": true,
                  "description": "Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits."
                },
                "allow_rebase_merge": {
                  "type": "boolean",
                  "default": true,
                  "description": "Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging."
                },
                "allow_squash_merge": {
                  "type": "boolean",
                  "default": true,
                  "description": "Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging."
                },
                "merge_commit_title": {
                  "enum": [
                    "PR_TITLE",
                    "MERGE_MESSAGE"
                  ],
                  "type": "string",
                  "description": "Required when using `merge_commit_message`.\n\nThe default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name)."
                },
                "allow_update_branch": {
                  "type": "boolean",
                  "default": false,
                  "description": "Either `true` to always allow a pull request head branch that is behind its base branch to be updated even if it is not required to be up to date before merging, or false otherwise."
                },
                "merge_commit_message": {
                  "enum": [
                    "PR_BODY",
                    "PR_TITLE",
                    "BLANK"
                  ],
                  "type": "string",
                  "description": "The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message."
                },
                "security_and_analysis": {
                  "type": "object",
                  "nullable": true,
                  "properties": {
                    "code_security": {
                      "type": "object",
                      "properties": {
                        "status": {
                          "type": "string",
                          "description": "Can be `enabled` or `disabled`."
                        }
                      },
                      "description": "Use the `status` property to enable or disable GitHub Code Security for this repository."
                    },
                    "secret_scanning": {
                      "type": "object",
                      "properties": {
                        "status": {
                          "type": "string",
                          "description": "Can be `enabled` or `disabled`."
                        }
                      },
                      "description": "Use the `status` property to enable or disable secret scanning for this repository. For more information, see \"[About secret scanning](/code-security/secret-security/about-secret-scanning).\""
                    },
                    "advanced_security": {
                      "type": "object",
                      "properties": {
                        "status": {
                          "type": "string",
                          "description": "Can be `enabled` or `disabled`."
                        }
                      },
                      "description": "Use the `status` property to enable or disable GitHub Advanced Security for this repository.\nFor more information, see \"[About GitHub Advanced\nSecurity](/github/getting-started-with-github/learning-about-github/about-github-advanced-security).\"\n\nFor standalone Code Scanning or Secret Protection products, this parameter cannot be used."
                    },
                    "secret_scanning_push_protection": {
                      "type": "object",
                      "properties": {
                        "status": {
                          "type": "string",
                          "description": "Can be `enabled` or `disabled`."
                        }
                      },
                      "description": "Use the `status` property to enable or disable secret scanning push protection for this repository. For more information, see \"[Protecting pushes with secret scanning](/code-security/secret-scanning/protecting-pushes-with-secret-scanning).\""
                    },
                    "secret_scanning_non_provider_patterns": {
                      "type": "object",
                      "properties": {
                        "status": {
                          "type": "string",
                          "description": "Can be `enabled` or `disabled`."
                        }
                      },
                      "description": "Use the `status` property to enable or disable secret scanning non-provider patterns for this repository. For more information, see \"[Supported secret scanning patterns](/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets).\""
                    }
                  },
                  "description": "Specify which security and analysis features to enable or disable for the repository.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see \"[Managing security managers in your organization](https://docs.github.com/enterprise-server@3.18/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).\"\n\nFor example, to enable GitHub Advanced Security, use this data in the body of the `PATCH` request:\n`{ \"security_and_analysis\": {\"advanced_security\": { \"status\": \"enabled\" } } }`.\n\nYou can check which security and analysis features are currently enabled by using a `GET /repos/{owner}/{repo}` request."
                },
                "delete_branch_on_merge": {
                  "type": "boolean",
                  "default": false,
                  "description": "Either `true` to allow automatically deleting head branches when pull requests are merged, or `false` to prevent automatic deletion."
                },
                "squash_merge_commit_title": {
                  "enum": [
                    "PR_TITLE",
                    "COMMIT_OR_PR_TITLE"
                  ],
                  "type": "string",
                  "description": "Required when using `squash_merge_commit_message`.\n\nThe default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit)."
                },
                "squash_merge_commit_message": {
                  "enum": [
                    "PR_BODY",
                    "COMMIT_MESSAGES",
                    "BLANK"
                  ],
                  "type": "string",
                  "description": "The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message."
                },
                "web_commit_signoff_required": {
                  "type": "boolean",
                  "default": false,
                  "description": "Either `true` to require contributors to sign off on web-based commits, or `false` to not require contributors to sign off on web-based commits."
                },
                "use_squash_pr_title_as_default": {
                  "type": "boolean",
                  "default": false,
                  "deprecated": true,
                  "description": "Either `true` to allow squash-merge commits to use pull request title, or `false` to use commit message. **This property is closing down. Please use `squash_merge_commit_title` instead."
                }
              }
            },
            "aint_path": {
              "type": "object",
              "required": [
                "owner",
                "repo"
              ],
              "properties": {
                "repo": {
                  "type": "string",
                  "description": "The name of the repository without the `.git` extension. The name is not case sensitive."
                },
                "owner": {
                  "type": "string",
                  "description": "The account owner of the repository. The name is not case sensitive."
                }
              }
            }
          },
          "description": "**Note**: To edit a repository's topics, use the [Replace all repository topics](https://docs.github.com/enterprise-server@3.18/rest/repos/repos#replace-all-repository-topics) endpoint."
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "github",
              "com"
            ],
            "path": [
              "repos",
              "${owner}",
              "${repo}"
            ],
            "query": {},
            "protocol": "https"
          },
          "method": "PATCH",
          "headers": {
            "Content-Type": "application/json"
          }
        }
      },
      "canonical_data": {
        "name": "update_github_repository_by_owner",
        "inputs": {
          "optional": "A request body of update fields, any combination of which may be provided, with at least one field required to perform an update: name (rename), description, homepage URL, visibility (public|private|internal, preferred over the legacy 'private' boolean), private (boolean for public/private when visibility is not set), archived (boolean to archive or unarchive), has_issues/has_projects/has_wiki (booleans to enable/disable features; has_projects may error if the org disables repo projects), is_template (boolean to make repo a template), allow_forking (boolean to allow or prevent private forks), default_branch (string that must reference an existing branch), merge behavior settings (allow_merge_commit, allow_rebase_merge, allow_squash_merge, delete_branch_on_merge, allow_update_branch), commit metadata defaults for merges (merge_commit_message: PR_BODY|PR_TITLE|BLANK requires merge_commit_title: PR_TITLE|MERGE_MESSAGE; squash_merge_commit_message: PR_BODY|COMMIT_MESSAGES|BLANK requires squash_merge_commit_title: PR_TITLE|COMMIT_OR_PR_TITLE), web_commit_signoff_required (boolean), use_squash_pr_title_as_default (deprecated boolean; use squash_merge_commit_title instead), and security_and_analysis (object specifying per-feature status 'enabled' or 'disabled' for code_security, secret_scanning, advanced_security, secret_scanning_push_protection, and secret_scanning_non_provider_patterns; changing these requires admin repo permissions or org owner/security manager). Unspecified fields remain unchanged; booleans use true/false; enum inputs must use documented values.",
          "required": [
            "owner: Case-insensitive string identifying the account that owns the repository; needed to locate the target repository to be updated.",
            "repo: Case-insensitive string naming the repository (without .git); needed to identify the specific repository whose configuration will be modified."
          ]
        },
        "intent": "Modify the configuration of an existing GitHub repository, updating metadata, visibility, feature flags, merge behavior, default branch, archival state, forking policy, homepage, and security/analysis settings.",
        "context": "This is a PATCH-style mutation on a GitHub Enterprise Server repository identified by case-insensitive owner and repo. If both visibility and private are provided, visibility is preferred. Some organization policies (e.g., visibility changes, repository projects) may constrain allowable updates and can produce errors. Boolean fields have documented defaults; archiving is reversible. Security and analysis statuses accept 'enabled' or 'disabled' and require elevated permissions. The endpoint does not create/delete repositories, manage topics, collaborators, branch protection, or pull request contents; it only updates repository configuration.",
        "outputs": "An updated repository record representing the repository\u2019s current configuration after the changes, including metadata (name, description, homepage), visibility and archival state, enabled features (issues, projects, wiki), default_branch, forking policy, merge behavior and commit message/title defaults, and security/analysis feature statuses. This object can be used by downstream tools that require the repository\u2019s latest settings or identifiers.",
        "operation": "update an existing repository's settings",
        "preconditions": "The specified repository must exist and be accessible; the caller must provide owner and repo and include at least one updatable field. If changing security_and_analysis, the caller must have admin permissions on the repository or be an organization owner/security manager. Visibility changes may be restricted by organization policy (non-owners may receive 422 when attempting restricted changes). The default_branch value must name an existing branch. Enum fields must use one of the documented values. If merge_commit_message is provided, merge_commit_title is also required; if squash_merge_commit_message is provided, squash_merge_commit_title is also required. Topics cannot be edited via this endpoint.",
        "postconditions": "On success, the repository\u2019s configuration is updated exactly as specified; unspecified properties remain unchanged. If archived=false is provided, a previously archived repository is unarchived. The operation is mutating and idempotent (repeating the same PATCH yields the same resulting configuration). The updated repository record is returned.",
        "business_objects": [
          "repository"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "delete_github_repository_by_owner",
      "description": "Mutation tool for deleting repositories in source_control: Permanently deletes a GitHub repository identified by owner and repo, requiring admin access and a token with delete_repo scope, and returns success on deletion or an error (e.g., 403 Forbidden) when permissions or organization policies block the action. Call when: you need to remove a repository entirely from GitHub after confirming the action is appropriate and authorized. Do not call when: you intend to archive, transfer ownership, rename, change visibility, or delete branches; use the corresponding repository management tools instead. Requires: owner (string, case-insensitive), repo (string without .git, case-insensitive), and an OAuth app or personal access token (Bearer) that includes delete_repo scope; the caller must have admin permissions on the target repository; for organization-owned repositories, ensure org settings permit member deletions. Rules: names are case-insensitive; if organization policies disallow deletion, expect 403 Forbidden; the operation is destructive and effectively irreversible; repeated calls after deletion are idempotent and may return not found; do not append .git to repo. Keywords: repository deletion, GitHub, admin permissions, delete_repo scope, organization policy, source control, destructive operation, 403 Forbidden.",
      "document": {
        "id": "fbaf697f-d828-4398-963c-214828337123",
        "name": "delete_github_repository_by_owner",
        "appName": "apigithubcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Mutation tool for deleting repositories in source_control: Permanently deletes a GitHub repository identified by owner and repo, requiring admin access and a token with delete_repo scope, and returns success on deletion or an error (e.g., 403 Forbidden) when permissions or organization policies block the action. Call when: you need to remove a repository entirely from GitHub after confirming the action is appropriate and authorized. Do not call when: you intend to archive, transfer ownership, rename, change visibility, or delete branches; use the corresponding repository management tools instead. Requires: owner (string, case-insensitive), repo (string without .git, case-insensitive), and an OAuth app or personal access token (Bearer) that includes delete_repo scope; the caller must have admin permissions on the target repository; for organization-owned repositories, ensure org settings permit member deletions. Rules: names are case-insensitive; if organization policies disallow deletion, expect 403 Forbidden; the operation is destructive and effectively irreversible; repeated calls after deletion are idempotent and may return not found; do not append .git to repo. Keywords: repository deletion, GitHub, admin permissions, delete_repo scope, organization policy, source control, destructive operation, 403 Forbidden.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aint_path": {
              "type": "object",
              "required": [
                "owner",
                "repo"
              ],
              "properties": {
                "repo": {
                  "type": "string",
                  "description": "The name of the repository without the `.git` extension. The name is not case sensitive."
                },
                "owner": {
                  "type": "string",
                  "description": "The account owner of the repository. The name is not case sensitive."
                }
              }
            }
          },
          "description": "Deleting a repository requires admin access.\n\nIf an organization owner has configured the organization to prevent members from deleting organization-owned\nrepositories, you will get a `403 Forbidden` response.\n\nOAuth app tokens and personal access tokens (classic) need the `delete_repo` scope to use this endpoint."
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "github",
              "com"
            ],
            "path": [
              "repos",
              "${owner}",
              "${repo}"
            ],
            "query": {},
            "protocol": "https"
          },
          "method": "DELETE",
          "headers": {}
        }
      },
      "canonical_data": {
        "name": "delete_github_repository_by_owner",
        "inputs": {
          "optional": "No additional optional parameters are defined. The only input container is aint_path, which must include owner and repo. Authentication (OAuth app or personal access token with delete_repo scope provided as a Bearer token) is required by the endpoint but is not represented in the schema as an input parameter.",
          "required": [
            "aint_path.owner: The account owner of the repository (user or organization), used to locate the target repository; the value is case-insensitive and is necessary to uniquely identify the repository to delete.",
            "aint_path.repo: The repository name without the .git suffix, used together with owner to identify the target repository; the value is case-insensitive and must not include .git."
          ]
        },
        "intent": "Permanently delete a specified GitHub repository identified by owner and name.",
        "context": "Repository and owner names are case-insensitive; do not append .git to the repo name. Organization policies may prevent deletion and yield 403 Forbidden even with admin permissions. The operation is a destructive mutation and is effectively irreversible; repeated calls after deletion are idempotent and may return Not Found. Authentication must be provided via a Bearer token with delete_repo scope. This tool is only for deletion; use other tools to archive, transfer, rename, change visibility, or delete branches.",
        "outputs": "An operation result indicating success or an error: on successful deletion, the call returns a success status (no repository data is returned); if permissions or organization policies block deletion, an error is returned (e.g., 403 Forbidden). After a successful deletion, subsequent calls may return Not Found for the same repository. These outcomes can be used by downstream logic to confirm deletion or handle permission/policy failures.",
        "operation": "Permanently delete a GitHub repository",
        "preconditions": "The caller must authenticate with an OAuth app token or personal access token (classic) that includes the delete_repo scope; the caller must have admin permissions on the target repository; for organization-owned repositories, the organization must allow members to delete repositories or the call will be blocked (403 Forbidden); the target repository is identified by a case-insensitive owner and repo name, and the repo value must not include the .git suffix.",
        "postconditions": "If successful, the specified GitHub repository is permanently deleted; the operation is destructive and effectively irreversible. Subsequent attempts to access or delete the same repository may indicate it no longer exists (e.g., Not Found). No other resources are modified.",
        "business_objects": [
          "GitHub repository",
          "repository owner account (user or organization)"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "list_repository_artifacts_by_id",
      "description": "Retrieval tool for listing artifacts in devops: lists GitHub Actions artifacts for a specific repository and returns a paginated collection of artifact metadata (e.g., id, name, size_bytes, created_at, expires_at in RFC3339 UTC), with optional exact-name filtering. Call when you need to enumerate or search repository artifacts, audit counts or expirations, or retrieve artifact metadata across pages. Do not call when you need to download or delete an artifact, fetch a single artifact by id, or list workflow runs or releases; use the corresponding download, delete, get, or workflow tools instead. Requires: owner (string, case-insensitive), repo (string without .git), per_page (integer 1\u2013100, default 30), page (integer >=1, default 1), and optional name (string for exact match); read access is mandatory, and for private repositories the OAuth or personal access token must include repo scope. Rules: this operation is read-only and idempotent; if name is provided, only exact matches are returned; per_page values above 100 are clamped to 100; results are paginated and server-ordered; timestamps are in RFC3339 UTC; provide owner/repo as canonical identifiers. Keywords: github actions, artifacts listing, repository metadata, pagination, devops, ci cd, audit, github api.",
      "document": {
        "id": "bf6ffa6e-2178-4885-9006-14a712a3957a",
        "name": "list_repository_artifacts_by_id",
        "appName": "apigithubcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for listing artifacts in devops: lists GitHub Actions artifacts for a specific repository and returns a paginated collection of artifact metadata (e.g., id, name, size_bytes, created_at, expires_at in RFC3339 UTC), with optional exact-name filtering. Call when you need to enumerate or search repository artifacts, audit counts or expirations, or retrieve artifact metadata across pages. Do not call when you need to download or delete an artifact, fetch a single artifact by id, or list workflow runs or releases; use the corresponding download, delete, get, or workflow tools instead. Requires: owner (string, case-insensitive), repo (string without .git), per_page (integer 1\u2013100, default 30), page (integer >=1, default 1), and optional name (string for exact match); read access is mandatory, and for private repositories the OAuth or personal access token must include repo scope. Rules: this operation is read-only and idempotent; if name is provided, only exact matches are returned; per_page values above 100 are clamped to 100; results are paginated and server-ordered; timestamps are in RFC3339 UTC; provide owner/repo as canonical identifiers. Keywords: github actions, artifacts listing, repository metadata, pagination, devops, ci cd, audit, github api.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aint_path": {
              "type": "object",
              "required": [
                "owner",
                "repo"
              ],
              "properties": {
                "repo": {
                  "type": "string",
                  "description": "The name of the repository without the `.git` extension. The name is not case sensitive."
                },
                "owner": {
                  "type": "string",
                  "description": "The account owner of the repository. The name is not case sensitive."
                }
              }
            },
            "aint_query": {
              "type": "object",
              "properties": {
                "name": {
                  "type": "string",
                  "description": "The name field of an artifact. When specified, only artifacts with this name will be returned."
                },
                "page": {
                  "type": "integer",
                  "default": 1,
                  "description": "The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.18/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""
                },
                "per_page": {
                  "type": "integer",
                  "default": 30,
                  "description": "The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.18/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""
                }
              }
            }
          },
          "description": "Lists all artifacts for a repository.\n\nAnyone with read access to the repository can use this endpoint.\n\nOAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository."
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "github",
              "com"
            ],
            "path": [
              "repos",
              "${owner}",
              "${repo}",
              "actions",
              "artifacts"
            ],
            "query": {},
            "protocol": "https"
          },
          "method": "GET",
          "headers": {}
        }
      },
      "canonical_data": {
        "name": "list_repository_artifacts_by_id",
        "inputs": {
          "optional": "Query parameters support pagination and filtering: name (string) restricts results to artifacts whose name exactly matches the provided value; page (integer, default 1) selects which results page to fetch (must be >= 1); per_page (integer, default 30, maximum 100; values above 100 are clamped) controls page size. These options do not change artifacts, only which subset is returned.",
          "required": [
            "owner: The account owner of the repository (case-insensitive). Identifies which repository's artifacts to list.",
            "repo: The repository name without the .git suffix (case-insensitive). Paired with owner to uniquely identify the repository whose artifacts are listed."
          ]
        },
        "intent": "Enumerate GitHub Actions artifacts for a specific repository and return a paginated set of artifact metadata, with optional exact-name filtering, for audit and discovery purposes.",
        "context": "Results are paginated and server-ordered. If name is provided, only exact-name matches are returned. Timestamps in the response are in RFC3339 UTC. Defaults: page=1 and per_page=30; per_page cannot exceed 100. This operation is read-only and idempotent. Use other dedicated tools to download, delete, or fetch a single artifact.",
        "outputs": "A paginated collection of GitHub Actions artifact metadata records for the specified repository. Each record includes fields such as id, name, size_bytes, created_at, and expires_at (timestamps in RFC3339 UTC). These identifiers and metadata can be used by downstream tools that fetch, download, or delete specific artifacts.",
        "operation": "List GitHub Actions artifacts for a repository",
        "preconditions": "The specified repository (owner/repo) must exist and be accessible to the caller with read access. For private repositories, the OAuth app token or personal access token must include the repo scope. Input constraints apply: page must be >= 1; per_page must be within 1\u2013100 (values above 100 are clamped). Owner and repo are provided as canonical, case-insensitive identifiers; repo must not include the .git extension.",
        "postconditions": "No server state is modified. On success, a read-only, idempotent retrieval of a page of artifact metadata is completed.",
        "business_objects": [
          "GitHub repository",
          "GitHub Actions artifact"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "list_github_repository_branches",
      "description": "Retrieval tool for listing branches in version_control: enumerates branch names for a GitHub repository with optional filtering by protection status and pagination; inputs include owner (string) and repo (string), plus protected (boolean), per_page (integer, max 100), and page (integer), and outputs a paginated list of branch records. Call when you need to discover all branches in a specific repository or to return only protected or only unprotected branches. Do not call when you need branch details (commit SHAs or rulesets), tags, pull requests, or to create, update, or delete branches; use repository detail or mutation tools instead. Requires owner and repo strings (case-insensitive), optional protected as a boolean true or false, per_page as an integer between 1 and 100 (default 30), and page as an integer >= 1 (default 1). Rules: if protected is set, return only branches matching that protection state; if omitted, return all branches; this call is read-only and idempotent; results are paginated\u2014iterate pages until no items remain to retrieve the complete set. Keywords: github branches, list repository branches, protected branches, branch enumeration, pagination, version control, git refs, repository listing.",
      "document": {
        "id": "ee70bbbb-27e6-4cf9-a490-cb5e42cff741",
        "name": "list_github_repository_branches",
        "appName": "apigithubcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for listing branches in version_control: enumerates branch names for a GitHub repository with optional filtering by protection status and pagination; inputs include owner (string) and repo (string), plus protected (boolean), per_page (integer, max 100), and page (integer), and outputs a paginated list of branch records. Call when you need to discover all branches in a specific repository or to return only protected or only unprotected branches. Do not call when you need branch details (commit SHAs or rulesets), tags, pull requests, or to create, update, or delete branches; use repository detail or mutation tools instead. Requires owner and repo strings (case-insensitive), optional protected as a boolean true or false, per_page as an integer between 1 and 100 (default 30), and page as an integer >= 1 (default 1). Rules: if protected is set, return only branches matching that protection state; if omitted, return all branches; this call is read-only and idempotent; results are paginated\u2014iterate pages until no items remain to retrieve the complete set. Keywords: github branches, list repository branches, protected branches, branch enumeration, pagination, version control, git refs, repository listing.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aint_path": {
              "type": "object",
              "required": [
                "owner",
                "repo"
              ],
              "properties": {
                "repo": {
                  "type": "string",
                  "description": "The name of the repository without the `.git` extension. The name is not case sensitive."
                },
                "owner": {
                  "type": "string",
                  "description": "The account owner of the repository. The name is not case sensitive."
                }
              }
            },
            "aint_query": {
              "type": "object",
              "properties": {
                "page": {
                  "type": "integer",
                  "default": 1,
                  "description": "The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.18/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""
                },
                "per_page": {
                  "type": "integer",
                  "default": 30,
                  "description": "The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.18/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""
                },
                "protected": {
                  "type": "boolean",
                  "description": "Setting to `true` returns only branches protected by branch protections or rulesets. When set to `false`, only unprotected branches are returned. Omitting this parameter returns all branches."
                }
              }
            }
          },
          "description": "List branches"
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "github",
              "com"
            ],
            "path": [
              "repos",
              "${owner}",
              "${repo}",
              "branches"
            ],
            "query": {},
            "protocol": "https"
          },
          "method": "GET",
          "headers": {}
        }
      },
      "canonical_data": {
        "name": "list_github_repository_branches",
        "inputs": {
          "optional": "Optional query parameters allow result shaping: a boolean 'protected' filter to return only protected or only unprotected branches when set, pagination controls via 'per_page' (integer 1\u2013100, default 30) to set page size, and 'page' (integer >= 1, default 1) to select which page to retrieve.",
          "required": [
            {
              "name": "owner",
              "description": "The account owner of the repository (case-insensitive). Identifies which GitHub account or organization the repository belongs to so the tool can locate the repository."
            },
            {
              "name": "repo",
              "description": "The name of the repository without the .git extension (case-insensitive). Specifies the target repository whose branches are to be listed."
            }
          ]
        },
        "intent": "Retrieve the list of branches for a specified GitHub repository, with optional filtering by protection status and support for pagination.",
        "context": "Branch names are enumerated for a single repository. Owner and repo identifiers are case-insensitive. If 'protected' is set, only branches matching that protection state are returned; if omitted, all branches are returned. Results are paginated with defaults per_page=30 and page=1; to retrieve all branches, iterate pages until no items remain. This tool is not for retrieving branch details (such as commit SHAs or rulesets), tags, or pull requests, and it does not create, update, or delete branches.",
        "outputs": "A paginated array of branch records for the specified repository. Each record represents a branch; the set reflects any applied protection filter and the requested page size/page number. These branch records (e.g., their names) can be used as inputs to other tools that operate on specific branches.",
        "operation": "List branches for a GitHub repository",
        "preconditions": "The specified repository owner and name must refer to an existing and accessible GitHub repository. The 'owner' and 'repo' values must be provided. If supplied, 'protected' must be a boolean. 'per_page' must be an integer between 1 and 100 (inclusive). 'page' must be an integer >= 1. The API endpoint must be reachable.",
        "postconditions": "No server-side state is changed; the operation is read-only and idempotent. On success, a single page of branch records is returned according to the provided filter and pagination parameters.",
        "business_objects": [
          "repository",
          "branch"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "get_github_repository_branch_by_id",
      "description": "Retrieval tool for fetching branch details in source control: Retrieves metadata for a specific branch within a repository by owner, repository name, and branch name, returning information about the branch reference and its head commit identifier. Call when: you know the exact branch name and need the current details for that branch in a given repository. Do not call when: you need to list or search branches, create/delete/protect branches, or fetch commits or pull requests; use a branch listing, branch mutation, or commit/PR tool instead; wildcard branch queries are not supported. Requires: owner (string, account login, case-insensitive), repo (string, repository name without .git, case-insensitive), branch (string, exact branch name; no wildcard characters); all parameters must be provided as plain UTF-8 strings. Rules: read-only and idempotent; names are matched literally (no partial matches); prefer UTC for any timestamps in responses; do not include URL prefixes or .git suffix in repo; errors if the repository or branch does not exist. Keywords: github branch, repository branch details, source control retrieval, git ref, head commit sha, version control api, branch metadata.",
      "document": {
        "id": "ec2d0029-f93a-45a3-a523-ef7a26b04549",
        "name": "get_github_repository_branch_by_id",
        "appName": "apigithubcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for fetching branch details in source control: Retrieves metadata for a specific branch within a repository by owner, repository name, and branch name, returning information about the branch reference and its head commit identifier. Call when: you know the exact branch name and need the current details for that branch in a given repository. Do not call when: you need to list or search branches, create/delete/protect branches, or fetch commits or pull requests; use a branch listing, branch mutation, or commit/PR tool instead; wildcard branch queries are not supported. Requires: owner (string, account login, case-insensitive), repo (string, repository name without .git, case-insensitive), branch (string, exact branch name; no wildcard characters); all parameters must be provided as plain UTF-8 strings. Rules: read-only and idempotent; names are matched literally (no partial matches); prefer UTC for any timestamps in responses; do not include URL prefixes or .git suffix in repo; errors if the repository or branch does not exist. Keywords: github branch, repository branch details, source control retrieval, git ref, head commit sha, version control api, branch metadata.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aint_path": {
              "type": "object",
              "required": [
                "branch",
                "owner",
                "repo"
              ],
              "properties": {
                "repo": {
                  "type": "string",
                  "description": "The name of the repository without the `.git` extension. The name is not case sensitive."
                },
                "owner": {
                  "type": "string",
                  "description": "The account owner of the repository. The name is not case sensitive."
                },
                "branch": {
                  "type": "string",
                  "description": "The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.18/graphql)."
                }
              }
            }
          },
          "description": "Get a branch"
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "github",
              "com"
            ],
            "path": [
              "repos",
              "${owner}",
              "${repo}",
              "branches",
              "${branch}"
            ],
            "query": {},
            "protocol": "https"
          },
          "method": "GET",
          "headers": {}
        }
      },
      "canonical_data": {
        "name": "get_github_repository_branch_by_id",
        "inputs": {
          "optional": "No optional parameters are supported. All inputs must be supplied inside the aint_path object; there is no pagination, filtering, or additional metadata accepted.",
          "required": [
            "owner: The account login of the repository owner (case-insensitive). Needed to locate the repository that contains the branch. Provided as a plain UTF-8 string within the aint_path object.",
            "repo: The repository name without the .git suffix (case-insensitive). Needed to identify the repository that contains the branch. Provided as a plain UTF-8 string within the aint_path object.",
            "branch: The exact branch name (no wildcard characters). Needed to identify the specific branch to retrieve. Provided as a plain UTF-8 string within the aint_path object."
          ]
        },
        "intent": "Retrieve details for a specific branch in a GitHub repository using its owner, repository name, and exact branch name.",
        "context": "This is a point lookup for a single branch; it does not list or search branches and does not create/delete/protect branches or retrieve commits/PRs. Wildcard branch queries are not supported. Inputs are matched literally (no partial matches); owner and repo are case-insensitive, branch must be exact. Do not include URL prefixes or a .git suffix in the repo name. The operation is idempotent and read-only. If timestamps are present in responses, they should be interpreted in UTC. Errors are returned if the repository or branch does not exist.",
        "outputs": "A single branch metadata record for the specified repository and branch, including information about the branch reference and its head commit identifier (e.g., the head commit SHA). These outputs can be used as inputs to other tools that require a branch reference or a commit identifier.",
        "operation": "retrieve branch metadata by owner, repository, and branch name",
        "preconditions": "The caller must provide owner, repo (without .git), and an exact branch name as plain UTF-8 strings within the aint_path object. The repository and the specified branch must exist; otherwise an error is returned. Branch names cannot include wildcard characters. Names are matched literally; owner and repo are case-insensitive. The API must be accessible.",
        "postconditions": "Read-only retrieval; no repository or branch state is modified. On success, the caller has the current metadata for the branch, including its head commit identifier.",
        "business_objects": [
          "branch",
          "commit"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "list_github_code_scanning_analyses",
      "description": "Category retrieval tool for listing code scanning analyses in devops/security: returns paginated analysis records for a repository, most recent first, with optional filters (tool_name, tool_guid, pr, ref, sarif_id) and sorting by created with asc/desc direction; outputs include analysis metadata such as rules_count and tool details, noting tool_name is deprecated and the tool field should be used. Call when you need an ordered, paginated list of code scanning analyses for a specific repository or to filter by tool or PR/branch reference. Do not call when you need individual alert findings, to upload SARIF results, or to change code scanning configuration; use alert retrieval or upload/configuration tools instead. Requires repository owner and repo strings, page integer >= 1, per_page integer 1\u2013100, direction in {asc, desc}, sort=created, optional pr integer, ref formatted as refs/pull/<number>/merge or refs/pull/<number>/head or refs/heads/<branch> or <branch>, optional sarif_id UUID string, optional tool_name string or tool_guid string; authentication must include security_events scope for private or public repositories or public_repo for public-only access. Rules: defaults are sort=created and direction=desc, results are paginated and deterministic for identical parameters, per_page above 100 is clamped, very old analyses may return rules_count=0, and clients should read tool from the tool field instead of tool_name in responses. Keywords: code scanning, repository analyses, GitHub security, SARIF uploads, pagination, sorting, rules_count.",
      "document": {
        "id": "2dec3c6e-607a-4fab-a861-18862c8225d4",
        "name": "list_github_code_scanning_analyses",
        "appName": "apigithubcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Category retrieval tool for listing code scanning analyses in devops/security: returns paginated analysis records for a repository, most recent first, with optional filters (tool_name, tool_guid, pr, ref, sarif_id) and sorting by created with asc/desc direction; outputs include analysis metadata such as rules_count and tool details, noting tool_name is deprecated and the tool field should be used. Call when you need an ordered, paginated list of code scanning analyses for a specific repository or to filter by tool or PR/branch reference. Do not call when you need individual alert findings, to upload SARIF results, or to change code scanning configuration; use alert retrieval or upload/configuration tools instead. Requires repository owner and repo strings, page integer >= 1, per_page integer 1\u2013100, direction in {asc, desc}, sort=created, optional pr integer, ref formatted as refs/pull/<number>/merge or refs/pull/<number>/head or refs/heads/<branch> or <branch>, optional sarif_id UUID string, optional tool_name string or tool_guid string; authentication must include security_events scope for private or public repositories or public_repo for public-only access. Rules: defaults are sort=created and direction=desc, results are paginated and deterministic for identical parameters, per_page above 100 is clamped, very old analyses may return rules_count=0, and clients should read tool from the tool field instead of tool_name in responses. Keywords: code scanning, repository analyses, GitHub security, SARIF uploads, pagination, sorting, rules_count.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aint_path": {
              "type": "object",
              "required": [
                "owner",
                "repo"
              ],
              "properties": {
                "repo": {
                  "type": "string",
                  "description": "The name of the repository without the `.git` extension. The name is not case sensitive."
                },
                "owner": {
                  "type": "string",
                  "description": "The account owner of the repository. The name is not case sensitive."
                }
              }
            },
            "aint_query": {
              "type": "object",
              "properties": {
                "pr": {
                  "type": "integer",
                  "description": "The number of the pull request for the results you want to list."
                },
                "ref": {
                  "type": "string",
                  "description": "The Git reference, formatted as `refs/pull/<number>/merge`, `refs/pull/<number>/head`,\n`refs/heads/<branch name>` or simply `<branch name>`."
                },
                "page": {
                  "type": "integer",
                  "default": 1,
                  "description": "The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.18/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""
                },
                "sort": {
                  "enum": [
                    "created"
                  ],
                  "type": "string",
                  "default": "created",
                  "description": "The property by which to sort the results."
                },
                "per_page": {
                  "type": "integer",
                  "default": 30,
                  "description": "The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.18/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""
                },
                "sarif_id": {
                  "type": "string",
                  "example": "6c81cd8e-b078-4ac3-a3be-1dad7dbd0b53",
                  "description": "An identifier for the upload."
                },
                "direction": {
                  "enum": [
                    "asc",
                    "desc"
                  ],
                  "type": "string",
                  "default": "desc",
                  "description": "The direction to sort the results by."
                },
                "tool_guid": {
                  "type": "string",
                  "nullable": true,
                  "description": "The GUID of the tool used to generate the code scanning analysis, if provided in the uploaded SARIF data."
                },
                "tool_name": {
                  "type": "string",
                  "description": "The name of the tool used to generate the code scanning analysis."
                }
              }
            }
          },
          "description": "Lists the details of all code scanning analyses for a repository,\nstarting with the most recent.\nThe response is paginated and you can use the `page` and `per_page` parameters\nto list the analyses you're interested in.\nBy default 30 analyses are listed per page.\n\nThe `rules_count` field in the response give the number of rules\nthat were run in the analysis.\nFor very old analyses this data is not available,\nand `0` is returned in this field.\n\n> [!WARNING]\n> **Closing down notice:** The `tool_name` field is closing down and will, in future, not be included in the response for this endpoint. The example response reflects this change. The tool name can now be found inside the `tool` field.\n\nOAuth app tokens and personal access tokens (classic) need the `security_events` scope to use this endpoint with private or public repositories, or the `public_repo` scope to use this endpoint with only public repositories."
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "github",
              "com"
            ],
            "path": [
              "repos",
              "${owner}",
              "${repo}",
              "code-scanning",
              "analyses"
            ],
            "query": {},
            "protocol": "https"
          },
          "method": "GET",
          "headers": {}
        }
      },
      "canonical_data": {
        "name": "list_github_code_scanning_analyses",
        "inputs": {
          "optional": "Query parameters enable pagination and filtering: page (default 1, must be >= 1) and per_page (default 30, max 100 and clamped if higher) control pagination; sort is fixed to 'created'; direction determines sort order ('asc' or 'desc', default 'desc'). Filters include pr (pull request number), ref (Git reference formatted as refs/pull/<number>/merge, refs/pull/<number>/head, refs/heads/<branch> or <branch>), sarif_id (upload identifier, UUID string), tool_guid (GUID from uploaded SARIF, nullable), and tool_name (deprecated input; use tool_guid where possible).",
          "required": [
            "owner: The account owner of the target repository; required to identify which repository's analyses to list.",
            "repo: The name of the repository (without the .git extension, case-insensitive); required to locate and list analyses for that specific repository."
          ]
        },
        "intent": "Retrieve an ordered, paginated list of code scanning analyses for a specified repository, with optional filters and sort direction.",
        "context": "By default, results are sorted by creation time in descending order and 30 analyses are returned per page. Pagination follows standard page/per_page semantics and produces deterministic results for the same input parameters. Very old analyses may report rules_count as 0. The tool_name field in responses is being deprecated; clients should read tool details from the 'tool' field. This endpoint is for listing analyses only; use other endpoints for individual alert retrieval, SARIF uploads, or configuration changes.",
        "outputs": "A paginated list of code scanning analysis records for the repository, ordered by creation time per the requested direction. Each record includes analysis metadata such as the rules_count (may be 0 for very old analyses) and tool details (use the 'tool' field rather than the deprecated 'tool_name'). These records can be used downstream to correlate analyses with tools, pull requests, branches, or SARIF uploads (e.g., via sarif_id).",
        "operation": "List code scanning analyses",
        "preconditions": "A valid repository must be addressable via the provided owner and repo. Authentication must include either the security_events scope for private or public repositories, or the public_repo scope for access limited to public repositories. Query constraints must be respected: page >= 1; per_page between 1 and 100 (values above 100 are clamped); sort must be 'created'; direction must be 'asc' or 'desc'; ref, if provided, must match the specified formats; sarif_id, if provided, should be a UUID string; tool_guid, if provided, should be a GUID string (nullable).",
        "postconditions": "No state is mutated; the operation is read-only. Upon success, the specified page of analyses is returned in a deterministic order for identical parameters, with per_page capped at 100 when higher values are requested.",
        "business_objects": [
          "code scanning analysis",
          "repository"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "delete_github_code_scanning_analysis",
      "description": "Mutation tool for deleting analyses in code scanning: deletes a specified GitHub code scanning analysis from a repository given owner, repo, and analysis_id, deleting only if it is the most recent in its (ref, tool, category) set, and returns next_analysis_url and confirm_delete_url to guide subsequent deletions. Call when: you need to remove a particular analysis or iterate through a set of analyses for a tool, typically after listing analyses and selecting one marked deletable=true. Do not call when: you want to list or read analyses (use list/get tools), disable code scanning, or delete alerts; also do not call if the analysis is not the most recent in its set. Requires: owner and repo as case-insensitive strings, analysis_id as an integer from the listing API, and optionally confirm_delete set to 'true' (string) to allow deleting the last analysis in a set; valid authentication with repo or public_repo scopes must already be in place. Rules: only the latest analysis in a set is deletable; if confirm_delete is not 'true' and the target is last, the API returns 400; on success URLs may be null when no further deletions remain; repeated calls after deletion may 404; prefer using next_analysis_url to avoid removing the final analysis, and use confirm_delete_url when intentionally clearing a set. Keywords: github code scanning, delete analysis, repository security, analysis_id, confirm_delete, next_analysis_url, devops, static analysis.",
      "document": {
        "id": "a8706e3a-30b6-4ad6-900d-860a7c40f005",
        "name": "delete_github_code_scanning_analysis",
        "appName": "apigithubcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Mutation tool for deleting analyses in code scanning: deletes a specified GitHub code scanning analysis from a repository given owner, repo, and analysis_id, deleting only if it is the most recent in its (ref, tool, category) set, and returns next_analysis_url and confirm_delete_url to guide subsequent deletions. Call when: you need to remove a particular analysis or iterate through a set of analyses for a tool, typically after listing analyses and selecting one marked deletable=true. Do not call when: you want to list or read analyses (use list/get tools), disable code scanning, or delete alerts; also do not call if the analysis is not the most recent in its set. Requires: owner and repo as case-insensitive strings, analysis_id as an integer from the listing API, and optionally confirm_delete set to 'true' (string) to allow deleting the last analysis in a set; valid authentication with repo or public_repo scopes must already be in place. Rules: only the latest analysis in a set is deletable; if confirm_delete is not 'true' and the target is last, the API returns 400; on success URLs may be null when no further deletions remain; repeated calls after deletion may 404; prefer using next_analysis_url to avoid removing the final analysis, and use confirm_delete_url when intentionally clearing a set. Keywords: github code scanning, delete analysis, repository security, analysis_id, confirm_delete, next_analysis_url, devops, static analysis.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aint_path": {
              "type": "object",
              "required": [
                "analysis_id",
                "owner",
                "repo"
              ],
              "properties": {
                "repo": {
                  "type": "string",
                  "description": "The name of the repository without the `.git` extension. The name is not case sensitive."
                },
                "owner": {
                  "type": "string",
                  "description": "The account owner of the repository. The name is not case sensitive."
                },
                "analysis_id": {
                  "type": "number",
                  "description": "The ID of the analysis, as returned from the `GET /repos/{owner}/{repo}/code-scanning/analyses` operation."
                }
              }
            },
            "aint_query": {
              "type": "object",
              "properties": {
                "confirm_delete": {
                  "type": "string",
                  "nullable": true,
                  "description": "Allow deletion if the specified analysis is the last in a set. If you attempt to delete the final analysis in a set without setting this parameter to `true`, you'll get a 400 response with the message: `Analysis is last of its type and deletion may result in the loss of historical alert data. Please specify confirm_delete.`"
                }
              }
            }
          },
          "description": "Deletes a specified code scanning analysis from a repository.\n\nYou can delete one analysis at a time.\nTo delete a series of analyses, start with the most recent analysis and work backwards.\nConceptually, the process is similar to the undo function in a text editor.\n\nWhen you list the analyses for a repository,\none or more will be identified as deletable in the response:\n\n```\n\"deletable\": true\n```\n\nAn analysis is deletable when it's the most recent in a set of analyses.\nTypically, a repository will have multiple sets of analyses\nfor each enabled code scanning tool,\nwhere a set is determined by a unique combination of analysis values:\n\n* `ref`\n* `tool`\n* `category`\n\nIf you attempt to delete an analysis that is not the most recent in a set,\nyou'll get a 400 response with the message:\n\n```\nAnalysis specified is not deletable.\n```\n\nThe response from a successful `DELETE` operation provides you with\ntwo alternative URLs for deleting the next analysis in the set:\n`next_analysis_url` and `confirm_delete_url`.\nUse the `next_analysis_url` URL if you want to avoid accidentally deleting the final analysis\nin a set. This is a useful option if you want to preserve at least one analysis\nfor the specified tool in your repository.\nUse the `confirm_delete_url` URL if you are content to remove all analyses for a tool.\nWhen you delete the last analysis in a set, the value of `next_analysis_url` and `confirm_delete_url`\nin the 200 response is `null`.\n\nAs an example of the deletion process,\nlet's imagine that you added a workflow that configured a particular code scanning tool\nto analyze the code in a repository. This tool has added 15 analyses:\n10 on the default branch, and another 5 on a topic branch.\nYou therefore have two separate sets of analyses for this tool.\nYou've now decided that you want to remove all of the analyses for the tool.\nTo do this you must make 15 separate deletion requests.\nTo start, you must find an analysis that's identified as deletable.\nEach set of analyses always has one that's identified as deletable.\nHaving found the deletable analysis for one of the two sets,\ndelete this analysis and then continue deleting the next analysis in the set until they're all deleted.\nThen repeat the process for the second set.\nThe procedure therefore consists of a nested loop:\n\n**Outer loop**:\n* List the analyses for the repository, filtered by tool.\n* Parse this list to find a deletable analysis. If found:\n\n  **Inner loop**:\n  * Delete the identified analysis.\n  * Parse the response for the value of `confirm_delete_url` and, if found, use this in the next iteration.\n\nThe above process assumes that you want to remove all trace of the tool's analyses from the GitHub user interface, for the specified repository, and it therefore uses the `confirm_delete_url` value. Alternatively, you could use the `next_analysis_url` value, which would leave the last analysis in each set undeleted to avoid removing a tool's analysis entirely.\n\nOAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with private or public repositories, or the `public_repo` scope to use this endpoint with only public repositories."
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "github",
              "com"
            ],
            "path": [
              "repos",
              "${owner}",
              "${repo}",
              "code-scanning",
              "analyses",
              "${analysis_id}"
            ],
            "query": {},
            "protocol": "https"
          },
          "method": "DELETE",
          "headers": {}
        }
      },
      "canonical_data": {
        "name": "delete_github_code_scanning_analysis",
        "inputs": {
          "optional": "confirm_delete (query string) may be set to 'true' to allow deletion when the specified analysis is the last remaining in its (ref, tool, category) set; if omitted or not 'true' and the target is the final analysis, the API returns 400 and does not delete. Standard authentication must already be in place (OAuth app or personal access token with repo scope for private or public repos, or public_repo for only public repos).",
          "required": [
            "owner: Case-insensitive string identifying the account owner of the target repository; needed to locate the repository in which the analysis resides.",
            "repo: Case-insensitive string for the repository name (without .git); required to precisely target the repository containing the analysis to delete.",
            "analysis_id: Numeric identifier of the analysis as provided by the listing endpoint (GET /repos/{owner}/{repo}/code-scanning/analyses); required to specify exactly which analysis to delete."
          ]
        },
        "intent": "Delete a specific GitHub code scanning analysis from a repository while enforcing set-based rules, and return URLs that guide safe, sequential deletion of remaining analyses.",
        "context": "This endpoint deletes exactly one analysis per call. Only the most recent analysis in a set (defined by the combination of ref, tool, and category) is deletable; attempting to delete a non-most-recent analysis yields 400 ('Analysis specified is not deletable'). If the target analysis is the final one in the set and confirm_delete is not 'true', the API returns 400 with a message instructing to specify confirm_delete. Use next_analysis_url to safely step backward through a set while preserving the final analysis, and use confirm_delete_url to remove all analyses in a set. When no further deletions remain, both URLs in the response are null. Owner and repo are case-insensitive strings. analysis_id must be obtained from the listing API. Repeating the same deletion after success may yield 404.",
        "outputs": "On successful deletion (200), returns an object containing next_analysis_url and confirm_delete_url. Each value is either a URL string or null. next_analysis_url points to the endpoint for deleting the next most recent analysis in the same set without deleting the final one, while confirm_delete_url points to the endpoint for deleting the next analysis even if it is the last in the set. When the last analysis in a set has been deleted, both URLs are null. These URLs can be used directly as inputs (request targets) for subsequent deletion calls.",
        "operation": "Delete a specified code scanning analysis from a repository",
        "preconditions": "The caller must be authenticated with appropriate scopes: repo for private or public repositories, or public_repo if only public repositories are accessed. The specified repository (owner/repo) must exist and be accessible to the caller. The analysis_id must refer to an existing code scanning analysis in that repository. To succeed, the target analysis must be the most recent in its (ref, tool, category) set; if it is the last remaining analysis in the set, confirm_delete must be provided as the string 'true', otherwise the request fails with 400.",
        "postconditions": "If successful, the specified code scanning analysis is removed from the repository. The set\u2019s most recent analysis is deleted, reducing the number of analyses in that set; if it was the last, the set now has no remaining analyses. The response provides URLs to continue deletion in sequence. Subsequent attempts to delete the same analysis_id will return 404 as it no longer exists.",
        "business_objects": [
          "code scanning analysis",
          "repository",
          "analysis set (ref, tool, category)"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "get_github_repository_commit_comment",
      "description": "Retrieval tool for fetching a single commit comment by ID in source_control: Retrieves the metadata and body of a specific commit comment in a repository using owner, repo, and comment_id, and may return raw markdown (body), text-only (body_text), and HTML-rendered (body_html) depending on media type. Call when you need the content or metadata of a known commit comment in a specific repository. Do not call when you need to list all commit comments, work with pull request review or issue comments, modify or delete comments, or retrieve commit details; use the appropriate listing, PR, issue, or mutation tools instead. Requires owner (string, case-insensitive), repo (string without .git), and comment_id (integer). Rules: read-only and idempotent; the comment_id must belong to the specified repository; pagination is not applicable; response representation varies by HTTP Accept media type and defaults to raw markdown in body if unspecified; if body_text or body_html are absent, rely on body. Keywords: commit comment, GitHub repository, source control, SCM, get by id, code review, REST API.",
      "document": {
        "id": "585457dd-7a3b-4800-9ac0-b48a7b72b13f",
        "name": "get_github_repository_commit_comment",
        "appName": "apigithubcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for fetching a single commit comment by ID in source_control: Retrieves the metadata and body of a specific commit comment in a repository using owner, repo, and comment_id, and may return raw markdown (body), text-only (body_text), and HTML-rendered (body_html) depending on media type. Call when you need the content or metadata of a known commit comment in a specific repository. Do not call when you need to list all commit comments, work with pull request review or issue comments, modify or delete comments, or retrieve commit details; use the appropriate listing, PR, issue, or mutation tools instead. Requires owner (string, case-insensitive), repo (string without .git), and comment_id (integer). Rules: read-only and idempotent; the comment_id must belong to the specified repository; pagination is not applicable; response representation varies by HTTP Accept media type and defaults to raw markdown in body if unspecified; if body_text or body_html are absent, rely on body. Keywords: commit comment, GitHub repository, source control, SCM, get by id, code review, REST API.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aint_path": {
              "type": "object",
              "required": [
                "comment_id",
                "owner",
                "repo"
              ],
              "properties": {
                "repo": {
                  "type": "string",
                  "description": "The name of the repository without the `.git` extension. The name is not case sensitive."
                },
                "owner": {
                  "type": "string",
                  "description": "The account owner of the repository. The name is not case sensitive."
                },
                "comment_id": {
                  "type": "number",
                  "description": "The unique identifier of the comment."
                }
              }
            }
          },
          "description": "Gets a specified commit comment.\n\nThis endpoint supports the following custom media types. For more information, see \"[Media types](https://docs.github.com/enterprise-server@3.18/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).\"\n\n- **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.\n- **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.\n- **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.\n- **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`."
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "github",
              "com"
            ],
            "path": [
              "repos",
              "${owner}",
              "${repo}",
              "comments",
              "${comment_id}"
            ],
            "query": {},
            "protocol": "https"
          },
          "method": "GET",
          "headers": {}
        }
      },
      "canonical_data": {
        "name": "get_github_repository_commit_comment",
        "inputs": {
          "optional": "No additional input fields are defined in the schema. Response representation (raw markdown, text-only, HTML, or all) is selected via the HTTP Accept media type outside this input schema.",
          "required": [
            "owner (string; case-insensitive) \u2014 The account owner of the repository, provided within aint_path.owner. It scopes which account hosts the repository so the comment lookup occurs in the correct namespace.",
            "repo (string; case-insensitive; omit .git) \u2014 The repository name, provided within aint_path.repo. It defines which repository contains the target commit comment.",
            "comment_id (number/integer) \u2014 The unique identifier of the commit comment, provided within aint_path.comment_id. It specifies exactly which commit comment to retrieve."
          ]
        },
        "intent": "Retrieve the content and metadata of a single GitHub commit comment by its identifier within a specific repository.",
        "context": "Pagination does not apply (single resource fetch). Representation varies by HTTP Accept media type: application/vnd.github-commitcomment.raw+json (default; includes body), application/vnd.github-commitcomment.text+json (includes body_text), application/vnd.github-commitcomment.html+json (includes body_html), and application/vnd.github-commitcomment.full+json (includes body, body_text, and body_html). If body_text or body_html are absent, rely on body. Use only for commit comments (not for listing comments, pull request review comments, issue comments, mutations, or commit detail retrieval). The operation is idempotent and read-only.",
        "outputs": "A single commit comment object in JSON containing the comment\u2019s metadata and its body content. Depending on the requested media type, the payload includes one or more of: body (raw markdown), body_text (plain text), and body_html (HTML-rendered). This returned commit comment record (including its id and body fields) can be used wherever a commit comment\u2019s identifier or content is needed by other tools.",
        "operation": "Fetch a specific commit comment by ID from a repository",
        "preconditions": "The inputs owner, repo, and comment_id must be provided (as aint_path.owner, aint_path.repo, and aint_path.comment_id). The specified repository must exist, and the given comment_id must belong to that repository. Owner and repo matching are case-insensitive, and the repo name must not include the .git suffix.",
        "postconditions": "Read-only operation; no resources are created, modified, or deleted. After success, the specified commit comment\u2019s metadata and body content are available to the caller in the requested representation.",
        "business_objects": [
          "commit comment",
          "repository",
          "repository owner"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "rename_github_repository_branch",
      "description": "Mutation tool for renaming branches in version_control: changes the name of an existing branch in a GitHub repository from a specified current name to a new name using repository owner and repo identifiers, returning an immediate acknowledgment while the rename completes asynchronously. Call when you need to rename an existing branch (including the default branch) within a specific repository. Do not call when creating or deleting branches, moving commits, retagging, changing repository settings, or renaming files; use dedicated branch create/delete or repository configuration tools instead. Requires: owner (string, case-insensitive), repo (string, case-insensitive, without .git), branch (string, current branch name, no wildcard characters), new_name (string, desired branch name, no wildcard characters), and credentials with push access; if the branch is the default branch, admin or owner permissions are required, and fine-grained tokens must include administration:write. Rules: the rename is asynchronous and pushes to the old branch name are blocked during the process; if new_name equals the current name, treat as a no-op; branch names cannot contain wildcard characters; operation is scoped to the specified repository and names should be provided exactly as stored. Keywords: branch rename, repository management, github, git, version control, default branch, permissions, asynchronous operation.",
      "document": {
        "id": "c84a6612-7b99-43e7-a6d2-e59a173574af",
        "name": "rename_github_repository_branch",
        "appName": "apigithubcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Mutation tool for renaming branches in version_control: changes the name of an existing branch in a GitHub repository from a specified current name to a new name using repository owner and repo identifiers, returning an immediate acknowledgment while the rename completes asynchronously. Call when you need to rename an existing branch (including the default branch) within a specific repository. Do not call when creating or deleting branches, moving commits, retagging, changing repository settings, or renaming files; use dedicated branch create/delete or repository configuration tools instead. Requires: owner (string, case-insensitive), repo (string, case-insensitive, without .git), branch (string, current branch name, no wildcard characters), new_name (string, desired branch name, no wildcard characters), and credentials with push access; if the branch is the default branch, admin or owner permissions are required, and fine-grained tokens must include administration:write. Rules: the rename is asynchronous and pushes to the old branch name are blocked during the process; if new_name equals the current name, treat as a no-op; branch names cannot contain wildcard characters; operation is scoped to the specified repository and names should be provided exactly as stored. Keywords: branch rename, repository management, github, git, version control, default branch, permissions, asynchronous operation.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_body"
          ],
          "properties": {
            "aint_body": {
              "type": "object",
              "required": [
                "new_name"
              ],
              "properties": {
                "new_name": {
                  "type": "string",
                  "description": "The new name of the branch."
                }
              }
            },
            "aint_path": {
              "type": "object",
              "required": [
                "branch",
                "owner",
                "repo"
              ],
              "properties": {
                "repo": {
                  "type": "string",
                  "description": "The name of the repository without the `.git` extension. The name is not case sensitive."
                },
                "owner": {
                  "type": "string",
                  "description": "The account owner of the repository. The name is not case sensitive."
                },
                "branch": {
                  "type": "string",
                  "description": "The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/enterprise-server@3.18/graphql)."
                }
              }
            }
          },
          "description": "Renames a branch in a repository.\n\n> [!NOTE]\n> Although the API responds immediately, the branch rename process might take some extra time to complete in the background. You won't be able to push to the old branch name while the rename process is in progress. For more information, see \"[Renaming a branch](https://docs.github.com/enterprise-server@3.18/github/administering-a-repository/renaming-a-branch)\".\n\nThe authenticated user must have push access to the branch. If the branch is the default branch, the authenticated user must also have admin or owner permissions.\n\nIn order to rename the default branch, fine-grained access tokens also need the `administration:write` repository permission."
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "github",
              "com"
            ],
            "path": [
              "repos",
              "${owner}",
              "${repo}",
              "branches",
              "${branch}",
              "rename"
            ],
            "query": {},
            "protocol": "https"
          },
          "method": "POST",
          "headers": {
            "Content-Type": "application/json"
          }
        }
      },
      "canonical_data": {
        "name": "rename_github_repository_branch",
        "inputs": {
          "optional": "aint_path: Object providing the path identifiers for the target branch and repository, including owner (account owner, case-insensitive), repo (repository name without .git, case-insensitive), and branch (current branch name, cannot contain wildcard characters). These identify which repository and branch to rename and must match stored names; the operation is scoped to the specified repository.",
          "required": [
            "aint_body: Object containing the new_name field. It specifies the desired new branch name and is required to perform the rename operation."
          ]
        },
        "intent": "Initiate an asynchronous rename of an existing branch within a specified GitHub repository.",
        "context": "The API responds immediately while the rename continues in the background. Owner and repo identifiers are case-insensitive; repo must be provided without the .git extension. The branch name cannot include wildcard characters (use the GraphQL API if wildcards are needed). The operation is strictly for renaming existing branches (including the default branch) within a single repository; it does not create/delete branches or alter commits, tags, files, or other repository settings.",
        "outputs": "An immediate acknowledgment that the branch rename request has been accepted; the actual rename completes asynchronously. No detailed branch data is guaranteed in the response. This acknowledgment can be used to confirm initiation before using the new branch name elsewhere.",
        "operation": "Rename an existing GitHub repository branch",
        "preconditions": "The specified repository and branch must exist and be addressable by owner, repo, and branch identifiers. The authenticated user must have push access to the branch. If renaming the default branch, the user must also have admin or owner permissions; fine-grained access tokens additionally require administration:write. Branch names (current and new) must not contain wildcard characters, and names should be provided exactly as stored. If the new_name equals the current branch name, the operation is treated as a no-op.",
        "postconditions": "On success, the branch rename process is initiated (the tool is mutating but completes asynchronously). During the rename process, pushes to the old branch name are blocked. Eventually, the branch will appear under the new name if the background operation completes successfully; no immediate state change is guaranteed in the response.",
        "business_objects": [
          "Repository",
          "Branch"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "get_code_scanning_analysis_by_id",
      "description": "Retrieval tool for fetching a code scanning analysis in security: fetches a single code scanning analysis for a GitHub repository by owner, repo, and analysis_id, returning metadata such as git ref, commit SHA, analysis datetime (RFC3339 UTC), scanning tool name, alert count, and rules_count, or a SARIF v2.1.0 subset when the Accept header is application/sarif+json. Call when: you have a known analysis_id from a prior listing or webhook and need the detailed metadata or SARIF content for that specific analysis in a given repository. Do not call when: you need to enumerate analyses, query alerts, or upload results; use a listing or alert-query/upload tool instead. Requires: owner (string), repo (string), analysis_id (integer), valid authentication (security_events scope for private or public repositories, or public_repo for public-only); repository names are case-insensitive; if requesting SARIF, set Accept to application/sarif+json. Rules: read-only and idempotent; when SARIF is requested, the response emphasizes SARIF data (including github/alertNumber and github/alertUrl) instead of the summary; for very old analyses rules_count may be 0 and not indicative of rule execution; prefer UTC for time interpretation and do not supply commit identifiers as inputs. Keywords: code scanning, SARIF v2.1.0, GitHub security events, repository analysis, static analysis, alerts count, commit SHA, rules_count.",
      "document": {
        "id": "b4011bc0-252f-4941-a3fc-259d65e1bdbb",
        "name": "get_code_scanning_analysis_by_id",
        "appName": "apigithubcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for fetching a code scanning analysis in security: fetches a single code scanning analysis for a GitHub repository by owner, repo, and analysis_id, returning metadata such as git ref, commit SHA, analysis datetime (RFC3339 UTC), scanning tool name, alert count, and rules_count, or a SARIF v2.1.0 subset when the Accept header is application/sarif+json. Call when: you have a known analysis_id from a prior listing or webhook and need the detailed metadata or SARIF content for that specific analysis in a given repository. Do not call when: you need to enumerate analyses, query alerts, or upload results; use a listing or alert-query/upload tool instead. Requires: owner (string), repo (string), analysis_id (integer), valid authentication (security_events scope for private or public repositories, or public_repo for public-only); repository names are case-insensitive; if requesting SARIF, set Accept to application/sarif+json. Rules: read-only and idempotent; when SARIF is requested, the response emphasizes SARIF data (including github/alertNumber and github/alertUrl) instead of the summary; for very old analyses rules_count may be 0 and not indicative of rule execution; prefer UTC for time interpretation and do not supply commit identifiers as inputs. Keywords: code scanning, SARIF v2.1.0, GitHub security events, repository analysis, static analysis, alerts count, commit SHA, rules_count.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aint_path": {
              "type": "object",
              "required": [
                "analysis_id",
                "owner",
                "repo"
              ],
              "properties": {
                "repo": {
                  "type": "string",
                  "description": "The name of the repository without the `.git` extension. The name is not case sensitive."
                },
                "owner": {
                  "type": "string",
                  "description": "The account owner of the repository. The name is not case sensitive."
                },
                "analysis_id": {
                  "type": "number",
                  "description": "The ID of the analysis, as returned from the `GET /repos/{owner}/{repo}/code-scanning/analyses` operation."
                }
              }
            }
          },
          "description": "Gets a specified code scanning analysis for a repository.\n\nThe default JSON response contains fields that describe the analysis.\nThis includes the Git reference and commit SHA to which the analysis relates,\nthe datetime of the analysis, the name of the code scanning tool,\nand the number of alerts.\n\nThe `rules_count` field in the default response give the number of rules\nthat were run in the analysis.\nFor very old analyses this data is not available,\nand `0` is returned in this field.\n\nThis endpoint supports the following custom media types. For more information, see \"[Media types](https://docs.github.com/enterprise-server@3.18/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).\"\n\n- **`application/sarif+json`**: Instead of returning a summary of the analysis, this endpoint returns a subset of the analysis data that was uploaded. The data is formatted as [SARIF version 2.1.0](https://docs.oasis-open.org/sarif/sarif/v2.1.0/cs01/sarif-v2.1.0-cs01.html). It also returns additional data such as the `github/alertNumber` and `github/alertUrl` properties.\n\nOAuth app tokens and personal access tokens (classic) need the `security_events` scope to use this endpoint with private or public repositories, or the `public_repo` scope to use this endpoint with only public repositories."
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "github",
              "com"
            ],
            "path": [
              "repos",
              "${owner}",
              "${repo}",
              "code-scanning",
              "analyses",
              "${analysis_id}"
            ],
            "query": {},
            "protocol": "https"
          },
          "method": "GET",
          "headers": {}
        }
      },
      "canonical_data": {
        "name": "get_code_scanning_analysis_by_id",
        "inputs": {
          "optional": "Clients may set the Accept header to application/sarif+json to receive a SARIF v2.1.0-formatted subset of the uploaded analysis data, including GitHub-specific properties (github/alertNumber and github/alertUrl). If no custom media type is requested, the default JSON response returns analysis metadata (git ref, commit SHA, RFC3339 UTC datetime, code scanning tool name, alert count, and rules_count). No pagination or additional query parameters are supported for this single-analysis retrieval.",
          "required": [
            "owner: The case-insensitive account owner of the repository. Needed to locate the repository whose analysis is being fetched. Provided within the aint_path object.",
            "repo: The case-insensitive repository name (without the .git extension). Needed to identify the repository containing the analysis. Provided within the aint_path object.",
            "analysis_id: The numeric ID of the analysis, as previously returned by listing analyses for the repository. Needed to select the specific analysis to retrieve. Provided within the aint_path object."
          ]
        },
        "intent": "Retrieve a single code scanning analysis for a specified GitHub repository by its analysis ID, returning either a summary of analysis metadata or a SARIF v2.1.0 subset depending on media type requested.",
        "context": "This endpoint is idempotent and read-only. Media type negotiation via the Accept header controls the response: application/sarif+json yields SARIF v2.1.0 subset data (including github/alertNumber and github/alertUrl); otherwise, a default JSON summary of the analysis is returned. Analysis times are provided in RFC3339 UTC; prefer UTC interpretation. Repository names are case-insensitive. The rules_count field may be 0 for very old analyses and is not indicative of rule execution in that case. Selection is strictly by analysis_id; commit identifiers are not provided as inputs. The tool is intended for retrieving a single analysis and does not support listing or pagination.",
        "outputs": "On success, returns either: (1) a single analysis metadata record describing the code scanning analysis (including the Git reference, commit SHA, RFC3339 UTC analysis datetime, code scanning tool name, alert count, and rules_count), or (2) when Accept is application/sarif+json, a subset of the analysis data formatted as SARIF v2.1.0, augmented with GitHub-specific properties such as github/alertNumber and github/alertUrl. The metadata record can be used by downstream tools to correlate analyses with commits/refs or to assess alert/rule counts, while the SARIF subset can be consumed by SARIF-compatible processors or tools that link alerts via the provided URLs.",
        "operation": "Fetch code scanning analysis by ID",
        "preconditions": "A valid authentication token is required: security_events scope for private or public repositories, or public_repo scope for public-only access. The specified repository (owner/repo) must exist and be accessible, and names are treated case-insensitively. The provided analysis_id must correspond to an existing code scanning analysis in that repository. The API endpoint must be reachable. To receive SARIF data, the client must set the Accept header to application/sarif+json.",
        "postconditions": "Read-only operation with no server-side state changes. After successful execution, the caller has the requested analysis data (either metadata summary or SARIF v2.1.0 subset) for the specified analysis ID.",
        "business_objects": [
          "code scanning analysis",
          "repository",
          "SARIF v2.1.0 report subset"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "list_github_repository_commit_comments",
      "description": "Retrieval tool for listing commit comments in source control: Returns all commit comments for a specified repository, ordered by ascending comment ID, with optional pagination and media type selection (raw markdown, text, HTML, or full). Call when you need a repository-wide list of commit-level comments across all commits to analyze discussion, extract bodies, or audit activity. Do not call when you need issue comments, pull request review comments, or comments for a specific commit only; use the respective issue/PR/commit comment tools instead, and do not call to create, update, or delete comments. Requires: owner and repo as case-insensitive strings; optional per_page integer 1\u2013100 and page integer >=1; if a media type is needed, set the HTTP Accept header to one of application/vnd.github-commitcomment.raw+json, application/vnd.github-commitcomment.text+json, application/vnd.github-commitcomment.html+json, or application/vnd.github-commitcomment.full+json. Rules: results are ordered by id ascending; default media type returns body; pagination is page-based (page, per_page), start at page 1; timestamps are returned in RFC3339 UTC; if per_page is set, results are limited and additional calls are required to iterate pages. Keywords: github, repository, commit comments, pagination, media types, source control, code review, retrieval.",
      "document": {
        "id": "e8f3f65e-2959-420c-bfa4-198c9753f8de",
        "name": "list_github_repository_commit_comments",
        "appName": "apigithubcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for listing commit comments in source control: Returns all commit comments for a specified repository, ordered by ascending comment ID, with optional pagination and media type selection (raw markdown, text, HTML, or full). Call when you need a repository-wide list of commit-level comments across all commits to analyze discussion, extract bodies, or audit activity. Do not call when you need issue comments, pull request review comments, or comments for a specific commit only; use the respective issue/PR/commit comment tools instead, and do not call to create, update, or delete comments. Requires: owner and repo as case-insensitive strings; optional per_page integer 1\u2013100 and page integer >=1; if a media type is needed, set the HTTP Accept header to one of application/vnd.github-commitcomment.raw+json, application/vnd.github-commitcomment.text+json, application/vnd.github-commitcomment.html+json, or application/vnd.github-commitcomment.full+json. Rules: results are ordered by id ascending; default media type returns body; pagination is page-based (page, per_page), start at page 1; timestamps are returned in RFC3339 UTC; if per_page is set, results are limited and additional calls are required to iterate pages. Keywords: github, repository, commit comments, pagination, media types, source control, code review, retrieval.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aint_path": {
              "type": "object",
              "required": [
                "owner",
                "repo"
              ],
              "properties": {
                "repo": {
                  "type": "string",
                  "description": "The name of the repository without the `.git` extension. The name is not case sensitive."
                },
                "owner": {
                  "type": "string",
                  "description": "The account owner of the repository. The name is not case sensitive."
                }
              }
            },
            "aint_query": {
              "type": "object",
              "properties": {
                "page": {
                  "type": "integer",
                  "default": 1,
                  "description": "The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.18/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""
                },
                "per_page": {
                  "type": "integer",
                  "default": 30,
                  "description": "The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.18/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""
                }
              }
            }
          },
          "description": "Lists the commit comments for a specified repository. Comments are ordered by ascending ID.\n\nThis endpoint supports the following custom media types. For more information, see \"[Media types](https://docs.github.com/enterprise-server@3.18/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).\"\n\n- **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.\n- **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.\n- **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.\n- **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`."
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "github",
              "com"
            ],
            "path": [
              "repos",
              "${owner}",
              "${repo}",
              "comments"
            ],
            "query": {},
            "protocol": "https"
          },
          "method": "GET",
          "headers": {}
        }
      },
      "canonical_data": {
        "name": "list_github_repository_commit_comments",
        "inputs": {
          "optional": "Page-based pagination can be controlled with 'page' (integer, default 1, must be >= 1) and 'per_page' (integer, default 30, max 100) to limit results per request and iterate through pages. The HTTP Accept header can be set to choose the comment body representation: application/vnd.github-commitcomment.raw+json (includes 'body'), application/vnd.github-commitcomment.text+json (includes 'body_text'), application/vnd.github-commitcomment.html+json (includes 'body_html'), or application/vnd.github-commitcomment.full+json (includes 'body', 'body_text', and 'body_html').",
          "required": [
            "owner: Case-insensitive string identifying the account that owns the repository. Needed to resolve the repository whose commit comments will be listed.",
            "repo: Case-insensitive string naming the repository (without the .git suffix). Required to specify the exact repository whose commit comments are returned."
          ]
        },
        "intent": "Provide a repository-wide listing of commit-level comments on GitHub for analysis, body extraction, or activity auditing, with support for pagination and selectable body representations via media types.",
        "context": "Results are ordered by comment ID ascending. Pagination is page-based using 'page' and 'per_page', starting at page 1; 'per_page' defaults to 30 and is capped at 100. If 'per_page' is set, results are limited to that count per request. Media type negotiation via the HTTP Accept header controls whether 'body', 'body_text', 'body_html', or all are included; default behavior (no specific media type) returns the raw markdown 'body'. Timestamps are in RFC3339 UTC. 'owner' and 'repo' inputs are case-insensitive. This endpoint lists repository-wide commit comments only and does not create, update, or delete comments; it should not be used for issue comments, pull request review comments, or comments for a single commit.",
        "outputs": "An array of commit comment records for the specified repository, ordered by ascending comment ID. Each record includes the comment body fields according to the requested media type: 'body' for raw markdown, 'body_text' for plain text, 'body_html' for HTML, or all three when 'full' is requested. Timestamps in the returned records are in RFC3339 UTC. These comment objects can be consumed by downstream tools that process comment content, ids, or timestamps.",
        "operation": "list commit comments for a repository",
        "preconditions": "A valid repository must be specified by 'owner' and 'repo'. If provided, 'page' must be an integer >= 1 and 'per_page' must be an integer between 1 and 100. If an HTTP Accept header is sent, it must be one of the supported commit comment media types. The GitHub REST API must be reachable.",
        "postconditions": "No server-side state is mutated; this is a read-only retrieval. Upon success, a page of commit comments from the specified repository is returned, ordered by ascending ID and formatted per the selected media type. If pagination parameters limit results, additional calls may be needed to retrieve subsequent pages.",
        "business_objects": [
          "repository",
          "commit comment"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "get_github_repository_content_by_path",
      "description": "Category tool for retrieval in source_control: retrieves the contents of a file or lists a directory in a GitHub repository, returning either raw file data or structured entries, with optional selection by branch/tag/commit (ref); omitting path returns the repository root. Call when you need to fetch a specific file\u2019s content or enumerate a directory at a given ref in a repository. Do not call when you need recursive directory trees, bulk listings beyond 1,000 items, cloning, writing, or files larger than 100 MB; use the Git Trees API for recursive retrieval or other tools for download/clone operations. Requires: owner (string), repo (string without .git), path (UTF-8 slash-delimited relative path from repo root; optional), and optional ref (branch name, tag, or commit SHA); inputs are case-insensitive for owner/repo. Rules: if path is omitted, return root directory; directories yield arrays of entries; symlinks resolve to target file content when the target is a regular file; submodules may appear with type \"file\" for compatibility; for 1\u2013100 MB files only raw/object media types are supported; files >100 MB are unsupported; listings are limited to 1,000 items and are not recursive, and download URLs are short-lived. Keywords: github contents api, repository file fetch, directory listing, source control, ref branch tag, symlink resolution, submodule behavior, non-recursive retrieval.",
      "document": {
        "id": "e130f356-6f8a-4d36-a764-02a12c1770f4",
        "name": "get_github_repository_content_by_path",
        "appName": "apigithubcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Category tool for retrieval in source_control: retrieves the contents of a file or lists a directory in a GitHub repository, returning either raw file data or structured entries, with optional selection by branch/tag/commit (ref); omitting path returns the repository root. Call when you need to fetch a specific file\u2019s content or enumerate a directory at a given ref in a repository. Do not call when you need recursive directory trees, bulk listings beyond 1,000 items, cloning, writing, or files larger than 100 MB; use the Git Trees API for recursive retrieval or other tools for download/clone operations. Requires: owner (string), repo (string without .git), path (UTF-8 slash-delimited relative path from repo root; optional), and optional ref (branch name, tag, or commit SHA); inputs are case-insensitive for owner/repo. Rules: if path is omitted, return root directory; directories yield arrays of entries; symlinks resolve to target file content when the target is a regular file; submodules may appear with type \"file\" for compatibility; for 1\u2013100 MB files only raw/object media types are supported; files >100 MB are unsupported; listings are limited to 1,000 items and are not recursive, and download URLs are short-lived. Keywords: github contents api, repository file fetch, directory listing, source control, ref branch tag, symlink resolution, submodule behavior, non-recursive retrieval.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aint_path": {
              "type": "object",
              "required": [
                "owner",
                "path",
                "repo"
              ],
              "properties": {
                "path": {
                  "type": "string",
                  "description": "path parameter"
                },
                "repo": {
                  "type": "string",
                  "description": "The name of the repository without the `.git` extension. The name is not case sensitive."
                },
                "owner": {
                  "type": "string",
                  "description": "The account owner of the repository. The name is not case sensitive."
                }
              }
            },
            "aint_query": {
              "type": "object",
              "properties": {
                "ref": {
                  "type": "string",
                  "description": "The name of the commit/branch/tag. Default: the repository\u2019s default branch."
                }
              }
            }
          },
          "description": "Gets the contents of a file or directory in a repository. Specify the file path or directory with the `path` parameter. If you omit the `path` parameter, you will receive the contents of the repository's root directory.\n\nThis endpoint supports the following custom media types. For more information, see \"[Media types](https://docs.github.com/enterprise-server@3.18/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).\"\n\n- **`application/vnd.github.raw+json`**: Returns the raw file contents for files and symlinks.\n- **`application/vnd.github.html+json`**: Returns the file contents in HTML. Markup languages are rendered to HTML using GitHub's open-source [Markup library](https://github.com/github/markup).\n- **`application/vnd.github.object+json`**: Returns the contents in a consistent object format regardless of the content type. For example, instead of an array of objects for a directory, the response will be an object with an `entries` attribute containing the array of objects.\n\nIf the content is a directory, the response will be an array of objects, one object for each item in the directory. When listing the contents of a directory, submodules have their \"type\" specified as \"file\". Logically, the value _should_ be \"submodule\". This behavior exists [for backwards compatibility purposes](https://git.io/v1YCW). In the next major version of the API, the type will be returned as \"submodule\".\n\nIf the content is a symlink and the symlink's target is a normal file in the repository, then the API responds with the content of the file. Otherwise, the API responds with an object describing the symlink itself.\n\nIf the content is a submodule, the `submodule_git_url` field identifies the location of the submodule repository, and the `sha` identifies a specific commit within the submodule repository. Git uses the given URL when cloning the submodule repository, and checks out the submodule at that specific commit. If the submodule repository is not hosted on github.com, the Git URLs (`git_url` and `_links[\"git\"]`) and the github.com URLs (`html_url` and `_links[\"html\"]`) will have null values.\n\n**Notes**:\n\n- To get a repository's contents recursively, you can [recursively get the tree](https://docs.github.com/enterprise-server@3.18/rest/git/trees#get-a-tree).\n- This API has an upper limit of 1,000 files for a directory. If you need to retrieve\nmore files, use the [Git Trees API](https://docs.github.com/enterprise-server@3.18/rest/git/trees#get-a-tree).\n- Download URLs expire and are meant to be used just once. To ensure the download URL does not expire, please use the contents API to obtain a fresh download URL for each download.\n- If the requested file's size is:\n  - 1 MB or smaller: All features of this endpoint are supported.\n  - Between 1-100 MB: Only the `raw` or `object` custom media types are supported. Both will work as normal, except that when using the `object` media type, the `content` field will be an empty\nstring and the `encoding` field will be `\"none\"`. To get the contents of these larger files, use the `raw` media type.\n  - Greater than 100 MB: This endpoint is not supported."
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "github",
              "com"
            ],
            "path": [
              "repos",
              "${owner}",
              "${repo}",
              "contents",
              "${path}"
            ],
            "query": {},
            "protocol": "https"
          },
          "method": "GET",
          "headers": {}
        }
      },
      "canonical_data": {
        "name": "get_github_repository_content_by_path",
        "inputs": {
          "optional": "ref: An optional name of a commit SHA, branch, or tag. If omitted, the repository\u2019s default branch is used. No other optional query or path parameters are supported. Media type selection is controlled via the HTTP Accept header (e.g., raw, html, object) rather than an input parameter.",
          "required": [
            "owner: The account owner of the repository (case-insensitive). Required to identify which account namespace the repository belongs to so the correct repository can be located.",
            "repo: The repository name without the .git suffix (case-insensitive). Required to identify the specific repository whose contents will be read.",
            "path: UTF-8, slash-delimited path relative to the repository root that points to either a file or a directory. Required to select the content to fetch (file content) or enumerate (directory listing)."
          ]
        },
        "intent": "Retrieve the contents of a specific file or list the entries of a directory in a GitHub repository at an optional branch/tag/commit reference.",
        "context": "Behavior depends on HTTP media type negotiation: application/vnd.github.raw+json returns raw file contents for files and symlinks; application/vnd.github.html+json returns HTML-rendered content for supported markup; application/vnd.github.object+json returns a consistent JSON object format (including an entries array for directories). Directory listings are non-recursive and limited to 1,000 items; for recursive or larger listings, use the Git Trees API. If path is omitted in the underlying API, the repository root is returned (though this tool\u2019s schema requires path). For files 1\u2013100 MB, only the raw or object media types are supported; with the object media type for these files, content is an empty string and encoding is \"none\"\u2014use the raw media type to obtain actual bytes. Files greater than 100 MB are unsupported. Symlinks resolve to the target file\u2019s content only if the target is a regular file; otherwise a symlink descriptor is returned. Submodules may appear with type \"file\" for backward compatibility; a future API version may return type \"submodule\". If a submodule points to a repository not hosted on github.com, certain URL fields may be null. Download URLs are short-lived and intended for one-time use; obtain fresh URLs as needed. Owner and repo names are case-insensitive. The default ref is the repository\u2019s default branch.",
        "outputs": "Returns either: (1) file content or a file content descriptor; (2) a directory listing; or (3) a symlink/submodule descriptor, depending on the target and requested media type. Specifically: - For files and symlinks, with the raw media type the response is the raw file bytes; with the html media type the response is the file rendered to HTML (for supported markup); with the object media type the response is a JSON object describing the file, including fields such as content (base64 or empty for large files), encoding, size, name, path, sha, url, git_url, html_url, download_url, and _links. - For directories, the response is an array of JSON objects, one per entry (or, with the object media type, a JSON object with an entries array). Each entry includes metadata such as name, path, type (note: submodules may appear as type \"file\" for backward compatibility), sha, and URLs. - For symlinks: if the target is a normal file in the repository, content is returned as for a file; otherwise a JSON object describing the symlink is returned. - For submodules: a JSON object including submodule_git_url and sha identifies the submodule location and pinned commit; when the submodule is not hosted on github.com, git_url/_links[\"git\"] and html_url/_links[\"html\"] can be null. These outputs can serve as inputs to downstream tools that consume raw file blobs, navigate directory structures, or follow URLs and SHAs to other GitHub APIs (e.g., Git Trees).",
        "operation": "Fetch repository content by path at an optional ref",
        "preconditions": "An accessible GitHub repository identified by the provided owner and repo must exist. The specified path must resolve at the chosen ref (or the default branch if ref is omitted) to a file, directory, symlink, or submodule. Files larger than 100 MB are not supported by this endpoint. The API must be reachable, and if a specific ref is given it must be a valid commit SHA, branch, or tag name for the repository.",
        "postconditions": "No server-side state is modified. On success, the caller obtains either the raw file content, an HTML rendering, or JSON metadata/entries describing the requested repository content, including any short-lived download URLs.",
        "business_objects": [
          "repository",
          "file",
          "directory",
          "symlink",
          "submodule"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "upsert_github_repository_file",
      "description": "Category tool for mutation in source control: Creates or replaces a file in a GitHub repository by committing Base64-encoded content to a specified path, returning commit/file metadata for the target branch. Call when you need to create a new file or update an existing file\u2019s contents within a repo and you have the commit message and the complete file bytes encoded as Base64. Do not call when deleting or renaming files, retrieving file contents, or performing parallel file mutations; use dedicated delete/rename/retrieval tools, and avoid concurrent calls that touch the same path. Requires: owner (string), repo (string without .git), path (string), message (string), content (Base64 string of file bytes); sha (string) is required only when updating an existing file; optional branch (string), committer {name (string), email (string), date (RFC3339 timestamp, prefer UTC)}, author {name (string), email (string), date (RFC3339)}; authentication must include repo scope and workflow scope to modify files under .github/workflows. Rules: if sha is provided treat as update, else create; default branch is used when branch is omitted; author defaults to committer or authenticated user if not provided; content must be Base64 with no URL encoding; serialize with delete-file operations to avoid conflicts. Keywords: github repository, file commit, base64 content, upsert file, branch, sha, workflow files, source control.",
      "document": {
        "id": "247f72f8-3581-4f5a-9d78-3959984a4238",
        "name": "upsert_github_repository_file",
        "appName": "apigithubcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Category tool for mutation in source control: Creates or replaces a file in a GitHub repository by committing Base64-encoded content to a specified path, returning commit/file metadata for the target branch. Call when you need to create a new file or update an existing file\u2019s contents within a repo and you have the commit message and the complete file bytes encoded as Base64. Do not call when deleting or renaming files, retrieving file contents, or performing parallel file mutations; use dedicated delete/rename/retrieval tools, and avoid concurrent calls that touch the same path. Requires: owner (string), repo (string without .git), path (string), message (string), content (Base64 string of file bytes); sha (string) is required only when updating an existing file; optional branch (string), committer {name (string), email (string), date (RFC3339 timestamp, prefer UTC)}, author {name (string), email (string), date (RFC3339)}; authentication must include repo scope and workflow scope to modify files under .github/workflows. Rules: if sha is provided treat as update, else create; default branch is used when branch is omitted; author defaults to committer or authenticated user if not provided; content must be Base64 with no URL encoding; serialize with delete-file operations to avoid conflicts. Keywords: github repository, file commit, base64 content, upsert file, branch, sha, workflow files, source control.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_body"
          ],
          "properties": {
            "aint_body": {
              "type": "object",
              "required": [
                "message",
                "content"
              ],
              "properties": {
                "sha": {
                  "type": "string",
                  "description": "**Required if you are updating a file**. The blob SHA of the file being replaced."
                },
                "author": {
                  "type": "object",
                  "required": [
                    "name",
                    "email"
                  ],
                  "properties": {
                    "date": {
                      "type": "string",
                      "example": "\"2013-01-15T17:13:22+05:00\""
                    },
                    "name": {
                      "type": "string",
                      "description": "The name of the author or committer of the commit. You'll receive a `422` status code if `name` is omitted."
                    },
                    "email": {
                      "type": "string",
                      "description": "The email of the author or committer of the commit. You'll receive a `422` status code if `email` is omitted."
                    }
                  },
                  "description": "The author of the file. Default: The `committer` or the authenticated user if you omit `committer`."
                },
                "branch": {
                  "type": "string",
                  "description": "The branch name. Default: the repository\u2019s default branch."
                },
                "content": {
                  "type": "string",
                  "description": "The new file content, using Base64 encoding."
                },
                "message": {
                  "type": "string",
                  "description": "The commit message."
                },
                "committer": {
                  "type": "object",
                  "required": [
                    "name",
                    "email"
                  ],
                  "properties": {
                    "date": {
                      "type": "string",
                      "example": "\"2013-01-05T13:13:22+05:00\""
                    },
                    "name": {
                      "type": "string",
                      "description": "The name of the author or committer of the commit. You'll receive a `422` status code if `name` is omitted."
                    },
                    "email": {
                      "type": "string",
                      "description": "The email of the author or committer of the commit. You'll receive a `422` status code if `email` is omitted."
                    }
                  },
                  "description": "The person that committed the file. Default: the authenticated user."
                }
              }
            },
            "aint_path": {
              "type": "object",
              "required": [
                "owner",
                "path",
                "repo"
              ],
              "properties": {
                "path": {
                  "type": "string",
                  "description": "path parameter"
                },
                "repo": {
                  "type": "string",
                  "description": "The name of the repository without the `.git` extension. The name is not case sensitive."
                },
                "owner": {
                  "type": "string",
                  "description": "The account owner of the repository. The name is not case sensitive."
                }
              }
            }
          },
          "description": "Creates a new file or replaces an existing file in a repository.\n\n> [!NOTE]\n> If you use this endpoint and the \"[Delete a file](https://docs.github.com/enterprise-server@3.18/rest/repos/contents/#delete-a-file)\" endpoint in parallel, the concurrent requests will conflict and you will receive errors. You must use these endpoints serially instead.\n\nOAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint. The `workflow` scope is also required in order to modify files in the `.github/workflows` directory."
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "github",
              "com"
            ],
            "path": [
              "repos",
              "${owner}",
              "${repo}",
              "contents",
              "${path}"
            ],
            "query": {},
            "protocol": "https"
          },
          "method": "PUT",
          "headers": {
            "Content-Type": "application/json"
          }
        }
      },
      "canonical_data": {
        "name": "upsert_github_repository_file",
        "inputs": {
          "optional": "Repository targeting and additional commit metadata are supplied via non-required fields. aint_path may be provided to identify the destination: owner (repository owner), repo (repository name without .git), and path (file path within the repo). Within aint_body, you may also supply: sha to indicate an update of an existing file; branch to select the target branch (default is the repository\u2019s default branch); committer and author objects (each requiring name and email if provided, with optional RFC3339 date) to set Git identity and timestamp; if author is omitted it defaults to the committer or the authenticated user. Content must be Base64-encoded with no URL encoding. Authentication must include repo scope, and workflow scope is additionally required when modifying files under .github/workflows.",
          "required": [
            "aint_body: The commit payload object required to perform the upsert. It must include the commit message and the Base64-encoded file content, and determines whether the operation is a create (no sha) or an update (sha provided). Specifically: message (commit message) and content (file bytes encoded in Base64) are required within this object; sha is required only when updating an existing file."
          ]
        },
        "intent": "Create or replace a file in a GitHub repository by committing provided Base64-encoded content to a specified path, returning metadata about the resulting file and commit on the target branch.",
        "context": "If sha is provided, the operation is treated as an update; otherwise it creates a new file. If branch is omitted, the repository\u2019s default branch is used. If author is omitted, it defaults to the committer or the authenticated user; if committer is omitted, it defaults to the authenticated user. Author and committer dates, when provided, must be RFC3339 timestamps (UTC preferred). The repository name is supplied without the .git suffix; owner and repo are not case sensitive. Do not use this tool for delete, rename, or content retrieval operations; use the dedicated tools for those. Avoid concurrent requests that affect the same path or combine with delete-file calls in parallel, as they will conflict and error.",
        "outputs": "An object containing commit and file metadata for the target branch after the operation. This includes information about the committed file and the associated commit, which can be used downstream (for example, to reference SHAs or commit details in subsequent repository operations).",
        "operation": "upsert a file in a GitHub repository by committing Base64-encoded content",
        "preconditions": "The caller must authenticate with a token that has the repo scope; if the target path is under .github/workflows, the workflow scope is also required. The target repository owner/name and file path must be specified to identify where the change applies. The content must be valid Base64 (not URL-encoded). To update an existing file, the correct current blob SHA of that file must be provided; omit sha to create a new file. Parallel operations that mutate or delete the same path must be avoided; delete and upsert requests must be serialized to prevent conflicts.",
        "postconditions": "On success, a new commit exists on the specified (or default) branch, and the repository contains the new file at the given path or the existing file has been replaced with the provided content. No other repository state is changed.",
        "business_objects": [
          "repository file",
          "commit",
          "repository branch"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "list_github_repository_forks",
      "description": "Retrieval tool for listing repository forks in version control: returns a paginated list of forks for a specified repository, optionally sorted by newest, oldest, stargazers, or watchers, including standard repository metadata for each fork. Call when you need the forks of a known repository and optionally control order and pagination. Do not call when you need to create a fork (use a fork-creation tool), fetch details of a single repository (use a get-repository tool), list branches/tags/stargazers/watchers/issues, or search across repositories. Requires: owner (string, case-insensitive), repo (string, case-insensitive), optional sort in {newest|oldest|stargazers|watchers}, per_page (integer 1\u2013100), page (integer >=1). Rules: defaults are sort=newest, per_page=30, page=1; per_page values above 100 are capped at 100; page is 1-based; owner and repo matching is case-insensitive; no side effects beyond retrieval. Keywords: github forks, repository forks, pagination, sorting by stargazers, version control, developer api, list forks, repo metadata.",
      "document": {
        "id": "b3e5f7d5-3017-48d2-ab56-f761d9598396",
        "name": "list_github_repository_forks",
        "appName": "apigithubcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for listing repository forks in version control: returns a paginated list of forks for a specified repository, optionally sorted by newest, oldest, stargazers, or watchers, including standard repository metadata for each fork. Call when you need the forks of a known repository and optionally control order and pagination. Do not call when you need to create a fork (use a fork-creation tool), fetch details of a single repository (use a get-repository tool), list branches/tags/stargazers/watchers/issues, or search across repositories. Requires: owner (string, case-insensitive), repo (string, case-insensitive), optional sort in {newest|oldest|stargazers|watchers}, per_page (integer 1\u2013100), page (integer >=1). Rules: defaults are sort=newest, per_page=30, page=1; per_page values above 100 are capped at 100; page is 1-based; owner and repo matching is case-insensitive; no side effects beyond retrieval. Keywords: github forks, repository forks, pagination, sorting by stargazers, version control, developer api, list forks, repo metadata.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aint_path": {
              "type": "object",
              "required": [
                "owner",
                "repo"
              ],
              "properties": {
                "repo": {
                  "type": "string",
                  "description": "The name of the repository without the `.git` extension. The name is not case sensitive."
                },
                "owner": {
                  "type": "string",
                  "description": "The account owner of the repository. The name is not case sensitive."
                }
              }
            },
            "aint_query": {
              "type": "object",
              "properties": {
                "page": {
                  "type": "integer",
                  "default": 1,
                  "description": "The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.18/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""
                },
                "sort": {
                  "enum": [
                    "newest",
                    "oldest",
                    "stargazers",
                    "watchers"
                  ],
                  "type": "string",
                  "default": "newest",
                  "description": "The sort order. `stargazers` will sort by star count."
                },
                "per_page": {
                  "type": "integer",
                  "default": 30,
                  "description": "The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.18/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""
                }
              }
            }
          },
          "description": "List forks"
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "github",
              "com"
            ],
            "path": [
              "repos",
              "${owner}",
              "${repo}",
              "forks"
            ],
            "query": {},
            "protocol": "https"
          },
          "method": "GET",
          "headers": {}
        }
      },
      "canonical_data": {
        "name": "list_github_repository_forks",
        "inputs": {
          "optional": "Optional query controls include: sort (one of newest, oldest, stargazers, watchers; default newest, with stargazers sorting by star count), per_page (integer page size, default 30, values above 100 are capped at 100), and page (1-based integer page index, default 1). These options let callers order results and paginate through the fork list.",
          "required": [
            "owner: The account owner of the target repository (user or organization). Required to identify which repository\u2019s forks to list; matching is case-insensitive.",
            "repo: The name of the target repository (without the .git extension). Required to identify which repository\u2019s forks to list; matching is case-insensitive."
          ]
        },
        "intent": "Retrieve a paginated, optionally sorted list of forks for a specified repository, returning standard repository metadata for each fork.",
        "context": "Default behaviors: sort=newest, per_page=30, page=1. Pagination is 1-based; per_page over 100 is capped at 100. Sorting supports newest, oldest, stargazers (by star count), and watchers. Owner and repo matching is case-insensitive. This tool is strictly for retrieval of repository forks (not for creating forks or listing other repository resources).",
        "outputs": "A paginated list (array) of fork repository records containing standard repository metadata for each fork of the specified repository. These records represent individual forked repositories and include identifiers that can be used by other repository-scoped tools.",
        "operation": "List forks for a repository",
        "preconditions": "A repository identified by the provided owner and repo must exist and be accessible. The owner and repo values are matched case-insensitively. If provided, sort must be one of {newest, oldest, stargazers, watchers}. Page must be an integer >= 1. Per_page must be an integer; values above 100 are accepted but will be capped to 100.",
        "postconditions": "Read-only operation with no side effects; after successful execution, the caller has a page of fork repository metadata for the specified repository.",
        "business_objects": [
          "repository",
          "repository fork"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "list_github_issues_pull_requests",
      "description": "Category tool for retrieval in issue tracking: lists paginated comments across issues and pull requests in a repository, with optional sorting by created or updated time and time-based filtering, returning comment metadata and bodies (raw, text, or HTML depending on media type negotiation). Call when you need all issue and pull request comments for a repository or to page through them with sorting and since filtering. Do not call when you need comments for a single issue or pull request, when you intend to create, edit, or delete comments, or when you need commit or review comments; use the appropriate per-item or mutation endpoints instead. Requires owner (string) and repo (string), and optional sort ('created'|'updated'), direction ('asc'|'desc', ignored unless sort is set), since (RFC3339 UTC 'YYYY-MM-DDTHH:MM:SSZ'), per_page (integer 1\u2013100, default 30), and page (integer >=1, default 1). Rules: by default results are ordered by ascending comment ID, includes both issues and PRs because PRs are issues, time inputs must be UTC, this operation is read-only and idempotent, direction is ignored without sort, and per_page values above 100 are capped. Keywords: github api, issue comments, pull request comments, repository, pagination, sorting, RFC3339 timestamp, source control.",
      "document": {
        "id": "626c12e3-9cd4-4e70-bd40-c4d33934c2a6",
        "name": "list_github_issues_pull_requests",
        "appName": "apigithubcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Category tool for retrieval in issue tracking: lists paginated comments across issues and pull requests in a repository, with optional sorting by created or updated time and time-based filtering, returning comment metadata and bodies (raw, text, or HTML depending on media type negotiation). Call when you need all issue and pull request comments for a repository or to page through them with sorting and since filtering. Do not call when you need comments for a single issue or pull request, when you intend to create, edit, or delete comments, or when you need commit or review comments; use the appropriate per-item or mutation endpoints instead. Requires owner (string) and repo (string), and optional sort ('created'|'updated'), direction ('asc'|'desc', ignored unless sort is set), since (RFC3339 UTC 'YYYY-MM-DDTHH:MM:SSZ'), per_page (integer 1\u2013100, default 30), and page (integer >=1, default 1). Rules: by default results are ordered by ascending comment ID, includes both issues and PRs because PRs are issues, time inputs must be UTC, this operation is read-only and idempotent, direction is ignored without sort, and per_page values above 100 are capped. Keywords: github api, issue comments, pull request comments, repository, pagination, sorting, RFC3339 timestamp, source control.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aint_path": {
              "type": "object",
              "required": [
                "owner",
                "repo"
              ],
              "properties": {
                "repo": {
                  "type": "string",
                  "description": "The name of the repository without the `.git` extension. The name is not case sensitive."
                },
                "owner": {
                  "type": "string",
                  "description": "The account owner of the repository. The name is not case sensitive."
                }
              }
            },
            "aint_query": {
              "type": "object",
              "properties": {
                "page": {
                  "type": "integer",
                  "default": 1,
                  "description": "The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.18/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""
                },
                "sort": {
                  "enum": [
                    "created",
                    "updated"
                  ],
                  "type": "string",
                  "default": "created",
                  "description": "The property to sort the results by."
                },
                "since": {
                  "type": "string",
                  "format": "date-time",
                  "description": "Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."
                },
                "per_page": {
                  "type": "integer",
                  "default": 30,
                  "description": "The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.18/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""
                },
                "direction": {
                  "enum": [
                    "asc",
                    "desc"
                  ],
                  "type": "string",
                  "description": "Either `asc` or `desc`. Ignored without the `sort` parameter."
                }
              }
            }
          },
          "description": "You can use the REST API to list comments on issues and pull requests for a repository. Every pull request is an issue, but not every issue is a pull request.\n\nBy default, issue comments are ordered by ascending ID.\n\nThis endpoint supports the following custom media types. For more information, see \"[Media types](https://docs.github.com/enterprise-server@3.18/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types).\"\n\n- **`application/vnd.github.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.\n- **`application/vnd.github.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.\n- **`application/vnd.github.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.\n- **`application/vnd.github.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`."
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "github",
              "com"
            ],
            "path": [
              "repos",
              "${owner}",
              "${repo}",
              "issues",
              "comments"
            ],
            "query": {},
            "protocol": "https"
          },
          "method": "GET",
          "headers": {}
        }
      },
      "canonical_data": {
        "name": "list_github_issues_pull_requests",
        "inputs": {
          "optional": "Pagination and filtering controls may be supplied: page (integer, default 1) selects which result page to fetch; per_page (integer, default 30, capped at 100) controls page size. Results can be sorted by sort='created' or 'updated' (schema default is 'created'), with direction='asc' or 'desc' applied only when sort is provided. since filters to comments last updated after the given UTC timestamp in RFC3339/ISO 8601 format (YYYY-MM-DDTHH:MM:SSZ). Media type negotiation via the HTTP Accept header controls body fields returned: application/vnd.github.raw+json (default) returns body; application/vnd.github.text+json returns body_text; application/vnd.github.html+json returns body_html; application/vnd.github.full+json returns body, body_text, and body_html.",
          "required": [
            "owner: The account owner of the target repository (string, case-insensitive). Required to resolve which repository\u2019s issue and pull request comments to list.",
            "repo: The repository name without the .git suffix (string, case-insensitive). Required to identify the specific repository whose comments will be retrieved."
          ]
        },
        "intent": "Retrieve a paginated list of comments across all issues and pull requests in a specified repository, with optional sorting and time-based filtering, returning comment bodies in the requested representation via media type negotiation.",
        "context": "By default, results are ordered by ascending comment ID. Pull requests are issues, so the listing includes comments from both issues and pull requests. Pagination uses page (default 1) and per_page (default 30, maximum 100 and capped if higher). The sort parameter defaults to 'created' per the schema; direction is ignored without sort. since filters to comments last updated after the given UTC RFC3339/ISO 8601 timestamp (with trailing 'Z'). Media type negotiation via Accept determines which body fields are returned: raw (body), text (body_text), HTML (body_html), or all (body, body_text, body_html). The operation is read-only and idempotent.",
        "outputs": "A paginated array of comment records for issues and pull requests in the specified repository. Each record includes comment metadata and one or more body representations determined by the requested media type: raw markdown (body), text-only (body_text), HTML-rendered (body_html), or all three when the 'full' media type is requested. The returned list reflects any provided sort (created or updated), direction, and since filters, and by default is ordered by ascending comment ID.",
        "operation": "list repository issue and pull request comments",
        "preconditions": "The caller must provide both owner and repo to identify an existing repository. Any provided since timestamp must be a UTC RFC3339/ISO 8601 value in the form YYYY-MM-DDTHH:MM:SSZ. If sort is used, it must be either 'created' or 'updated'; direction, if provided, must be 'asc' or 'desc' and is ignored unless sort is set. page should be an integer >= 1; per_page should be an integer, with values above 100 capped. The API endpoint must be reachable; media type negotiation is based on the Accept header.",
        "postconditions": "This is a read-only, idempotent retrieval. No repository or comment state is modified. Upon success, the client possesses one page of issue and pull request comment data matching the requested filters and sort criteria.",
        "business_objects": [
          "repository",
          "issue comment",
          "pull request comment"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "delete_github_repository_file",
      "description": "Mutation tool for deleting files in source_control repositories: deletes a file at a given path in a repository by creating a commit on a specified branch and returns commit metadata for the deletion. Call when: you need to remove a tracked file from a repository given its current blob sha and record a commit with a message, optionally specifying branch and committer/author. Do not call when: you want to create or update file contents, restore files, or delete repositories; use the repository file create/update tool or repository management tools instead. Requires: owner (string), repo (string), path (string), message (string), sha (hex blob SHA of the target file); optional branch (string, defaults to the repository\u2019s default branch); if author or committer objects are provided they must include name and email; repository owner and name are case-insensitive. Rules: if author is omitted, committer info is used; if committer is omitted, the authenticated user is used; missing name or email with author/committer yields a 422 error; do not run concurrently with file create/update operations\u2014use serial requests; operation applies to the specified branch. Keywords: delete file, repository contents, source control, git commit, blob sha, branch, author committer, github api.",
      "document": {
        "id": "6a450ba3-f66c-40f6-8543-713e4ca8092e",
        "name": "delete_github_repository_file",
        "appName": "apigithubcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Mutation tool for deleting files in source_control repositories: deletes a file at a given path in a repository by creating a commit on a specified branch and returns commit metadata for the deletion. Call when: you need to remove a tracked file from a repository given its current blob sha and record a commit with a message, optionally specifying branch and committer/author. Do not call when: you want to create or update file contents, restore files, or delete repositories; use the repository file create/update tool or repository management tools instead. Requires: owner (string), repo (string), path (string), message (string), sha (hex blob SHA of the target file); optional branch (string, defaults to the repository\u2019s default branch); if author or committer objects are provided they must include name and email; repository owner and name are case-insensitive. Rules: if author is omitted, committer info is used; if committer is omitted, the authenticated user is used; missing name or email with author/committer yields a 422 error; do not run concurrently with file create/update operations\u2014use serial requests; operation applies to the specified branch. Keywords: delete file, repository contents, source control, git commit, blob sha, branch, author committer, github api.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_body"
          ],
          "properties": {
            "aint_body": {
              "type": "object",
              "required": [
                "message",
                "sha"
              ],
              "properties": {
                "sha": {
                  "type": "string",
                  "description": "The blob SHA of the file being deleted."
                },
                "author": {
                  "type": "object",
                  "properties": {
                    "name": {
                      "type": "string",
                      "description": "The name of the author (or committer) of the commit"
                    },
                    "email": {
                      "type": "string",
                      "description": "The email of the author (or committer) of the commit"
                    }
                  },
                  "description": "object containing information about the author."
                },
                "branch": {
                  "type": "string",
                  "description": "The branch name. Default: the repository\u2019s default branch"
                },
                "message": {
                  "type": "string",
                  "description": "The commit message."
                },
                "committer": {
                  "type": "object",
                  "properties": {
                    "name": {
                      "type": "string",
                      "description": "The name of the author (or committer) of the commit"
                    },
                    "email": {
                      "type": "string",
                      "description": "The email of the author (or committer) of the commit"
                    }
                  },
                  "description": "object containing information about the committer."
                }
              }
            },
            "aint_path": {
              "type": "object",
              "required": [
                "owner",
                "path",
                "repo"
              ],
              "properties": {
                "path": {
                  "type": "string",
                  "description": "path parameter"
                },
                "repo": {
                  "type": "string",
                  "description": "The name of the repository without the `.git` extension. The name is not case sensitive."
                },
                "owner": {
                  "type": "string",
                  "description": "The account owner of the repository. The name is not case sensitive."
                }
              }
            }
          },
          "description": "Deletes a file in a repository.\n\nYou can provide an additional `committer` parameter, which is an object containing information about the committer. Or, you can provide an `author` parameter, which is an object containing information about the author.\n\nThe `author` section is optional and is filled in with the `committer` information if omitted. If the `committer` information is omitted, the authenticated user's information is used.\n\nYou must provide values for both `name` and `email`, whether you choose to use `author` or `committer`. Otherwise, you'll receive a `422` status code.\n\n> [!NOTE]\n> If you use this endpoint and the \"[Create or update file contents](https://docs.github.com/enterprise-server@3.18/rest/repos/contents/#create-or-update-file-contents)\" endpoint in parallel, the concurrent requests will conflict and you will receive errors. You must use these endpoints serially instead."
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "github",
              "com"
            ],
            "path": [
              "repos",
              "${owner}",
              "${repo}",
              "contents",
              "${path}"
            ],
            "query": {},
            "protocol": "https"
          },
          "method": "DELETE",
          "headers": {
            "Content-Type": "application/json"
          }
        }
      },
      "canonical_data": {
        "name": "delete_github_repository_file",
        "inputs": {
          "optional": "aint_path may be provided to locate the file to delete and includes owner, repo, and path (these three are required within aint_path if aint_path is supplied); owner and repo are case-insensitive. Within aint_body, you may optionally specify branch to choose the branch on which the deletion commit is made (defaults to the repository\u2019s default branch if omitted). You may also provide author and/or committer objects (each must include both name and email if supplied); if author is omitted, committer information is used; if committer is omitted, the authenticated user\u2019s information is used. Providing author/committer without both name and email results in a 422 error.",
          "required": [
            "aint_body \u2014 The request body object that carries the deletion parameters; it is required to perform the delete-as-commit operation.",
            "aint_body.message \u2014 The commit message for the deletion commit; required because the file removal is recorded as a commit and must have a message.",
            "aint_body.sha \u2014 The hex blob SHA of the current file being deleted; required to target the exact file version and ensure the deletion applies to the intended blob."
          ]
        },
        "intent": "Delete a tracked file from a repository by creating a commit on a specified branch and return metadata about that deletion commit.",
        "context": "The repository owner and name are case-insensitive. If branch is omitted, the repository\u2019s default branch is used. If author is omitted, committer information is used; if committer is omitted, the authenticated user\u2019s information is used. Supplying author or committer without both name and email returns a 422 status. The endpoint must be used serially and not in parallel with the create/update file contents endpoint to avoid conflicts. The deletion is performed via a commit on the specified branch, using the provided blob SHA to target the exact file version.",
        "outputs": "An object containing commit metadata for the deletion commit (i.e., details describing the commit that removed the file). This metadata can be used to reference the commit or pass commit identifiers to other tools that operate on commits.",
        "operation": "delete a repository file via a commit on a specified branch",
        "preconditions": "The target repository and file path must exist, and the provided blob SHA must correspond to the file being deleted. If author or committer objects are provided, each must include both name and email (otherwise a 422 error occurs). This operation should not be run concurrently with create/update file contents requests, as concurrent use will cause conflicts and errors. The operation applies to the specified branch, or the repository\u2019s default branch if branch is not provided.",
        "postconditions": "A new commit is created on the specified (or default) branch that removes the file at the given path, and the tool returns metadata describing that deletion commit. Repository history is updated accordingly; the operation is mutating.",
        "business_objects": [
          "repository file",
          "repository branch",
          "commit"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "create_github_repository_fork",
      "description": "Mutation tool for creating repository forks in source_control: creates a fork of a specified repository for the authenticated user or a target organization and returns metadata for the new fork; inputs include source owner (string), source repo name without .git (string), and optional destination organization (string), new fork name (string), and default_branch_only (boolean) to copy only the default branch. Call when you need to create a fork of an existing repository to make changes or open pull requests under the user account or a specific organization. Do not call when you want to list existing forks, clone or fetch repository contents, create a brand-new empty repository, transfer ownership, or synchronize an existing fork with its upstream. Requires: authenticated context with permission to read the source repository and create repositories in the destination; owner and repo are mandatory strings (case-insensitive), organization/name/default_branch_only are optional. Rules: if organization is provided, the fork is created under that organization; otherwise it is created under the authenticated user; if name is provided it sets the fork\u2019s repository name; default_branch_only=true copies only the default branch; forking is asynchronous and may return 202 Accepted, so the fork\u2019s git objects may be unavailable for several minutes; repeated calls are not idempotent and may fail if a fork with the same name already exists. Keywords: github, repository fork, source control, devops, create repo, organization, default branch, async operation.",
      "document": {
        "id": "c0215c47-214e-4c98-8ac6-e9f4b3724d43",
        "name": "create_github_repository_fork",
        "appName": "apigithubcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Mutation tool for creating repository forks in source_control: creates a fork of a specified repository for the authenticated user or a target organization and returns metadata for the new fork; inputs include source owner (string), source repo name without .git (string), and optional destination organization (string), new fork name (string), and default_branch_only (boolean) to copy only the default branch. Call when you need to create a fork of an existing repository to make changes or open pull requests under the user account or a specific organization. Do not call when you want to list existing forks, clone or fetch repository contents, create a brand-new empty repository, transfer ownership, or synchronize an existing fork with its upstream. Requires: authenticated context with permission to read the source repository and create repositories in the destination; owner and repo are mandatory strings (case-insensitive), organization/name/default_branch_only are optional. Rules: if organization is provided, the fork is created under that organization; otherwise it is created under the authenticated user; if name is provided it sets the fork\u2019s repository name; default_branch_only=true copies only the default branch; forking is asynchronous and may return 202 Accepted, so the fork\u2019s git objects may be unavailable for several minutes; repeated calls are not idempotent and may fail if a fork with the same name already exists. Keywords: github, repository fork, source control, devops, create repo, organization, default branch, async operation.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aint_body": {
              "type": "object",
              "nullable": true,
              "properties": {
                "name": {
                  "type": "string",
                  "description": "When forking from an existing repository, a new name for the fork."
                },
                "organization": {
                  "type": "string",
                  "description": "Optional parameter to specify the organization name if forking into an organization."
                },
                "default_branch_only": {
                  "type": "boolean",
                  "description": "When forking from an existing repository, fork with only the default branch."
                }
              }
            },
            "aint_path": {
              "type": "object",
              "required": [
                "owner",
                "repo"
              ],
              "properties": {
                "repo": {
                  "type": "string",
                  "description": "The name of the repository without the `.git` extension. The name is not case sensitive."
                },
                "owner": {
                  "type": "string",
                  "description": "The account owner of the repository. The name is not case sensitive."
                }
              }
            }
          },
          "description": "Create a fork for the authenticated user.\n\n> [!NOTE]\n> Forking a Repository happens asynchronously. You may have to wait a short period of time before you can access the git objects. If this takes longer than 5 minutes, be sure to contact [GitHub Enterprise Server Support](https://support.github.com/contact?tags=dotcom-rest-api).\n\n> [!NOTE]\n> Although this endpoint works with GitHub Apps, the GitHub App must be installed on the destination account with access to all repositories and on the source account with access to the source repository."
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "github",
              "com"
            ],
            "path": [
              "repos",
              "${owner}",
              "${repo}",
              "forks"
            ],
            "query": {},
            "protocol": "https"
          },
          "method": "POST",
          "headers": {
            "Content-Type": "application/json"
          }
        }
      },
      "canonical_data": {
        "name": "create_github_repository_fork",
        "inputs": {
          "optional": "An optional request body may include: organization (string) to create the fork under a target organization instead of the authenticated user; name (string) to set a custom repository name for the fork; default_branch_only (boolean) to copy only the default branch rather than all branches. If organization is provided, the fork is created under that organization; otherwise it is created under the authenticated user.",
          "required": [
            "owner: Case-insensitive string identifying the account owner of the source repository to fork; required to locate and authorize access to the upstream repository.",
            "repo: Case-insensitive name of the source repository (without the .git extension); required to specify exactly which repository to fork."
          ]
        },
        "intent": "Create a fork of an existing GitHub repository under the authenticated user or a specified organization and return metadata about the new fork.",
        "context": "Forking occurs asynchronously and may return 202 Accepted; the fork\u2019s git objects can be unavailable for several minutes (contact support if longer than 5 minutes). Repository and owner names are case-insensitive, and repo must be provided without the .git extension. If organization is omitted, the fork is created under the authenticated user. If a name is omitted, GitHub applies its default naming for forks. Repeated calls are not idempotent and may fail if a fork with the same name already exists. This tool only creates forks and does not list forks, clone/fetch contents, create an empty repository, transfer ownership, or synchronize an existing fork with its upstream.",
        "outputs": "Repository metadata for the newly created fork. The response represents the forked repository resource (e.g., its identity and configuration) that can be used by other tools to reference or operate on the fork. Forking is asynchronous and may return an acceptance response while the fork\u2019s git objects are still being prepared.",
        "operation": "create a fork of a repository",
        "preconditions": "The caller must be authenticated. The authenticated context must have permission to read the specified source repository and permission to create repositories in the destination account (authenticated user or specified organization). The source repository identified by owner and repo must be accessible. If using a GitHub App, it must be installed on the destination account with access to all repositories and on the source account with access to the source repository.",
        "postconditions": "On success, a new fork repository is created under the authenticated user or the specified organization. If a custom name is provided, the fork uses that name. If default_branch_only is true, only the default branch is initially copied. The operation mutates state by creating a new repository resource; git objects for the fork may take time to become available.",
        "business_objects": [
          "repository",
          "organization"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "list_github_repository_releases",
      "description": "Retrieval tool for listing releases in source control: returns a paginated list of releases for a specific repository, excluding plain Git tags not associated with a release; inputs include owner (string, case-insensitive), repo (string without .git, case-insensitive), per_page (integer 1\u2013100), and page (integer \u22651), and the result is a list of release objects with metadata. Call when: you need to enumerate published and accessible draft releases for a repository, review version history, or paginate through available releases. Do not call when: you need all Git tags (use a repository tags tool), details of a single release, or any operation that creates, updates, or deletes releases. Requires: known repository owner and repo names; optional pagination parameters; appropriate authentication if draft releases should be visible; the repository must exist. Rules: if per_page is omitted default to 30 and cap at 100; if page is omitted default to 1; drafts appear only with push-access credentials; read-only operation with no side effects. Keywords: repository releases, source control, GitHub releases, pagination, draft releases, version history, tags vs releases.",
      "document": {
        "id": "024912f7-4a2a-47ac-b97a-3a7af95410b5",
        "name": "list_github_repository_releases",
        "appName": "apigithubcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for listing releases in source control: returns a paginated list of releases for a specific repository, excluding plain Git tags not associated with a release; inputs include owner (string, case-insensitive), repo (string without .git, case-insensitive), per_page (integer 1\u2013100), and page (integer \u22651), and the result is a list of release objects with metadata. Call when: you need to enumerate published and accessible draft releases for a repository, review version history, or paginate through available releases. Do not call when: you need all Git tags (use a repository tags tool), details of a single release, or any operation that creates, updates, or deletes releases. Requires: known repository owner and repo names; optional pagination parameters; appropriate authentication if draft releases should be visible; the repository must exist. Rules: if per_page is omitted default to 30 and cap at 100; if page is omitted default to 1; drafts appear only with push-access credentials; read-only operation with no side effects. Keywords: repository releases, source control, GitHub releases, pagination, draft releases, version history, tags vs releases.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aint_path": {
              "type": "object",
              "required": [
                "owner",
                "repo"
              ],
              "properties": {
                "repo": {
                  "type": "string",
                  "description": "The name of the repository without the `.git` extension. The name is not case sensitive."
                },
                "owner": {
                  "type": "string",
                  "description": "The account owner of the repository. The name is not case sensitive."
                }
              }
            },
            "aint_query": {
              "type": "object",
              "properties": {
                "page": {
                  "type": "integer",
                  "default": 1,
                  "description": "The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.18/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""
                },
                "per_page": {
                  "type": "integer",
                  "default": 30,
                  "description": "The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.18/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""
                }
              }
            }
          },
          "description": "This returns a list of releases, which does not include regular Git tags that have not been associated with a release. To get a list of Git tags, use the [Repository Tags API](https://docs.github.com/enterprise-server@3.18/rest/repos/repos#list-repository-tags).\n\nInformation about published releases are available to everyone. Only users with push access will receive listings for draft releases."
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "github",
              "com"
            ],
            "path": [
              "repos",
              "${owner}",
              "${repo}",
              "releases"
            ],
            "query": {},
            "protocol": "https"
          },
          "method": "GET",
          "headers": {}
        }
      },
      "canonical_data": {
        "name": "list_github_repository_releases",
        "inputs": {
          "optional": "Pagination controls via query parameters: page (the 1-based page index; defaults to 1) and per_page (number of results per page; defaults to 30 and is capped at 100). These determine which slice of the repository\u2019s release list is returned.",
          "required": [
            "owner: The account owner of the target repository; used to locate the repository whose releases will be listed. The value is case-insensitive and is required to resolve the repository path.",
            "repo: The repository name (without the .git suffix); used with the owner to identify the repository whose releases will be listed. The value is case-insensitive and is required to resolve the repository path."
          ]
        },
        "intent": "Retrieve a paginated list of releases for a specified GitHub repository, excluding plain Git tags that are not associated with a release.",
        "context": "Owner and repo are path parameters and are case-insensitive; the repo name must not include the .git extension. Results are paginated: per_page defaults to 30 (maximum 100), and page defaults to 1. Listings include published releases for everyone and include draft releases only when the caller has push access. Regular Git tags that are not associated with a release are not returned; to list tags, a separate repository tags API/tool must be used. This is a read-only operation with no side effects.",
        "outputs": "An array (paginated) of release objects with metadata for the specified repository. The list contains only releases (published plus any draft releases visible to the caller) and explicitly excludes regular Git tags not tied to a release. Each element represents a GitHub release record that can be consumed by downstream tools expecting release metadata.",
        "operation": "List repository releases",
        "preconditions": "The target repository must exist and be addressable by the provided owner and repo names. Input constraints must be respected (page must be >= 1; per_page must be between 1 and 100, with a default of 30). The API must be accessible. Published releases are always retrievable; viewing draft releases additionally requires credentials with push access to the repository.",
        "postconditions": "Read-only retrieval; no repository or release state is modified. Upon success, a single page of release objects (excluding non-release tags) is returned according to the requested pagination parameters.",
        "business_objects": [
          "repository",
          "release"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "list_github_repositories_for_authenticated_user",
      "description": "Retrieval tool for listing repositories in source control: returns repositories the signed-in user has explicit read, write, or admin access to, with optional filters for visibility, affiliation, type, sort order, pagination, and updated-time windows; outputs a paginated list of repository metadata. Call when: you need to enumerate repositories accessible to the current authenticated user and optionally filter or page through them by visibility, affiliation, type, sort, direction, since, before, per_page, and page. Do not call when: you need repositories for another user, a single repository by name or ID, repository contents, or any create/update/delete operation; use a repository lookup, content retrieval, or mutation tool instead. Requires: an authenticated user context; visibility in {all, public, private}; affiliation as a comma-separated list from {owner, collaborator, organization_member}; type in {all, owner, public, private, member}; sort in {created, updated, pushed, full_name}; direction in {asc, desc}; per_page integer 1\u2013100 (default 30); page integer \u22651 (default 1); since and before timestamps in RFC3339 UTC (YYYY-MM-DDTHH:MM:SSZ). Rules: if type is provided, do not provide visibility or affiliation (422 error); default direction is asc when sort=full_name, otherwise desc; organization_member includes team-access repositories; when both since and before are set, results are constrained to that interval; operation is read-only and idempotent. Keywords: GitHub repositories, authenticated user, source control listing, visibility filters, affiliation, pagination, RFC3339 timestamps, read-only.",
      "document": {
        "id": "4c65d60f-4e06-476d-b247-c9bc8a3fc5ff",
        "name": "list_github_repositories_for_authenticated_user",
        "appName": "apigithubcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for listing repositories in source control: returns repositories the signed-in user has explicit read, write, or admin access to, with optional filters for visibility, affiliation, type, sort order, pagination, and updated-time windows; outputs a paginated list of repository metadata. Call when: you need to enumerate repositories accessible to the current authenticated user and optionally filter or page through them by visibility, affiliation, type, sort, direction, since, before, per_page, and page. Do not call when: you need repositories for another user, a single repository by name or ID, repository contents, or any create/update/delete operation; use a repository lookup, content retrieval, or mutation tool instead. Requires: an authenticated user context; visibility in {all, public, private}; affiliation as a comma-separated list from {owner, collaborator, organization_member}; type in {all, owner, public, private, member}; sort in {created, updated, pushed, full_name}; direction in {asc, desc}; per_page integer 1\u2013100 (default 30); page integer \u22651 (default 1); since and before timestamps in RFC3339 UTC (YYYY-MM-DDTHH:MM:SSZ). Rules: if type is provided, do not provide visibility or affiliation (422 error); default direction is asc when sort=full_name, otherwise desc; organization_member includes team-access repositories; when both since and before are set, results are constrained to that interval; operation is read-only and idempotent. Keywords: GitHub repositories, authenticated user, source control listing, visibility filters, affiliation, pagination, RFC3339 timestamps, read-only.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aint_query": {
              "type": "object",
              "properties": {
                "page": {
                  "type": "integer",
                  "default": 1,
                  "description": "The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.14/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""
                },
                "sort": {
                  "enum": [
                    "created",
                    "updated",
                    "pushed",
                    "full_name"
                  ],
                  "type": "string",
                  "default": "full_name",
                  "description": "The property to sort the results by."
                },
                "type": {
                  "enum": [
                    "all",
                    "owner",
                    "public",
                    "private",
                    "member"
                  ],
                  "type": "string",
                  "default": "all",
                  "description": "Limit results to repositories of the specified type. Will cause a `422` error if used in the same request as **visibility** or **affiliation**."
                },
                "since": {
                  "type": "string",
                  "format": "date-time",
                  "description": "Only show repositories updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."
                },
                "before": {
                  "type": "string",
                  "format": "date-time",
                  "description": "Only show repositories updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`."
                },
                "per_page": {
                  "type": "integer",
                  "default": 30,
                  "description": "The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.14/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""
                },
                "direction": {
                  "enum": [
                    "asc",
                    "desc"
                  ],
                  "type": "string",
                  "description": "The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`."
                },
                "visibility": {
                  "enum": [
                    "all",
                    "public",
                    "private"
                  ],
                  "type": "string",
                  "default": "all",
                  "description": "Limit results to repositories with the specified visibility."
                },
                "affiliation": {
                  "type": "string",
                  "default": "owner,collaborator,organization_member",
                  "description": "Comma-separated list of values. Can include:  \n * `owner`: Repositories that are owned by the authenticated user.  \n * `collaborator`: Repositories that the user has been added to as a collaborator.  \n * `organization_member`: Repositories that the user has access to through being a member of an organization. This includes every repository on every team that the user is on."
                }
              }
            }
          },
          "description": "Lists repositories that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access.\n\nThe authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership."
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "github",
              "com"
            ],
            "path": [
              "user",
              "repos"
            ],
            "query": {},
            "protocol": "https"
          },
          "method": "GET",
          "headers": {}
        }
      },
      "canonical_data": {
        "name": "list_github_repositories_for_authenticated_user",
        "inputs": {
          "optional": "All inputs are provided within the aint_query object to control filtering, sorting, and pagination: visibility (all|public|private) limits by repo visibility; affiliation is a comma-separated list drawn from owner, collaborator, organization_member to constrain by how access is granted; type (all|owner|public|private|member) limits by repo type and must not be used together with visibility or affiliation (otherwise 422 error); sort (created|updated|pushed|full_name) chooses the sorting property; direction (asc|desc) chooses sort order (defaults to asc when sort=full_name, otherwise desc); per_page sets page size (integer 1\u2013100, default 30); page selects which page to return (integer \u22651, default 1); since and before are RFC3339/ISO 8601 UTC timestamps (YYYY-MM-DDTHH:MM:SSZ) to include only repositories updated after/before the given times, and when both are supplied the results are constrained to that interval.",
          "required": "none"
        },
        "intent": "Enumerate repositories that the current authenticated user can access, with optional filtering, sorting, and pagination.",
        "context": "This tool lists repositories for the signed-in user only; it does not return repositories for other users or single repository details. Default behaviors: sort defaults to full_name; direction defaults to asc when sort=full_name, otherwise desc; visibility defaults to all; affiliation defaults to owner,collaborator,organization_member; type defaults to all; per_page defaults to 30 (max 100); page defaults to 1. organization_member includes repositories accessible via team membership. since and before are ISO 8601/RFC3339 UTC timestamps (YYYY-MM-DDTHH:MM:SSZ); when both are supplied, the results are limited to that updated-time interval. Pagination is supported via page and per_page parameters and may require multiple calls to traverse all results. Using type together with visibility or affiliation results in a 422 error. The operation is read-only and idempotent.",
        "outputs": "A paginated list of repository metadata records representing repositories to which the authenticated user has explicit read, write, or admin permission. The list reflects any provided visibility, affiliation or type filters, updated-time window (since/before), and the requested sort and direction. These repository records can be used downstream to reference repositories (e.g., by IDs or names) in other tools that operate on repositories.",
        "operation": "List repositories accessible to the authenticated user",
        "preconditions": "An authenticated user context is required. If the type parameter is provided, visibility and affiliation must not be provided in the same request (else a 422 error). All enumerated parameters must be within allowed sets: visibility in {all, public, private}; affiliation values drawn from {owner, collaborator, organization_member}; type in {all, owner, public, private, member}; sort in {created, updated, pushed, full_name}; direction in {asc, desc}. Pagination values must meet constraints: per_page is an integer between 1 and 100 (default 30) and page is an integer \u22651 (default 1). since and before must be valid RFC3339/ISO 8601 UTC timestamps in the form YYYY-MM-DDTHH:MM:SSZ.",
        "postconditions": "No server-side state is changed; the operation is read-only and idempotent. Upon success, the caller receives one page of repository metadata limited to repositories the authenticated user can explicitly access and constrained by the provided filters and sort options.",
        "business_objects": [
          "repository"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "list_sap_customer_orders",
      "description": "Retrieval tool for listing and filtering customer orders in commerce: Retrieves customer order entities from an OData CustomerOrder collection with support for pagination ($top, $skip), filtering ($filter), sorting ($orderby), field projection ($select), and related entity expansion ($expand), returning matching orders and optionally a total count via $inlinecount. Call when: you need a list of customer orders with optional constraints, projections, related data, or pagination, such as finding recent orders by status, buyer, or date range. Do not call when: you need to create, update, cancel, or approve orders (use mutation tools), or when retrieving a single order by ID (use a single-order retrieval tool). Requires: provide an aint_query object containing any applicable OData V2 parameters where $top and $skip are integers >= 0, $filter is an OData V2 expression (use RFC3339 UTC for datetime literals), $inlinecount is 'allpages' or 'none', $orderby is an array of allowed field tokens (e.g., 'ID' or 'ID desc'), and $select/$expand are arrays of supported property or navigation names. Rules: read-only, no side effects; if $select is set only those properties are returned; if $expand is set related entities are included; if $inlinecount='allpages' the response includes a total record count; when using dates and times prefer UTC; ordering terms must match the allowed enum; server defaults apply when parameters are omitted. Keywords: customer orders, OData v2, pagination, filtering, sorting, select expand, commerce, sales orders.",
      "document": {
        "id": "2943984f-818a-44e0-81d6-6b787c2a1263",
        "name": "list_sap_customer_orders",
        "appName": "sandboxapisapcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for listing and filtering customer orders in commerce: Retrieves customer order entities from an OData CustomerOrder collection with support for pagination ($top, $skip), filtering ($filter), sorting ($orderby), field projection ($select), and related entity expansion ($expand), returning matching orders and optionally a total count via $inlinecount. Call when: you need a list of customer orders with optional constraints, projections, related data, or pagination, such as finding recent orders by status, buyer, or date range. Do not call when: you need to create, update, cancel, or approve orders (use mutation tools), or when retrieving a single order by ID (use a single-order retrieval tool). Requires: provide an aint_query object containing any applicable OData V2 parameters where $top and $skip are integers >= 0, $filter is an OData V2 expression (use RFC3339 UTC for datetime literals), $inlinecount is 'allpages' or 'none', $orderby is an array of allowed field tokens (e.g., 'ID' or 'ID desc'), and $select/$expand are arrays of supported property or navigation names. Rules: read-only, no side effects; if $select is set only those properties are returned; if $expand is set related entities are included; if $inlinecount='allpages' the response includes a total record count; when using dates and times prefer UTC; ordering terms must match the allowed enum; server defaults apply when parameters are omitted. Keywords: customer orders, OData v2, pagination, filtering, sorting, select expand, commerce, sales orders.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aint_query": {
              "type": "object",
              "properties": {
                "$top": {
                  "type": "integer",
                  "minimum": 0,
                  "description": "Show only the first n items, see [URI Conventions (OData Version 2.0)](https://www.odata.org/documentation/odata-version-2-0/uri-conventions/)"
                },
                "$skip": {
                  "type": "integer",
                  "minimum": 0,
                  "description": "Skip the first n items, see [URI Conventions (OData Version 2.0)](https://www.odata.org/documentation/odata-version-2-0/uri-conventions/)"
                },
                "$expand": {
                  "type": "array",
                  "items": {
                    "enum": [
                      "CustomerOrderAttachmentFolder",
                      "CustomerOrderBusinessTransactionDocumentReference",
                      "CustomerOrderCashDiscountTerms",
                      "CustomerOrderExternalPriceComponent",
                      "CustomerOrderItem",
                      "CustomerOrderParty",
                      "CustomerOrderPriceComponent",
                      "CustomerOrderRegisteredProduct",
                      "CustomerOrderTextCollection"
                    ],
                    "type": "string"
                  },
                  "description": "Expand related entities, see [URI Conventions (OData Version 2.0)](https://www.odata.org/documentation/odata-version-2-0/uri-conventions/)",
                  "uniqueItems": true
                },
                "$filter": {
                  "type": "string",
                  "description": "Filter items by property values, see [URI Conventions (OData Version 2.0)](https://www.odata.org/documentation/odata-version-2-0/uri-conventions/)"
                },
                "$select": {
                  "type": "array",
                  "items": {
                    "enum": [
                      "ObjectID",
                      "InformationLifeCycleStatusCode",
                      "InformationLifeCycleStatusCodeText",
                      "ClassificationCode",
                      "ClassificationCodeText",
                      "BuyerID",
                      "FulfilmentBlockingReasonCode",
                      "FulfilmentBlockingReasonCodeText",
                      "ID",
                      "InvoicingBlockingReasonCode",
                      "InvoicingBlockingReasonCodeText",
                      "LastChangeDate",
                      "OrderExternalLifeCycleStatusCode",
                      "OrderExternalLifeCycleStatusCodeText",
                      "Name",
                      "LanguageCode",
                      "LanguageCodeText",
                      "ProcessingTypeCode",
                      "ProcessingTypeCodeText",
                      "ItemListCancellationStatusCode",
                      "ItemListCancellationStatusCodeText",
                      "ItemListFulfilmentProcessingStatusCode",
                      "ItemListFulfilmentProcessingStatusCodeText",
                      "ApprovalStatusCode",
                      "ApprovalStatusCodeText",
                      "ConsistencyStatusCode",
                      "ConsistencyStatusCodeText",
                      "OverallBlockingStatusCode",
                      "OverallBlockingStatusCodeText",
                      "ReplicationProcessingStatusCode",
                      "ReplicationProcessingStatusCodeText",
                      "DistributionChannelCode",
                      "DistributionChannelCodeText",
                      "DivisionCode",
                      "DivisionCodeText",
                      "SalesGroupID",
                      "SalesOfficeID",
                      "SalesOrganisationID",
                      "SalesTerritoryID",
                      "BuyerPartyID",
                      "DeliveryPriorityCode",
                      "DeliveryPriorityCodeText",
                      "TransferLocationName",
                      "EmployeeResponsiblePartyID",
                      "BuyerPartyName",
                      "EmployeeResponsiblePartyName",
                      "BuyerContactPartyID",
                      "BuyerContactPartyName",
                      "CurrencyCode",
                      "CurrencyCodeText",
                      "PriceDateTime",
                      "ProductRecipientPartyID",
                      "ProductRecipientPartyName",
                      "RequestedFulfillmentStartDateTime",
                      "timeZoneCode",
                      "timeZoneCodeText",
                      "CancellationReasonCode",
                      "CancellationReasonCodeText",
                      "SalesUnitPartyID",
                      "CalculationStatusCode",
                      "CalculationStatusCodeText",
                      "ExternalPriceDocumentBaseBusinessTransactionDocumentUUID",
                      "PricingProcedureCode",
                      "PricingProcedureCodeText",
                      "DateTime",
                      "OrderReasonCode",
                      "OrderReasonCodeText",
                      "MaintenanceModeInternalOnlyMainDiscount",
                      "NetAmount",
                      "NetAmountCurrencyCode",
                      "NetAmountCurrencyCodeText",
                      "GrossAmount",
                      "GrossAmountCurrencyCode",
                      "GrossAmountCurrencyCodeText",
                      "TaxAmount",
                      "TaxAmountCurrencyCode",
                      "TaxAmountCurrencyCodeText",
                      "InternalPricingProcedureCode",
                      "InternalPricingProcedureCodeText",
                      "InternalPricingCalculationStatusCode",
                      "InternalPricingCalculationStatusCodeText",
                      "NetWeightMeasure",
                      "NetWeightUnitCode",
                      "NetWeightUnitCodeText",
                      "GrossWeightMeasure",
                      "GrossWeightUnitCode",
                      "GrossWeightUnitCodeText",
                      "VolumeMeasure",
                      "VolumeUnitCode",
                      "VolumeUnitCodeText",
                      "Simulate",
                      "SubmitForApproval",
                      "Transfer",
                      "WithdrawFromApproval",
                      "SetAsCompleted",
                      "PlantPartyID",
                      "PlantPartyName",
                      "CreatedBy",
                      "LastChangedBy",
                      "CreationIdentityUUID",
                      "LastChangeIdentityUUID",
                      "EntityLastChangedOn",
                      "ETag",
                      "CustomerOrderAttachmentFolder",
                      "CustomerOrderBusinessTransactionDocumentReference",
                      "CustomerOrderCashDiscountTerms",
                      "CustomerOrderExternalPriceComponent",
                      "CustomerOrderItem",
                      "CustomerOrderParty",
                      "CustomerOrderPriceComponent",
                      "CustomerOrderRegisteredProduct",
                      "CustomerOrderTextCollection"
                    ],
                    "type": "string"
                  },
                  "description": "Select properties to be returned, see [URI Conventions (OData Version 2.0)](https://www.odata.org/documentation/odata-version-2-0/uri-conventions/)",
                  "uniqueItems": true
                },
                "$orderby": {
                  "type": "array",
                  "items": {
                    "enum": [
                      "ObjectID",
                      "ObjectID desc",
                      "InformationLifeCycleStatusCode",
                      "InformationLifeCycleStatusCode desc",
                      "InformationLifeCycleStatusCodeText",
                      "InformationLifeCycleStatusCodeText desc",
                      "ClassificationCode",
                      "ClassificationCode desc",
                      "ClassificationCodeText",
                      "ClassificationCodeText desc",
                      "BuyerID",
                      "BuyerID desc",
                      "FulfilmentBlockingReasonCode",
                      "FulfilmentBlockingReasonCode desc",
                      "FulfilmentBlockingReasonCodeText",
                      "FulfilmentBlockingReasonCodeText desc",
                      "ID",
                      "ID desc",
                      "InvoicingBlockingReasonCode",
                      "InvoicingBlockingReasonCode desc",
                      "InvoicingBlockingReasonCodeText",
                      "InvoicingBlockingReasonCodeText desc",
                      "LastChangeDate",
                      "LastChangeDate desc",
                      "OrderExternalLifeCycleStatusCode",
                      "OrderExternalLifeCycleStatusCode desc",
                      "OrderExternalLifeCycleStatusCodeText",
                      "OrderExternalLifeCycleStatusCodeText desc",
                      "Name",
                      "Name desc",
                      "LanguageCode",
                      "LanguageCode desc",
                      "LanguageCodeText",
                      "LanguageCodeText desc",
                      "ProcessingTypeCode",
                      "ProcessingTypeCode desc",
                      "ProcessingTypeCodeText",
                      "ProcessingTypeCodeText desc",
                      "ItemListCancellationStatusCode",
                      "ItemListCancellationStatusCode desc",
                      "ItemListCancellationStatusCodeText",
                      "ItemListCancellationStatusCodeText desc",
                      "ItemListFulfilmentProcessingStatusCode",
                      "ItemListFulfilmentProcessingStatusCode desc",
                      "ItemListFulfilmentProcessingStatusCodeText",
                      "ItemListFulfilmentProcessingStatusCodeText desc",
                      "ApprovalStatusCode",
                      "ApprovalStatusCode desc",
                      "ApprovalStatusCodeText",
                      "ApprovalStatusCodeText desc",
                      "ConsistencyStatusCode",
                      "ConsistencyStatusCode desc",
                      "ConsistencyStatusCodeText",
                      "ConsistencyStatusCodeText desc",
                      "OverallBlockingStatusCode",
                      "OverallBlockingStatusCode desc",
                      "OverallBlockingStatusCodeText",
                      "OverallBlockingStatusCodeText desc",
                      "ReplicationProcessingStatusCode",
                      "ReplicationProcessingStatusCode desc",
                      "ReplicationProcessingStatusCodeText",
                      "ReplicationProcessingStatusCodeText desc",
                      "DistributionChannelCode",
                      "DistributionChannelCode desc",
                      "DistributionChannelCodeText",
                      "DistributionChannelCodeText desc",
                      "DivisionCode",
                      "DivisionCode desc",
                      "DivisionCodeText",
                      "DivisionCodeText desc",
                      "SalesGroupID",
                      "SalesGroupID desc",
                      "SalesOfficeID",
                      "SalesOfficeID desc",
                      "SalesOrganisationID",
                      "SalesOrganisationID desc",
                      "SalesTerritoryID",
                      "SalesTerritoryID desc",
                      "BuyerPartyID",
                      "BuyerPartyID desc",
                      "DeliveryPriorityCode",
                      "DeliveryPriorityCode desc",
                      "DeliveryPriorityCodeText",
                      "DeliveryPriorityCodeText desc",
                      "TransferLocationName",
                      "TransferLocationName desc",
                      "EmployeeResponsiblePartyID",
                      "EmployeeResponsiblePartyID desc",
                      "BuyerPartyName",
                      "BuyerPartyName desc",
                      "EmployeeResponsiblePartyName",
                      "EmployeeResponsiblePartyName desc",
                      "BuyerContactPartyID",
                      "BuyerContactPartyID desc",
                      "BuyerContactPartyName",
                      "BuyerContactPartyName desc",
                      "CurrencyCode",
                      "CurrencyCode desc",
                      "CurrencyCodeText",
                      "CurrencyCodeText desc",
                      "PriceDateTime",
                      "PriceDateTime desc",
                      "ProductRecipientPartyID",
                      "ProductRecipientPartyID desc",
                      "ProductRecipientPartyName",
                      "ProductRecipientPartyName desc",
                      "RequestedFulfillmentStartDateTime",
                      "RequestedFulfillmentStartDateTime desc",
                      "timeZoneCode",
                      "timeZoneCode desc",
                      "timeZoneCodeText",
                      "timeZoneCodeText desc",
                      "CancellationReasonCode",
                      "CancellationReasonCode desc",
                      "CancellationReasonCodeText",
                      "CancellationReasonCodeText desc",
                      "SalesUnitPartyID",
                      "SalesUnitPartyID desc",
                      "CalculationStatusCode",
                      "CalculationStatusCode desc",
                      "CalculationStatusCodeText",
                      "CalculationStatusCodeText desc",
                      "ExternalPriceDocumentBaseBusinessTransactionDocumentUUID",
                      "ExternalPriceDocumentBaseBusinessTransactionDocumentUUID desc",
                      "PricingProcedureCode",
                      "PricingProcedureCode desc",
                      "PricingProcedureCodeText",
                      "PricingProcedureCodeText desc",
                      "DateTime",
                      "DateTime desc",
                      "OrderReasonCode",
                      "OrderReasonCode desc",
                      "OrderReasonCodeText",
                      "OrderReasonCodeText desc",
                      "MaintenanceModeInternalOnlyMainDiscount",
                      "MaintenanceModeInternalOnlyMainDiscount desc",
                      "NetAmount",
                      "NetAmount desc",
                      "NetAmountCurrencyCode",
                      "NetAmountCurrencyCode desc",
                      "NetAmountCurrencyCodeText",
                      "NetAmountCurrencyCodeText desc",
                      "GrossAmount",
                      "GrossAmount desc",
                      "GrossAmountCurrencyCode",
                      "GrossAmountCurrencyCode desc",
                      "GrossAmountCurrencyCodeText",
                      "GrossAmountCurrencyCodeText desc",
                      "TaxAmount",
                      "TaxAmount desc",
                      "TaxAmountCurrencyCode",
                      "TaxAmountCurrencyCode desc",
                      "TaxAmountCurrencyCodeText",
                      "TaxAmountCurrencyCodeText desc",
                      "InternalPricingProcedureCode",
                      "InternalPricingProcedureCode desc",
                      "InternalPricingProcedureCodeText",
                      "InternalPricingProcedureCodeText desc",
                      "InternalPricingCalculationStatusCode",
                      "InternalPricingCalculationStatusCode desc",
                      "InternalPricingCalculationStatusCodeText",
                      "InternalPricingCalculationStatusCodeText desc",
                      "NetWeightMeasure",
                      "NetWeightMeasure desc",
                      "NetWeightUnitCode",
                      "NetWeightUnitCode desc",
                      "NetWeightUnitCodeText",
                      "NetWeightUnitCodeText desc",
                      "GrossWeightMeasure",
                      "GrossWeightMeasure desc",
                      "GrossWeightUnitCode",
                      "GrossWeightUnitCode desc",
                      "GrossWeightUnitCodeText",
                      "GrossWeightUnitCodeText desc",
                      "VolumeMeasure",
                      "VolumeMeasure desc",
                      "VolumeUnitCode",
                      "VolumeUnitCode desc",
                      "VolumeUnitCodeText",
                      "VolumeUnitCodeText desc",
                      "Simulate",
                      "Simulate desc",
                      "SubmitForApproval",
                      "SubmitForApproval desc",
                      "Transfer",
                      "Transfer desc",
                      "WithdrawFromApproval",
                      "WithdrawFromApproval desc",
                      "SetAsCompleted",
                      "SetAsCompleted desc",
                      "PlantPartyID",
                      "PlantPartyID desc",
                      "PlantPartyName",
                      "PlantPartyName desc",
                      "CreatedBy",
                      "CreatedBy desc",
                      "LastChangedBy",
                      "LastChangedBy desc",
                      "CreationIdentityUUID",
                      "CreationIdentityUUID desc",
                      "LastChangeIdentityUUID",
                      "LastChangeIdentityUUID desc",
                      "EntityLastChangedOn",
                      "EntityLastChangedOn desc",
                      "ETag",
                      "ETag desc"
                    ],
                    "type": "string"
                  },
                  "description": "Order items by property values, see [URI Conventions (OData Version 2.0)](https://www.odata.org/documentation/odata-version-2-0/uri-conventions/)",
                  "uniqueItems": true
                },
                "$inlinecount": {
                  "enum": [
                    "allpages",
                    "none"
                  ],
                  "type": "string",
                  "description": "Include count of items, see [URI Conventions (OData Version 2.0)](https://www.odata.org/documentation/odata-version-2-0/uri-conventions/)"
                }
              }
            }
          },
          "description": "Get entities from CustomerOrderCollection"
        },
        "staticInput": {
          "url": {
            "host": [
              "sandbox",
              "api",
              "sap",
              "com"
            ],
            "path": [
              "sap",
              "c4c",
              "odata",
              "v1",
              "c4codataapi",
              "CustomerOrderCollection"
            ],
            "query": {},
            "protocol": "https"
          },
          "method": "GET",
          "headers": {}
        }
      },
      "canonical_data": {
        "name": "list_sap_customer_orders",
        "inputs": {
          "optional": "An optional aint_query object that carries OData v2 query parameters: $top and $skip (integers \u2265 0) for pagination; $filter (an OData v2 filter expression, using RFC3339 UTC for datetime literals) for server-side filtering; $orderby (array of allowed field tokens, each optionally with 'desc') for sorting; $select (array of supported property names) for field projection; $expand (array of supported navigation names) to include related entities; and $inlinecount ('allpages' or 'none') to request a total count. Arrays must contain unique items. If parameters are omitted, server defaults apply.",
          "required": "none"
        },
        "intent": "Read-only retrieval of customer orders from an OData v2 CustomerOrder collection with rich query controls for pagination, filtering, sorting, field projection, related-entity expansion, and optional total count.",
        "context": "Implements OData v2 query semantics: pagination via $top/$skip, filtering via $filter, sorting via $orderby, field projection via $select, related-entity inclusion via $expand, and total count via $inlinecount. If $select is set, only those properties are returned; if $expand is set, related entities are included; if $inlinecount='allpages', a total record count is included. Arrays for $select, $expand, and $orderby must have unique items. Date/time literals should use RFC3339 in UTC. When parameters are omitted, server-defined defaults apply. The tool has no side effects.",
        "outputs": "A list of CustomerOrder entities from the CustomerOrderCollection. If $select is provided, only those properties are present on each entity; otherwise server defaults apply. If $expand is provided, specified related entities (e.g., CustomerOrderItem, CustomerOrderParty, etc.) are included inline with each order. If $inlinecount='allpages', the response also includes a total count of matching orders. Returned identifiers and fields (e.g., ID/ObjectID and other properties) can be used by downstream tools that reference or act on specific orders.",
        "operation": "Retrieve customer orders using OData v2 query options",
        "preconditions": "The OData CustomerOrder service must be accessible. Any provided aint_query parameters must meet constraints: $top and $skip are integers \u2265 0; $filter is a valid OData v2 expression with RFC3339 UTC datetimes; $orderby terms must be from the allowed enumeration; $select and $expand values must be from their allowed enumerations and contain unique items; $inlinecount must be 'allpages' or 'none'. This tool is retrieval-only and must not be used for create/update/cancel/approve operations.",
        "postconditions": "No server state is modified; the operation is read-only. On success, matching customer orders are returned (with any requested projections, expansions, and optional total count).",
        "business_objects": [
          "CustomerOrder"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "post_servicenow_records_in_now_table",
      "description": "Create a servicenow record in existing table names, such as   incident \u2014 Contains incident records used for break/fix issues.\nproblem \u2014 Contains problem records used for root cause analysis.\nchange_request \u2014 Used to store change requests, including standard, normal, and emergency changes.\ntask \u2014 The parent table for all task-type records, including incidents, problems, and changes.\nsc_request \u2014 Represents a Service Catalog request (REQ), the container for requested items.\nsc_req_item \u2014 Represents individual Service Catalog request items (RITM) inside a request.\nsc_task \u2014 Tasks associated with catalog request items (e.g., approvals, fulfillment steps).\ncmdb_ci \u2014 The core table for all configuration items in the CMDB.\ncmdb_ci_server \u2014 Stores server CIs (physical, virtual, cloud).\ncmdb_ci_app \u2014 Stores application-related configuration items.\nsys_user \u2014 Stores user accounts and profile data.\nsys_user_group \u2014 Stores group definitions (e.g., support groups, assignment groups).\nsys_choice \u2014 Stores the selectable values (choices) for dropdown fields.\nsys_properties \u2014 Stores system-wide configuration properties.",
      "document": {
        "id": "ff2d5ccb-5a2f-4428-8c5a-14b2f140a84f",
        "auth": null,
        "name": "post_servicenow_records_in_now_table",
        "appName": "dev341424service-nowcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Create a servicenow record in existing table names, such as   incident \u2014 Contains incident records used for break/fix issues.\nproblem \u2014 Contains problem records used for root cause analysis.\nchange_request \u2014 Used to store change requests, including standard, normal, and emergency changes.\ntask \u2014 The parent table for all task-type records, including incidents, problems, and changes.\nsc_request \u2014 Represents a Service Catalog request (REQ), the container for requested items.\nsc_req_item \u2014 Represents individual Service Catalog request items (RITM) inside a request.\nsc_task \u2014 Tasks associated with catalog request items (e.g., approvals, fulfillment steps).\ncmdb_ci \u2014 The core table for all configuration items in the CMDB.\ncmdb_ci_server \u2014 Stores server CIs (physical, virtual, cloud).\ncmdb_ci_app \u2014 Stores application-related configuration items.\nsys_user \u2014 Stores user accounts and profile data.\nsys_user_group \u2014 Stores group definitions (e.g., support groups, assignment groups).\nsys_choice \u2014 Stores the selectable values (choices) for dropdown fields.\nsys_properties \u2014 Stores system-wide configuration properties.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aint_body": {
              "type": "string",
              "description": "application/json content"
            },
            "aint_path": {
              "type": "object",
              "required": [
                "tableName"
              ],
              "properties": {
                "tableName": {
                  "type": "string",
                  "description": ""
                }
              }
            },
            "aint_query": {
              "type": "object",
              "properties": {
                "sysparm_view": {
                  "description": "Render the response according to the specified UI view (overridden by sysparm_fields)"
                },
                "sysparm_fields": {
                  "description": "A comma-separated list of fields to return in the response"
                },
                "sysparm_display_value": {
                  "description": "Return field display values (true), actual values (false), or both (all) (default: false)"
                },
                "sysparm_input_display_value": {
                  "description": "Set field values using their display value (true) or actual value (false) (default: false)"
                },
                "sysparm_exclude_reference_link": {
                  "description": "True to exclude Table API links for reference fields (default: false)"
                },
                "sysparm_suppress_auto_sys_field": {
                  "description": "True to suppress auto generation of system fields (default: false)"
                }
              }
            }
          },
          "description": "Create a record"
        },
        "staticInput": {
          "url": {
            "host": [
              "dev341424",
              "service-now",
              "com"
            ],
            "path": [
              "api",
              "now",
              "table",
              "${tableName}"
            ],
            "query": {},
            "protocol": "https"
          },
          "method": "POST",
          "headers": {
            "Content-Type": "application/json"
          }
        }
      },
      "canonical_data": {
        "name": "post_servicenow_records_in_now_table",
        "inputs": {
          "optional": "A JSON request body (application/json) providing field names and values for the new record; plus query parameters to control behavior and response formatting: choose a UI view for response rendering or explicitly select returned fields; choose whether to return field display values, actual values, or both; choose whether to set input field values by their display values or actual values; choose whether to exclude Table API reference links in the response; and choose whether to suppress auto-generation of system fields during creation.",
          "required": [
            "tableName: The name of the ServiceNow table to create the record in. It selects the target Table API endpoint and determines which fields are valid for the new record."
          ]
        },
        "intent": "Create a new record in a specified ServiceNow table via the Table API.",
        "context": "This is a ServiceNow Table API create operation that supports any existing table (examples include incident, problem, change_request, task, sc_request, sc_req_item, sc_task, cmdb_ci, cmdb_ci_server, cmdb_ci_app, sys_user, sys_user_group, sys_choice, sys_properties). Response rendering can be driven by sysparm_view but is overridden by an explicit sysparm_fields list. Defaults: sysparm_display_value=false (returns actual values), sysparm_input_display_value=false (expects actual values for inputs), sysparm_exclude_reference_link=false (includes reference links), sysparm_suppress_auto_sys_field=false (auto-generates system fields). There is no pagination for this single-record create. The request body is sent as application/json.",
        "outputs": "A JSON representation of the newly created ServiceNow table record. The response can be shaped by the requested view or explicit field list, may return display or actual values per the display-value setting, and may include or exclude reference links as requested. These returned record fields can be used to reference or pass data to subsequent operations that accept record field data.",
        "operation": "create a record in a specified ServiceNow table",
        "preconditions": "The specified tableName must correspond to an existing ServiceNow table. If a body is provided, it must be valid application/json. When setting sysparm_input_display_value=true, provided field values should be the display values recognized by ServiceNow; otherwise actual values should be used.",
        "postconditions": "A new record is created in the specified ServiceNow table with the supplied field values. System fields are auto-generated unless explicitly suppressed. The operation is mutating and returns the created record per the requested response parameters.",
        "business_objects": [
          "ServiceNow table record",
          "ServiceNow table"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "search_arxiv_research_papers",
      "description": "Retrieval tool for querying preprint records in research: searches the arXiv API and returns an Atom XML feed of matching papers given a boolean search_query or a comma-delimited id_list, supporting 0-based start pagination, max_results (<= 30000), and sortBy (relevance|lastUpdatedDate|submittedDate) with sortOrder (ascending|descending), yielding feed entries with paper metadata and links. Call when you need authoritative arXiv search results or to fetch specific papers by known arXiv IDs. Do not call when you need PDFs, full-text retrieval, citation formatting, or results from sources other than arXiv; use a web retrieval, PDF download, or general literature search tool instead. Requires: at least one of search_query (string, e.g., all:electron or ti:\"electron thermal conductivity\") or id_list (comma-delimited arXiv IDs like 2101.00001,2101.00002), optional start (integer, 0-based), max_results (integer 1..30000), sortBy and sortOrder from the allowed sets. Rules: if id_list is provided it takes precedence over search_query and sort options may be ignored, start defaults to 0 and max_results to 10 if omitted, results are read-only with no side effects, and excessive max_results will be capped at 30000. Keywords: arXiv, preprints, scholarly search, Atom feed, research papers, academic metadata, paper retrieval.",
      "document": {
        "id": "2b886890-28b5-43ee-91fb-3d12b9303133",
        "name": "search_arxiv_research_papers",
        "appName": "exportarxivorg",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for querying preprint records in research: searches the arXiv API and returns an Atom XML feed of matching papers given a boolean search_query or a comma-delimited id_list, supporting 0-based start pagination, max_results (<= 30000), and sortBy (relevance|lastUpdatedDate|submittedDate) with sortOrder (ascending|descending), yielding feed entries with paper metadata and links. Call when you need authoritative arXiv search results or to fetch specific papers by known arXiv IDs. Do not call when you need PDFs, full-text retrieval, citation formatting, or results from sources other than arXiv; use a web retrieval, PDF download, or general literature search tool instead. Requires: at least one of search_query (string, e.g., all:electron or ti:\"electron thermal conductivity\") or id_list (comma-delimited arXiv IDs like 2101.00001,2101.00002), optional start (integer, 0-based), max_results (integer 1..30000), sortBy and sortOrder from the allowed sets. Rules: if id_list is provided it takes precedence over search_query and sort options may be ignored, start defaults to 0 and max_results to 10 if omitted, results are read-only with no side effects, and excessive max_results will be capped at 30000. Keywords: arXiv, preprints, scholarly search, Atom feed, research papers, academic metadata, paper retrieval.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_query"
          ],
          "properties": {
            "aint_query": {
              "type": "object",
              "properties": {
                "start": {
                  "type": "integer",
                  "description": "0-based index of first result."
                },
                "sortBy": {
                  "enum": [
                    "relevance",
                    "lastUpdatedDate",
                    "submittedDate"
                  ],
                  "type": "string",
                  "description": "Sort field."
                },
                "id_list": {
                  "type": "string",
                  "description": "Comma-delimited arXiv IDs, e.g., 2101.00001,2101.00002"
                },
                "sortOrder": {
                  "enum": [
                    "ascending",
                    "descending"
                  ],
                  "type": "string",
                  "description": "Sort direction."
                },
                "max_results": {
                  "type": "integer",
                  "description": "Number of results to return (<= 30000)."
                },
                "search_query": {
                  "type": "string",
                  "description": "e.g., all:electron, ti:\"electron thermal conductivity\""
                }
              },
              "description": "Query string parameters for arXiv API.",
              "additionalProperties": false
            }
          },
          "description": "Parameters for arXiv query interface. Provide at least one of search_query or id_list.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "export",
              "arxiv",
              "org"
            ],
            "path": [
              "api",
              "query"
            ],
            "protocol": "https"
          },
          "method": "GET",
          "headers": {
            "Accept": "application/atom+xml"
          }
        }
      },
      "canonical_data": {
        "name": "search_arxiv_research_papers",
        "inputs": {
          "optional": "Within aint_query, all properties are optional at the schema level, but at least one of search_query or id_list must be provided functionally. Optional controls include: search_query for boolean query terms; id_list for comma-delimited arXiv IDs (takes precedence over search and may cause sort options to be ignored); start for 0-based pagination offset; max_results to limit the number returned (defaults apply if omitted and values above 30000 are capped); and sorting via sortBy (relevance, lastUpdatedDate, submittedDate) with sortOrder (ascending, descending).",
          "required": [
            "aint_query: Object containing the arXiv API query parameters used to select which preprint records to retrieve. It must specify the selection via at least one of search_query (a boolean query string) or id_list (a comma-delimited list of arXiv IDs), and may include pagination and sorting controls to determine which records are returned."
          ]
        },
        "intent": "Retrieve arXiv preprint records by search query or explicit arXiv ID list and return them as an Atom XML feed.",
        "context": "Results come exclusively from arXiv and are returned as an Atom feed. Pagination uses a 0-based start offset; defaults are start=0 and max_results=10 if omitted. max_results values above 30000 are capped at 30000. Sorting supports sortBy (relevance, lastUpdatedDate, submittedDate) and sortOrder (ascending, descending). If id_list is provided, it takes precedence over search_query, and sort options may be ignored. Use this tool for authoritative arXiv search or fetching known arXiv IDs; it does not retrieve PDFs, full-text, or citation formats.",
        "outputs": "An Atom XML feed document containing feed entries for each matched arXiv paper. Each entry includes the paper\u2019s metadata and links. The XML can be parsed downstream to extract arXiv IDs and other metadata to drive subsequent tools that accept arXiv identifiers or paper metadata as input.",
        "operation": "Query arXiv and return an Atom XML feed of matching papers",
        "preconditions": "The aint_query object must be provided. Within it, at least one of search_query or id_list must be present. If provided, sortBy must be one of relevance, lastUpdatedDate, or submittedDate; sortOrder must be ascending or descending. start must be an integer (0-based index). max_results must be an integer within 1..30000. The arXiv API must be reachable.",
        "postconditions": "Read-only operation with no side effects; no external state is modified. On success, an Atom XML feed representing the requested slice of arXiv preprint records is returned (subject to any capping of max_results).",
        "business_objects": [
          "arXiv preprint record",
          "arXiv ID",
          "Atom XML feed"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "list_github_public_repositories_by_user",
      "description": "Category tool for retrieval in source control: Retrieves public GitHub repositories for a specified user, returning a paginated list filtered by membership type (all, owner, member) and sorted by created, updated, pushed, or full_name in the requested direction, yielding repository metadata suitable for enumeration. Call when: you need to list a GitHub user's public repositories with optional filtering by ownership/membership, sorting, and pagination. Do not call when: you need private repositories, organization-wide repositories, repository details (README, topics, branches), or file contents; use tools for private/org listing or repository detail/content retrieval instead. Requires: username as the GitHub login string; type in {all, owner, member}; sort in {created, updated, pushed, full_name}; direction in {asc, desc}; per_page as integer 1\u2013100; page as integer \u22651. Rules: if sort=full_name and direction is omitted, default asc; otherwise default desc; if type is omitted, default owner; per_page above 100 is capped; only public repositories are returned; pagination uses page and per_page; read-only and idempotent. Keywords: github user repos, list public repositories, source control retrieval, pagination and sorting, repository metadata, developer api.",
      "document": {
        "id": "895e2677-a55f-4593-ade3-3bf056d1deb4",
        "name": "list_github_public_repositories_by_user",
        "appName": "apigithubcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Category tool for retrieval in source control: Retrieves public GitHub repositories for a specified user, returning a paginated list filtered by membership type (all, owner, member) and sorted by created, updated, pushed, or full_name in the requested direction, yielding repository metadata suitable for enumeration. Call when: you need to list a GitHub user's public repositories with optional filtering by ownership/membership, sorting, and pagination. Do not call when: you need private repositories, organization-wide repositories, repository details (README, topics, branches), or file contents; use tools for private/org listing or repository detail/content retrieval instead. Requires: username as the GitHub login string; type in {all, owner, member}; sort in {created, updated, pushed, full_name}; direction in {asc, desc}; per_page as integer 1\u2013100; page as integer \u22651. Rules: if sort=full_name and direction is omitted, default asc; otherwise default desc; if type is omitted, default owner; per_page above 100 is capped; only public repositories are returned; pagination uses page and per_page; read-only and idempotent. Keywords: github user repos, list public repositories, source control retrieval, pagination and sorting, repository metadata, developer api.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aint_path": {
              "type": "object",
              "required": [
                "username"
              ],
              "properties": {
                "username": {
                  "type": "string",
                  "description": "The handle for the GitHub user account."
                }
              }
            },
            "aint_query": {
              "type": "object",
              "properties": {
                "page": {
                  "type": "integer",
                  "default": 1,
                  "description": "The page number of the results to fetch. For more information, see \"[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.14/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""
                },
                "sort": {
                  "enum": [
                    "created",
                    "updated",
                    "pushed",
                    "full_name"
                  ],
                  "type": "string",
                  "default": "full_name",
                  "description": "The property to sort the results by."
                },
                "type": {
                  "enum": [
                    "all",
                    "owner",
                    "member"
                  ],
                  "type": "string",
                  "default": "owner",
                  "description": "Limit results to repositories of the specified type."
                },
                "per_page": {
                  "type": "integer",
                  "default": 30,
                  "description": "The number of results per page (max 100). For more information, see \"[Using pagination in the REST API](https://docs.github.com/enterprise-server@3.14/rest/using-the-rest-api/using-pagination-in-the-rest-api).\""
                },
                "direction": {
                  "enum": [
                    "asc",
                    "desc"
                  ],
                  "type": "string",
                  "description": "The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`."
                }
              }
            }
          },
          "description": "Lists public repositories for the specified user."
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "github",
              "com"
            ],
            "path": [
              "users",
              "${username}",
              "repos"
            ],
            "query": {},
            "protocol": "https"
          },
          "method": "GET",
          "headers": {}
        }
      },
      "canonical_data": {
        "name": "list_github_public_repositories_by_user",
        "inputs": {
          "optional": "Query parameters allow controlling result scope and ordering: filter by repository membership type (all, owner, member), choose sort key (created, updated, pushed, or full_name), set sort direction (asc or desc with defaults depending on sort key), and paginate via page (>=1) and per_page (1\u2013100, capped at 100). Defaults: type=owner, sort=full_name, direction=asc when sort=full_name otherwise desc, page=1, per_page=30.",
          "required": [
            "username: The GitHub login of the target user whose public repositories will be listed; required as the path identifier to select which user's repositories to fetch."
          ]
        },
        "intent": "Provide a paginated, optionally filtered and sorted listing of a specified GitHub user's public repositories for enumeration purposes.",
        "context": "Results are limited to public repositories. Pagination is controlled via page and per_page, with per_page capped at 100; default page=1 and per_page=30. Sorting defaults to full_name; direction defaults to asc when sort=full_name and desc otherwise. If type is omitted, only repositories owned by the user are listed (type=owner). The tool is designed for repository enumeration and does not return private repos or detailed repository contents.",
        "outputs": "A paginated array of public repository metadata objects for the specified user, filtered by the requested membership type and ordered by the selected sort key and direction. Each object represents a single public GitHub repository and its associated metadata suitable for enumeration and downstream repository-focused operations.",
        "operation": "Retrieve a paginated list of a user's public GitHub repositories",
        "preconditions": "The provided username must correspond to a GitHub user; only public repositories are retrievable. Input values must conform to allowed enums and ranges: type in {all, owner, member}, sort in {created, updated, pushed, full_name}, direction in {asc, desc}, per_page between 1 and 100 (values above 100 are capped), and page as an integer >= 1.",
        "postconditions": "The operation is read-only and idempotent; no server-side state is changed. After successful execution, a deterministic, paginated list of the user's public repositories matching the input filters and sort criteria is returned.",
        "business_objects": [
          "GitHub user account",
          "Public GitHub repository"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "search_sec_filings",
      "description": "Category tool for retrieval in finance: searches SEC EDGAR filings and exhibits since 2001 by keywords, phrases, wildcards, and Boolean operators, returning up to 100 filing metadata records per page with optional filters for CIKs, form types, and a yyyy-mm-dd date range. Call when: you need to locate SEC filings across issuers or time by text query and optional CIK, form type, and startDate/endDate filters, and retrieve paginated metadata for downstream selection. Do not call when: you already know a specific filing identifier (e.g., accession number), need to download or summarize filing documents, or need non-SEC sources; use a dedicated filing retrieval or content tool instead. Requires: query (string, non-empty); optional ciks (array of CIK strings, leading zeros optional), formTypes (array of EDGAR form type codes), startDate and endDate (yyyy-mm-dd, UTC date), page (decimal string for 1-based pagination). Rules: search is case-insensitive; defaults to startDate=30 days ago, endDate=today, and page=1 if omitted; startDate must be on or before endDate; each page returns up to 100 results; supports quoted phrases, wildcards (*), OR, NOT, and exclusions (-). Keywords: SEC EDGAR, filings search, CIK filter, form types, boolean query, financial disclosures, regulatory filings, metadata pagination.",
      "document": {
        "id": "5b5d0d19-3d24-42bb-ad90-45b5f3292595",
        "name": "search_sec_filings",
        "appName": "apisec-apiio",
        "tool_type": "general",
        "transport": "http",
        "description": "Category tool for retrieval in finance: searches SEC EDGAR filings and exhibits since 2001 by keywords, phrases, wildcards, and Boolean operators, returning up to 100 filing metadata records per page with optional filters for CIKs, form types, and a yyyy-mm-dd date range. Call when: you need to locate SEC filings across issuers or time by text query and optional CIK, form type, and startDate/endDate filters, and retrieve paginated metadata for downstream selection. Do not call when: you already know a specific filing identifier (e.g., accession number), need to download or summarize filing documents, or need non-SEC sources; use a dedicated filing retrieval or content tool instead. Requires: query (string, non-empty); optional ciks (array of CIK strings, leading zeros optional), formTypes (array of EDGAR form type codes), startDate and endDate (yyyy-mm-dd, UTC date), page (decimal string for 1-based pagination). Rules: search is case-insensitive; defaults to startDate=30 days ago, endDate=today, and page=1 if omitted; startDate must be on or before endDate; each page returns up to 100 results; supports quoted phrases, wildcards (*), OR, NOT, and exclusions (-). Keywords: SEC EDGAR, filings search, CIK filter, form types, boolean query, financial disclosures, regulatory filings, metadata pagination.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_body"
          ],
          "properties": {
            "aint_body": {
              "type": "object",
              "required": [
                "query"
              ],
              "properties": {
                "ciks": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Filter by specific CIKs. Leading zeros optional."
                },
                "page": {
                  "type": "string",
                  "description": "Pagination page number (each page returns up to 100 filings). Default: 1."
                },
                "query": {
                  "type": "string",
                  "description": "Case-insensitive search term(s) or exact phrase(s). Supports wildcards (*), OR, NOT, exclusions (-), and quoted phrases."
                },
                "endDate": {
                  "type": "string",
                  "description": "End of filing date range (yyyy-mm-dd). Default: today."
                },
                "formTypes": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Restrict to specific EDGAR form types (e.g., 8-K, 10-Q, 10-K)."
                },
                "startDate": {
                  "type": "string",
                  "description": "Start of filing date range (yyyy-mm-dd). Default: 30 days ago."
                }
              },
              "description": "JSON payload for the full-text search.",
              "additionalProperties": false
            }
          },
          "description": "Dynamic inputs for SEC Filing Full-Text Search POST body.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "sec-api",
              "io"
            ],
            "path": [
              "full-text-search"
            ],
            "protocol": "https"
          },
          "method": "POST",
          "headers": {
            "Content-Type": "application/json",
            "Authorization": "$Authorization"
          }
        }
      },
      "canonical_data": {
        "name": "search_sec_filings",
        "inputs": {
          "optional": "Within aint_body, the following fields may refine the search and control pagination: ciks (array of CIK strings, leading zeros optional) to restrict by specific issuers; formTypes (array of EDGAR form type codes, e.g., 8-K, 10-Q, 10-K) to limit results by filing type; startDate and endDate (yyyy-mm-dd, UTC) to bound the filing date range, with the constraint that startDate must be on or before endDate; page (decimal string, 1-based) to request a specific results page. Defaults apply when omitted: startDate=30 days ago, endDate=today, page=1. No additional properties beyond these are accepted.",
          "required": [
            {
              "name": "aint_body",
              "description": "JSON POST body that encapsulates all search criteria for the full-text filing search; it is required as the container for the query and optional filters."
            },
            {
              "name": "aint_body.query",
              "description": "Non-empty case-insensitive full-text query string that drives the search over filings and exhibits; supports quoted phrases, wildcards (*), Boolean operators (OR, NOT), and exclusions (-), and is necessary to identify which filings should be returned."
            }
          ]
        },
        "intent": "Locate SEC EDGAR filings by full\u2011text search with optional issuer, form type, date range, and pagination filters, returning paginated filing metadata for downstream selection.",
        "context": "Search is case-insensitive and supports quoted phrases, wildcards (*), Boolean operators OR and NOT, and exclusions with a leading minus (-). Pagination is 1-based and each page returns up to 100 results. Defaults: startDate=30 days ago, endDate=today, page=1. Date parameters use yyyy-mm-dd in UTC. CIK filters accept strings with optional leading zeros. Results are limited to SEC EDGAR filings and exhibits since 2001. The input schema is strict (additionalProperties=false). This tool returns metadata only (not filing documents) and is intended for discovery and downstream selection rather than direct document retrieval.",
        "outputs": "A paginated set (up to 100 per page) of filing metadata records matching the query and any provided filters; each record represents an SEC EDGAR filing and can be used to select specific filings for downstream tools that retrieve or process filing contents.",
        "operation": "perform full-text search over SEC EDGAR filings (and exhibits) and return paginated filing metadata",
        "preconditions": "The request must include a non-empty aint_body.query string. If provided, startDate and endDate must be valid UTC dates in yyyy-mm-dd format with startDate on or before endDate. If provided, page must be a 1-based decimal string. CIK filters must be strings (leading zeros optional). The API must be accessible, and the request body must adhere to the defined schema (no additional properties). The searchable corpus covers filings and exhibits from 2001 onward.",
        "postconditions": "Read-only operation; no server-side or filing state is modified. Upon success, a page of filing metadata matching the criteria is returned.",
        "business_objects": [
          "SEC EDGAR filing",
          "filing metadata",
          "filing exhibit"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "retrieve_equity_bars_intraday",
      "description": "Retrieval tool for OHLCV time series in finance: Retrieves intraday open-high-low-close-volume bars for a specified equity ticker at a chosen interval, returning JSON or CSV with timestamps and price/volume fields; options include split/dividend-adjusted prices, inclusion of extended hours, output size, and historical month selection. Call when: you need intraday OHLCV bars for a stock symbol at 1min, 5min, 15min, 30min, or 60min resolution, including optional pre/post-market data or adjusted prices. Do not call when: you require real-time quotes, end-of-day aggregates (daily/weekly/monthly), fundamentals, or instruments other than equities; use a quote or daily time series retrieval tool instead. Requires: symbol as a ticker string (e.g., IBM), interval in {'1min','5min','15min','30min','60min'}, optional month formatted as YYYY-MM, adjusted and extended_hours as string literals 'true' or 'false', outputsize in {'compact','full'}, and datatype in {'json','csv'}; provider credentials are assumed to be configured. Rules: prefer datatype='json' for structured parsing; timestamps are provider-supplied and may be exchange-local rather than RFC3339 UTC; when adjusted='true', prices reflect corporate actions; when extended_hours='true', pre/post-market bars are included where supported; if month is provided, results are constrained to that month, while outputsize controls depth when month is omitted; calls are read-only and idempotent. Keywords: intraday ohlcv, stock bars, alpha vantage, finance data api, adjusted prices, extended hours, time series, ticker symbol.",
      "document": {
        "id": "2d50d459-77d9-407b-aff0-f09a572c0322",
        "name": "retrieve_equity_bars_intraday",
        "appName": "wwwalphavantageco",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for OHLCV time series in finance: Retrieves intraday open-high-low-close-volume bars for a specified equity ticker at a chosen interval, returning JSON or CSV with timestamps and price/volume fields; options include split/dividend-adjusted prices, inclusion of extended hours, output size, and historical month selection. Call when: you need intraday OHLCV bars for a stock symbol at 1min, 5min, 15min, 30min, or 60min resolution, including optional pre/post-market data or adjusted prices. Do not call when: you require real-time quotes, end-of-day aggregates (daily/weekly/monthly), fundamentals, or instruments other than equities; use a quote or daily time series retrieval tool instead. Requires: symbol as a ticker string (e.g., IBM), interval in {'1min','5min','15min','30min','60min'}, optional month formatted as YYYY-MM, adjusted and extended_hours as string literals 'true' or 'false', outputsize in {'compact','full'}, and datatype in {'json','csv'}; provider credentials are assumed to be configured. Rules: prefer datatype='json' for structured parsing; timestamps are provider-supplied and may be exchange-local rather than RFC3339 UTC; when adjusted='true', prices reflect corporate actions; when extended_hours='true', pre/post-market bars are included where supported; if month is provided, results are constrained to that month, while outputsize controls depth when month is omitted; calls are read-only and idempotent. Keywords: intraday ohlcv, stock bars, alpha vantage, finance data api, adjusted prices, extended hours, time series, ticker symbol.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_query"
          ],
          "properties": {
            "aint_query": {
              "type": "object",
              "required": [
                "symbol",
                "interval"
              ],
              "properties": {
                "month": {
                  "type": "string",
                  "pattern": "^\\d{4}-\\d{2}$",
                  "description": "Specific month in history, format YYYY-MM."
                },
                "symbol": {
                  "type": "string",
                  "description": "Ticker symbol (e.g., IBM)."
                },
                "adjusted": {
                  "enum": [
                    "true",
                    "false"
                  ],
                  "type": "string",
                  "description": "Return split/dividend-adjusted data."
                },
                "datatype": {
                  "enum": [
                    "json",
                    "csv"
                  ],
                  "type": "string",
                  "description": "Response format."
                },
                "interval": {
                  "enum": [
                    "1min",
                    "5min",
                    "15min",
                    "30min",
                    "60min"
                  ],
                  "type": "string",
                  "description": "Time interval between points."
                },
                "outputsize": {
                  "enum": [
                    "compact",
                    "full"
                  ],
                  "type": "string",
                  "description": "Data size returned."
                },
                "extended_hours": {
                  "enum": [
                    "true",
                    "false"
                  ],
                  "type": "string",
                  "description": "Include pre/post-market hours."
                }
              },
              "additionalProperties": false
            }
          },
          "description": "Dynamic inputs for TIME_SERIES_INTRADAY.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "www",
              "alphavantage",
              "co"
            ],
            "path": [
              "query"
            ],
            "query": {
              "apikey": "$apikey",
              "function": "TIME_SERIES_INTRADAY"
            },
            "protocol": "https"
          },
          "method": "GET"
        }
      },
      "canonical_data": {
        "name": "retrieve_equity_bars_intraday",
        "inputs": {
          "optional": "Within aint_query, you may provide: month (YYYY-MM) to constrain results to a specific historical month; adjusted ('true'|'false') to return split/dividend-adjusted prices; extended_hours ('true'|'false') to include pre/post-market bars where supported; outputsize ('compact'|'full') to control the number of bars returned when month is not specified; datatype ('json'|'csv') to select the response format (JSON preferred for structured parsing).",
          "required": [
            "aint_query: Container object for the query parameters; must be provided to supply the required fields that define which equity and interval to retrieve.",
            "aint_query.symbol: The equity\u2019s ticker symbol (e.g., IBM); specifies the instrument whose intraday bars are to be retrieved.",
            "aint_query.interval: The intraday resolution of the bars; one of {'1min','5min','15min','30min','60min'}; determines the time spacing between returned OHLCV bars."
          ]
        },
        "intent": "Fetch intraday open-high-low-close-volume (OHLCV) bar data for a specified equity ticker at a chosen minute-based interval, with options to adjust for corporate actions, include extended hours, filter by month, control output depth, and select JSON or CSV format.",
        "context": "The tool targets intraday OHLCV retrieval, not real-time quotes or end-of-day aggregates. Timestamps are provider-supplied and may be exchange-local rather than RFC3339 UTC. Prefer datatype='json' for structured parsing. When 'adjusted'='true', prices incorporate corporate actions; when 'extended_hours'='true', pre/post-market bars are included where available. Supplying 'month' limits results to that calendar month; when 'month' is omitted, 'outputsize' determines how many bars are returned. Calls are read-only and idempotent.",
        "outputs": "JSON or CSV containing a time series of intraday bars for the requested equity and interval, with provider-supplied timestamps and per-bar fields for open, high, low, close, and volume. When 'adjusted'='true', price fields reflect corporate actions; when 'extended_hours'='true', pre/post-market bars are included where supported. If 'month' is provided, results are limited to that month; otherwise 'outputsize' governs how many bars are returned. These bar records can be consumed by downstream tools that accept timestamped OHLCV data.",
        "operation": "Retrieve intraday OHLCV time series for an equity symbol at a specified interval",
        "preconditions": "Provider credentials must be configured and the API must be accessible. The request must include a valid aint_query object with 'symbol' set to an equity ticker and 'interval' set to one of {'1min','5min','15min','30min','60min'}. If 'month' is provided, it must match the YYYY-MM pattern. Optional flags must use the defined enums: 'datatype' in {'json','csv'}, 'adjusted' and 'extended_hours' in {'true','false'}, and 'outputsize' in {'compact','full'}. The tool is intended for equities and intraday bars only.",
        "postconditions": "No system state is modified; the operation is read-only and idempotent. On success, intraday OHLCV bar data is returned according to the specified parameters (format, adjustment, extended hours inclusion, month filter or output size).",
        "business_objects": [
          "equity ticker symbol",
          "intraday OHLCV bar"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "retrieve_equity_ohlcv_daily",
      "description": "Retrieval tool for daily OHLCV time series in finance: returns raw, unadjusted, date-indexed open, high, low, close, and volume bars for a single equity ticker, with optional output size (compact for recent subset, full for full history) and output format (json or csv). Call when: you need historical daily bar data for a publicly traded stock by ticker symbol for charting, analysis, or backtesting. Do not call when: you need intraday/weekly/monthly intervals, adjusted series with dividends/splits, fundamentals, quotes, or data for crypto/forex; use a different market data tool for those. Requires: symbol as a ticker string (e.g., IBM); optional outputsize in {'compact','full'} and datatype in {'json','csv'}; dates are YYYY-MM-DD. Rules: defaults are datatype=json and outputsize=compact; response is read-only and idempotent; if datatype=csv expect a comma-separated text payload, otherwise JSON; no date range filtering or multi-symbol input is supported. Keywords: alpha vantage, daily ohlcv, equity time series, stock prices, historical market data, json, csv.",
      "document": {
        "id": "df844fb9-60ec-4640-baa0-889dbc3c97c9",
        "name": "retrieve_equity_ohlcv_daily",
        "appName": "wwwalphavantageco",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for daily OHLCV time series in finance: returns raw, unadjusted, date-indexed open, high, low, close, and volume bars for a single equity ticker, with optional output size (compact for recent subset, full for full history) and output format (json or csv). Call when: you need historical daily bar data for a publicly traded stock by ticker symbol for charting, analysis, or backtesting. Do not call when: you need intraday/weekly/monthly intervals, adjusted series with dividends/splits, fundamentals, quotes, or data for crypto/forex; use a different market data tool for those. Requires: symbol as a ticker string (e.g., IBM); optional outputsize in {'compact','full'} and datatype in {'json','csv'}; dates are YYYY-MM-DD. Rules: defaults are datatype=json and outputsize=compact; response is read-only and idempotent; if datatype=csv expect a comma-separated text payload, otherwise JSON; no date range filtering or multi-symbol input is supported. Keywords: alpha vantage, daily ohlcv, equity time series, stock prices, historical market data, json, csv.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_query"
          ],
          "properties": {
            "aint_query": {
              "type": "object",
              "required": [
                "symbol"
              ],
              "properties": {
                "symbol": {
                  "type": "string",
                  "description": "Ticker symbol (e.g., IBM)."
                },
                "datatype": {
                  "enum": [
                    "json",
                    "csv"
                  ],
                  "type": "string",
                  "description": "Response format."
                },
                "outputsize": {
                  "enum": [
                    "compact",
                    "full"
                  ],
                  "type": "string",
                  "description": "Data size returned."
                }
              },
              "additionalProperties": false
            }
          },
          "description": "Dynamic inputs for TIME_SERIES_DAILY.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "www",
              "alphavantage",
              "co"
            ],
            "path": [
              "query"
            ],
            "query": {
              "apikey": "$apikey",
              "function": "TIME_SERIES_DAILY"
            },
            "protocol": "https"
          },
          "method": "GET"
        }
      },
      "canonical_data": {
        "name": "retrieve_equity_ohlcv_daily",
        "inputs": {
          "optional": "Within aint_query, you may specify datatype ('json' or 'csv') to choose the response media type and outputsize ('compact' for a recent subset or 'full' for full history). If omitted, defaults are datatype=json and outputsize=compact. No other parameters are accepted (additionalProperties=false). There is no date range filtering or multi-symbol input; the series dates are in YYYY-MM-DD.",
          "required": [
            "aint_query (object): Container for all query parameters; required to provide the instrument identifier and optional retrieval/format controls. Must conform to the defined schema with no additional properties.",
            "aint_query.symbol (string): The stock ticker (e.g., \"IBM\"); required to identify the single equity whose daily OHLCV series will be retrieved."
          ]
        },
        "intent": "Fetch unadjusted daily OHLCV price/volume history for a single publicly traded equity by ticker, with selectable output size and format.",
        "context": "Defaults are datatype=json and outputsize=compact. 'compact' returns a recent subset; 'full' returns full historical daily data. The series is unadjusted (no dividend/split adjustments) and date keys use YYYY-MM-DD. Only a single symbol is supported per call; there is no date range filtering. The response is idempotent. If datatype=csv, expect a plain comma-separated text payload; otherwise a JSON structure. This corresponds to the TIME_SERIES_DAILY endpoint behavior.",
        "outputs": "Either a JSON payload or a CSV text payload (depending on 'datatype') containing a date-indexed daily time series of raw, unadjusted OHLCV bars (open, high, low, close, volume) for the requested single equity. The JSON form represents a date-keyed collection of bars; the CSV form is comma-separated rows with the same fields. The data can be consumed by downstream tools that require daily OHLCV bars keyed by date for a single ticker.",
        "operation": "retrieve raw, unadjusted daily OHLCV time series for a single equity ticker",
        "preconditions": "A valid single equity ticker symbol must be provided in aint_query.symbol. If provided, aint_query.datatype must be one of {'json','csv'} and aint_query.outputsize must be one of {'compact','full'}. Inputs must contain only the defined fields (no additional properties). The request must target daily equity data (not intraday/weekly/monthly, not adjusted series, and not crypto/forex).",
        "postconditions": "Read-only retrieval; no system or data mutation occurs. On success, the caller receives the requested daily OHLCV series for the specified equity in the chosen format and size.",
        "business_objects": [
          "equity ticker",
          "daily OHLCV time series"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "fred_economic_data_search",
      "description": "Retrieval tool for searching economic data series in finance: Finds Federal Reserve Economic Data (FRED) time series metadata matching a required search_text and optional tag_names, exclude_tag_names, order_by, sort_order, filter_variable/filter_value, realtime_start/end, limit, and offset, returning a paginated list of series identifiers and descriptors in JSON or XML. Call when: you need to discover or shortlist relevant series by keyword, tags, filters, or to paginate through search results. Do not call when: you need time-series observations/values, to browse categories, or to fetch details for a specific known series; use an observations, category, or series detail tool instead. Requires: search_text as a non-empty string; limit as integer >= 1; offset as integer >= 0 (zero-based); order_by as a supported series field; sort_order as 'asc' or 'desc'; tag_names and exclude_tag_names as comma-separated tag strings; realtime_start and realtime_end as dates in YYYY-MM-DD; file_type as 'json' or 'xml'; filter_variable and filter_value as strings; search_type as a supported mode. Rules: prefer file_type='json' unless XML is explicitly required; combine limit with offset for deterministic pagination; include-tag filters are applied first and exclude-tag filters remove matches; realtime_start/realtime_end constrain vintage availability (not observation dates); the operation is idempotent and has no side effects. Keywords: FRED, economic series search, time series metadata, tags filter, pagination, sort order, JSON XML, finance data.",
      "document": {
        "id": "48946e5b-2280-463e-8fe4-bb0aed7a924f",
        "name": "fred_economic_data_search",
        "appName": "apistlouisfedorg",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for searching economic data series in finance: Finds Federal Reserve Economic Data (FRED) time series metadata matching a required search_text and optional tag_names, exclude_tag_names, order_by, sort_order, filter_variable/filter_value, realtime_start/end, limit, and offset, returning a paginated list of series identifiers and descriptors in JSON or XML. Call when: you need to discover or shortlist relevant series by keyword, tags, filters, or to paginate through search results. Do not call when: you need time-series observations/values, to browse categories, or to fetch details for a specific known series; use an observations, category, or series detail tool instead. Requires: search_text as a non-empty string; limit as integer >= 1; offset as integer >= 0 (zero-based); order_by as a supported series field; sort_order as 'asc' or 'desc'; tag_names and exclude_tag_names as comma-separated tag strings; realtime_start and realtime_end as dates in YYYY-MM-DD; file_type as 'json' or 'xml'; filter_variable and filter_value as strings; search_type as a supported mode. Rules: prefer file_type='json' unless XML is explicitly required; combine limit with offset for deterministic pagination; include-tag filters are applied first and exclude-tag filters remove matches; realtime_start/realtime_end constrain vintage availability (not observation dates); the operation is idempotent and has no side effects. Keywords: FRED, economic series search, time series metadata, tags filter, pagination, sort order, JSON XML, finance data.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_query"
          ],
          "properties": {
            "aint_query": {
              "type": "object",
              "required": [
                "search_text"
              ],
              "properties": {
                "limit": {
                  "type": "integer",
                  "description": "Max number of results."
                },
                "offset": {
                  "type": "integer",
                  "description": "Result offset for pagination."
                },
                "order_by": {
                  "type": "string",
                  "description": "Field to order results by."
                },
                "file_type": {
                  "enum": [
                    "xml",
                    "json"
                  ],
                  "type": "string",
                  "description": "Response format."
                },
                "tag_names": {
                  "type": "string",
                  "description": "Comma-separated tags to include."
                },
                "sort_order": {
                  "type": "string",
                  "description": "Sort direction."
                },
                "search_text": {
                  "type": "string",
                  "description": "Text to search for in series metadata."
                },
                "search_type": {
                  "type": "string",
                  "description": "Search mode."
                },
                "filter_value": {
                  "type": "string",
                  "description": "Value to filter on."
                },
                "realtime_end": {
                  "type": "string",
                  "description": "Realtime end date."
                },
                "realtime_start": {
                  "type": "string",
                  "description": "Realtime start date."
                },
                "filter_variable": {
                  "type": "string",
                  "description": "Variable to filter by."
                },
                "exclude_tag_names": {
                  "type": "string",
                  "description": "Comma-separated tags to exclude."
                }
              },
              "additionalProperties": false
            }
          },
          "description": "Dynamic inputs for searching FRED series.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "stlouisfed",
              "org"
            ],
            "path": [
              "fred",
              "series",
              "search"
            ],
            "query": {
              "api_key": "$api_key"
            },
            "protocol": "https"
          },
          "method": "GET",
          "headers": {}
        }
      },
      "canonical_data": {
        "name": "fred_economic_data_search",
        "inputs": {
          "optional": "Within aint_query, you may specify: pagination controls (limit >= 1 and zero-based offset >= 0 used together for deterministic paging); sorting controls (order_by as a supported series field and sort_order as 'asc' or 'desc'); tag-based filtering (tag_names to include and exclude_tag_names to remove matches, both as comma-separated strings with include applied before exclude); general filtering (filter_variable and filter_value strings; search_type as a supported search mode); realtime vintage window (realtime_start and realtime_end as YYYY-MM-DD to constrain series availability by vintage, not observation dates); and response media type (file_type 'json' or 'xml', with JSON preferred unless XML is explicitly needed). No other properties are allowed.",
          "required": [
            "aint_query: Container object that holds all search parameters for the request; it must be provided to scope and execute the search.",
            "aint_query.search_text: Non-empty text string to match against series metadata; it defines the core search query and is mandatory for the search to run."
          ]
        },
        "intent": "Discover FRED time series by keyword and optional filters, returning a paginated set of series metadata in JSON or XML.",
        "context": "Intended for discovering or shortlisting series by keyword and optional filters, not for fetching observations, browsing categories, or retrieving a specific known series. Prefer JSON responses unless XML is required. Use limit with offset for deterministic pagination (offset is zero-based). Include-tag filters are applied first, then exclude-tag filters remove matches. Realtime start/end constrain vintage availability, not observation dates. Supported sorting depends on valid order_by fields and sort_order values. The schema disallows unspecified parameters (additionalProperties: false). Operation has no side effects.",
        "outputs": "A paginated list of FRED time series metadata records (identifiers and descriptive fields) in the requested format (JSON or XML). These records represent candidate series that can be passed to downstream tools (e.g., using their series identifiers) to fetch series details or observations.",
        "operation": "Search FRED time series metadata",
        "preconditions": "The request must include aint_query with a non-empty search_text. If provided, optional parameters must satisfy their constraints: limit is an integer >= 1; offset is an integer >= 0 (zero-based); order_by must be a supported series field; sort_order must be 'asc' or 'desc'; tag_names and exclude_tag_names are comma-separated strings; realtime_start and realtime_end must be dates in YYYY-MM-DD format; file_type must be 'json' or 'xml'; search_type, filter_variable, and filter_value must be strings. The API must be reachable.",
        "postconditions": "Read-only, idempotent retrieval; no system state is changed. After successful execution, the caller has a deterministic page of matching series metadata for the given search criteria.",
        "business_objects": [
          "FRED time series metadata"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "list_economic_data_time_series_observations",
      "description": "Retrieval tool for fetching time-series observations in economics: Returns date-stamped values for a Federal Reserve Economic Data (FRED) series_id with optional filters for observation_start/end, real-time vintage windows, units transformations, frequency aggregation, sorting, pagination, and output format, yielding an ordered list of observations and metadata from the fred/series/observations endpoint. Call when: you need raw or aggregated FRED series values over a specified date range or vintage window, or when preparing data for analysis or charting. Do not call when: you need to discover series IDs, browse categories/releases, fetch series metadata, or perform statistical calculations; use search/metadata or analytics tools instead. Requires: series_id (string), optional observation_start and observation_end (YYYY-MM-DD), realtime_start and realtime_end (YYYY-MM-DD), vintage_dates (comma-separated YYYY-MM-DD), frequency (d|w|m|q|a), aggregation_method (avg|sum|eop), units (lin|chg|pch etc.), sort_order (asc|desc), limit (integer > 0), offset (integer \u2265 0), output_type (integer flag), and file_type with json preferred; pass dates as calendar dates, not timestamps. Rules: prefer file_type=json to receive structured data; if frequency is set, provide aggregation_method to control how values are rolled up; units transformations apply after aggregation; sort_order governs chronological order, and limit+offset paginate the sorted results; this tool is read-only and returns the upstream payload without client-side post-processing. Keywords: FRED, economic time series, observations, vintage dates, aggregation frequency, units transformation, finance data, macroeconomic indicators.",
      "document": {
        "id": "0ef86a82-827f-4ed5-bdcd-3fc5e254e951",
        "name": "list_economic_data_time_series_observations",
        "appName": "apistlouisfedorg",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for fetching time-series observations in economics: Returns date-stamped values for a Federal Reserve Economic Data (FRED) series_id with optional filters for observation_start/end, real-time vintage windows, units transformations, frequency aggregation, sorting, pagination, and output format, yielding an ordered list of observations and metadata from the fred/series/observations endpoint. Call when: you need raw or aggregated FRED series values over a specified date range or vintage window, or when preparing data for analysis or charting. Do not call when: you need to discover series IDs, browse categories/releases, fetch series metadata, or perform statistical calculations; use search/metadata or analytics tools instead. Requires: series_id (string), optional observation_start and observation_end (YYYY-MM-DD), realtime_start and realtime_end (YYYY-MM-DD), vintage_dates (comma-separated YYYY-MM-DD), frequency (d|w|m|q|a), aggregation_method (avg|sum|eop), units (lin|chg|pch etc.), sort_order (asc|desc), limit (integer > 0), offset (integer \u2265 0), output_type (integer flag), and file_type with json preferred; pass dates as calendar dates, not timestamps. Rules: prefer file_type=json to receive structured data; if frequency is set, provide aggregation_method to control how values are rolled up; units transformations apply after aggregation; sort_order governs chronological order, and limit+offset paginate the sorted results; this tool is read-only and returns the upstream payload without client-side post-processing. Keywords: FRED, economic time series, observations, vintage dates, aggregation frequency, units transformation, finance data, macroeconomic indicators.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_query"
          ],
          "properties": {
            "aint_query": {
              "type": "object",
              "required": [
                "series_id"
              ],
              "properties": {
                "limit": {
                  "type": "integer",
                  "description": "Maximum number of results to return."
                },
                "units": {
                  "type": "string",
                  "description": "Unit transformation of series values (e.g., lin, chg, pch)."
                },
                "offset": {
                  "type": "integer",
                  "description": "Result offset for pagination."
                },
                "file_type": {
                  "enum": [
                    "xml",
                    "json",
                    "xlsx",
                    "csv"
                  ],
                  "type": "string",
                  "description": "Response format; default is xml."
                },
                "frequency": {
                  "type": "string",
                  "description": "Frequency to aggregate data to (e.g., d, w, m, q, a)."
                },
                "series_id": {
                  "type": "string",
                  "description": "The FRED series ID (e.g., GNPCA)."
                },
                "sort_order": {
                  "enum": [
                    "asc",
                    "desc"
                  ],
                  "type": "string",
                  "description": "Sort order of results."
                },
                "output_type": {
                  "type": "integer",
                  "description": "Output type flag."
                },
                "realtime_end": {
                  "type": "string",
                  "description": "End date for real-time period (YYYY-MM-DD)."
                },
                "vintage_dates": {
                  "type": "string",
                  "description": "Comma-separated vintage dates (YYYY-MM-DD) to filter by."
                },
                "realtime_start": {
                  "type": "string",
                  "description": "Start date for real-time period (YYYY-MM-DD)."
                },
                "observation_end": {
                  "type": "string",
                  "description": "Filter observations up to this date (YYYY-MM-DD)."
                },
                "observation_start": {
                  "type": "string",
                  "description": "Filter observations from this date (YYYY-MM-DD)."
                },
                "aggregation_method": {
                  "type": "string",
                  "description": "Method used when aggregating to a lower frequency (e.g., avg, sum, eop)."
                }
              },
              "additionalProperties": false
            }
          },
          "description": "Dynamic inputs mapped to query parameters for the fred/series/observations endpoint.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "stlouisfed",
              "org"
            ],
            "path": [
              "fred",
              "series",
              "observations"
            ],
            "query": {
              "api_key": "$api_key"
            },
            "protocol": "https"
          },
          "method": "GET"
        }
      },
      "canonical_data": {
        "name": "list_economic_data_time_series_observations",
        "inputs": {
          "optional": "Within aint_query, the tool accepts optional parameters to tailor the retrieval: observation_start and observation_end (YYYY-MM-DD) to bound the calendar date range; realtime_start and realtime_end (YYYY-MM-DD) to bound the real-time/vintage window; vintage_dates (comma-separated YYYY-MM-DD) to select specific vintages; frequency (d, w, m, q, a) to aggregate the series to a lower frequency; aggregation_method (e.g., avg, sum, eop) to define how values are rolled up when frequency is set; units (e.g., lin, chg, pch) to transform values after any aggregation; sort_order (asc or desc) to control chronological ordering; limit (integer > 0) and offset (integer \u2265 0) for pagination of the sorted results; output_type (integer flag) to request alternative output structures; and file_type (xml, json, xlsx, csv) to choose the response format (default is xml, json is recommended for structured use). All date-like fields must be provided as calendar dates (YYYY-MM-DD), not timestamps.",
          "required": [
            "aint_query: Container object mapping directly to fred/series/observations query parameters; it is required to carry the series identifier and any optional filters or formatting controls.",
            "series_id (inside aint_query): The FRED series ID whose observations should be retrieved; this identifies the exact economic time series to return."
          ]
        },
        "intent": "Retrieve date-stamped values for a specified FRED economic time series, with optional filtering by calendar date range or real-time vintage window, and optional aggregation, transformation, sorting, pagination, and output format controls.",
        "context": "The tool directly proxies fred/series/observations and performs no client-side post-processing. Prefer file_type=json to obtain structured data. If frequency is set, aggregation_method determines how multiple higher-frequency values are combined; units transformations are applied after aggregation. sort_order controls chronological ordering, and limit plus offset paginate the already-sorted results. observation_start/end filter by calendar dates; realtime_start/end define the real-time (vintage) window; vintage_dates allows selection of specific vintages via comma-separated YYYY-MM-DD values. Default response format is xml if file_type is not specified.",
        "outputs": "Returns the upstream fred/series/observations payload in the requested file_type (xml, json, xlsx, or csv). The content is an ordered list of observation records (each with a date and a value) along with associated metadata. In JSON/csv-like forms, these observation records can be directly used as input data for downstream tools that require time-stamped values (e.g., for analysis, aggregation, or charting), preserving the specified sorting, filtering, and transformation choices.",
        "operation": "fetch time-series observations for a FRED series",
        "preconditions": "A valid series_id must be supplied inside the required aint_query object. If provided, date parameters must be in YYYY-MM-DD format. If frequency is provided, the aggregation_method must be chosen from supported methods (e.g., avg, sum, eop) to control rollups. units, frequency, sort_order, and file_type must be from their allowed sets. limit must be > 0 and offset must be \u2265 0 when used. The FRED fred/series/observations endpoint must be accessible.",
        "postconditions": "Read-only operation; no server-side or client-side state is mutated. On success, an ordered observations dataset and metadata are returned exactly as provided by the FRED endpoint, reflecting the requested filters, aggregation, transformations, sorting, and pagination.",
        "business_objects": [
          "FRED series",
          "time-series observations"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "create_linkedin_post",
      "description": "Mutation tool for creating posts in social: Creates a LinkedIn UGC share on a member profile using commentary text, a media category (NONE, ARTICLE, IMAGE, VIDEO), optional media (article URL or digital media asset URN), and visibility, resulting in a published post on LinkedIn. Call when you need to publish a new LinkedIn post for the authenticated member with text and optional article, image, or video. Do not call when uploading media assets, editing or deleting posts, commenting, messaging, or posting to organization pages; use a media upload or the appropriate tool instead. Requires author_person_urn (string in format urn:li:person:XXXXXXXX), lifecycle_state='PUBLISHED', share_commentary_text (string, UTF-8), share_media_category in {NONE, ARTICLE, IMAGE, VIDEO}, and visibility in {PUBLIC, CONNECTIONS}; if IMAGE or VIDEO, include media array items with status='READY' and media urn:li:digitalmediaAsset:XXXXXXXX; if ARTICLE, include a media item with originalUrl (https URL) and optional title/description; do not include media when share_media_category is NONE. Rules: share_media_category determines which media fields are honored (for IMAGE/VIDEO ignore originalUrl; for ARTICLE ignore media asset URNs), the author must be the authenticated member, lifecycle_state must be 'PUBLISHED', additional properties are rejected per schema, and calls are not idempotent so repeated invocations will publish multiple posts. Keywords: linkedin, ugc share, social post publishing, person urn, digital media asset, article url, member visibility, image video.",
      "document": {
        "id": "e4d2f53e-f3e1-4859-91e5-211bebdb0026",
        "auth": {
          "provider": "linkedin"
        },
        "name": "create_linkedin_post",
        "appName": "apilinkedincom",
        "tool_type": "general",
        "transport": "http",
        "description": "Mutation tool for creating posts in social: Creates a LinkedIn UGC share on a member profile using commentary text, a media category (NONE, ARTICLE, IMAGE, VIDEO), optional media (article URL or digital media asset URN), and visibility, resulting in a published post on LinkedIn. Call when you need to publish a new LinkedIn post for the authenticated member with text and optional article, image, or video. Do not call when uploading media assets, editing or deleting posts, commenting, messaging, or posting to organization pages; use a media upload or the appropriate tool instead. Requires author_person_urn (string in format urn:li:person:XXXXXXXX), lifecycle_state='PUBLISHED', share_commentary_text (string, UTF-8), share_media_category in {NONE, ARTICLE, IMAGE, VIDEO}, and visibility in {PUBLIC, CONNECTIONS}; if IMAGE or VIDEO, include media array items with status='READY' and media urn:li:digitalmediaAsset:XXXXXXXX; if ARTICLE, include a media item with originalUrl (https URL) and optional title/description; do not include media when share_media_category is NONE. Rules: share_media_category determines which media fields are honored (for IMAGE/VIDEO ignore originalUrl; for ARTICLE ignore media asset URNs), the author must be the authenticated member, lifecycle_state must be 'PUBLISHED', additional properties are rejected per schema, and calls are not idempotent so repeated invocations will publish multiple posts. Keywords: linkedin, ugc share, social post publishing, person urn, digital media asset, article url, member visibility, image video.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aint_body": {
              "type": "object",
              "required": [
                "author",
                "lifecycleState",
                "specificContent",
                "visibility"
              ],
              "properties": {
                "author": {
                  "type": "string",
                  "description": "Person URN of the member creating the share (e.g., urn:li:person:XXXXXXXX)."
                },
                "visibility": {
                  "type": "object",
                  "required": [
                    "com.linkedin.ugc.MemberNetworkVisibility"
                  ],
                  "properties": {
                    "com.linkedin.ugc.MemberNetworkVisibility": {
                      "enum": [
                        "PUBLIC",
                        "CONNECTIONS"
                      ],
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                },
                "lifecycleState": {
                  "enum": [
                    "PUBLISHED"
                  ],
                  "type": "string",
                  "description": "Always 'PUBLISHED' when creating a share."
                },
                "specificContent": {
                  "type": "object",
                  "required": [
                    "com.linkedin.ugc.ShareContent"
                  ],
                  "properties": {
                    "com.linkedin.ugc.ShareContent": {
                      "type": "object",
                      "required": [
                        "shareCommentary",
                        "shareMediaCategory"
                      ],
                      "properties": {
                        "media": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "required": [
                              "status"
                            ],
                            "properties": {
                              "media": {
                                "type": "string",
                                "description": "DigitalMediaAsset URN for image/video (e.g., urn:li:digitalmediaAsset:XXXXXXXX)."
                              },
                              "title": {
                                "type": "object",
                                "required": [
                                  "text"
                                ],
                                "properties": {
                                  "text": {
                                    "type": "string"
                                  }
                                },
                                "additionalProperties": false
                              },
                              "status": {
                                "enum": [
                                  "READY"
                                ],
                                "type": "string"
                              },
                              "description": {
                                "type": "object",
                                "required": [
                                  "text"
                                ],
                                "properties": {
                                  "text": {
                                    "type": "string"
                                  }
                                },
                                "additionalProperties": false
                              },
                              "originalUrl": {
                                "type": "string",
                                "description": "URL of the article to share."
                              }
                            },
                            "additionalProperties": false
                          }
                        },
                        "shareCommentary": {
                          "type": "object",
                          "required": [
                            "text"
                          ],
                          "properties": {
                            "text": {
                              "type": "string"
                            }
                          },
                          "additionalProperties": false
                        },
                        "shareMediaCategory": {
                          "enum": [
                            "NONE",
                            "ARTICLE",
                            "IMAGE",
                            "VIDEO"
                          ],
                          "type": "string"
                        }
                      },
                      "additionalProperties": false
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          },
          "description": "Provide the UGC post body."
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "linkedin",
              "com"
            ],
            "path": [
              "v2",
              "ugcPosts"
            ],
            "protocol": "https"
          },
          "method": "POST",
          "headers": {
            "Authorization": "Bearer $Authorization",
            "X-Restli-Protocol-Version": "2.0.0"
          }
        }
      },
      "canonical_data": {
        "name": "create_linkedin_post",
        "inputs": {
          "optional": "Accepts a single object payload (aint_body) that represents the UGC post body. It must include: author (a person URN like urn:li:person:XXXXXXXX identifying the posting member); lifecycleState set to PUBLISHED; visibility as an object containing com.linkedin.ugc.MemberNetworkVisibility with value PUBLIC or CONNECTIONS; and specificContent containing com.linkedin.ugc.ShareContent with shareCommentary.text (UTF-8 text) and shareMediaCategory in {NONE, ARTICLE, IMAGE, VIDEO}. Depending on shareMediaCategory, an optional media array can be provided: for IMAGE or VIDEO, each item must have status=READY and a media field set to a digital media asset URN (urn:li:digitalmediaAsset:XXXXXXXX); for ARTICLE, provide an item with originalUrl (https URL) and optional title.text/description.text; for NONE, no media should be supplied. The schema is strict (additionalProperties=false) for the nested objects, and shareMediaCategory determines which media fields are honored (ARTICLE uses originalUrl and ignores media URNs; IMAGE/VIDEO use media URNs and ignore originalUrl).",
          "required": "none"
        },
        "intent": "Publish a new LinkedIn member UGC post (share) to the authenticated member\u2019s profile with required commentary text, visibility, and an optional article link or uploaded media.",
        "context": "This tool only creates member UGC shares (not organization posts) and does not upload media, edit/delete posts, comment, or message. shareMediaCategory drives which media-related fields are honored (ARTICLE uses originalUrl; IMAGE/VIDEO use media URNs). The schema is strict with additionalProperties=false in nested objects. Commentary text is UTF-8. Media item status must be READY. Visibility is restricted to PUBLIC or CONNECTIONS. Repeated invocations publish additional posts rather than replace or upsert.",
        "outputs": "The specification does not define a response body; the side effect is creation of a published LinkedIn UGC post (share) on the author\u2019s member profile.",
        "operation": "Create a LinkedIn UGC share on a member profile",
        "preconditions": "The caller must be authenticated as the member indicated by the author person URN. The request body must conform to the schema with no additional properties. lifecycleState must be PUBLISHED. shareMediaCategory must be one of NONE, ARTICLE, IMAGE, VIDEO. If shareMediaCategory=IMAGE or VIDEO, each media item must have status=READY and a valid digital media asset URN (urn:li:digitalmediaAsset:XXXXXXXX) that already exists and is available. If shareMediaCategory=ARTICLE, at least one media item must include originalUrl (https URL), with optional title/description. If shareMediaCategory=NONE, media must be omitted. Visibility must be PUBLIC or CONNECTIONS.",
        "postconditions": "A new LinkedIn UGC post is published to the specified member profile. The operation is mutating and not idempotent; repeated calls with the same input will result in multiple published posts.",
        "business_objects": [
          "LinkedIn UGC post (share)",
          "Digital media asset",
          "Article link",
          "Member (person)"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "get_servicenow_records_by_tableName",
      "description": "Retrieve records from  existing tables.\n\nincident \u2014 Contains incident records used for break/fix issues.\nproblem \u2014 Contains problem records used for root cause analysis.\nchange_request \u2014 Used to store change requests, including standard, normal, and emergency changes.\ntask \u2014 The parent table for all task-type records, including incidents, problems, and changes.\nsc_request \u2014 Represents a Service Catalog request (REQ), the container for requested items.\nsc_req_item \u2014 Represents individual Service Catalog request items (RITM) inside a request.\nsc_task \u2014 Tasks associated with catalog request items (e.g., approvals, fulfillment steps).\ncmdb_ci \u2014 The core table for all configuration items in the CMDB.\ncmdb_ci_server \u2014 Stores server CIs (physical, virtual, cloud).\ncmdb_ci_app \u2014 Stores application-related configuration items.\nsys_user \u2014 Stores user accounts and profile data.\nsys_user_group \u2014 Stores group definitions (e.g., support groups, assignment groups).\nsys_choice \u2014 Stores the selectable values (choices) for dropdown fields.\nsys_properties \u2014 Stores system-wide configuration properties.",
      "document": {
        "id": "648b2378-8476-466f-8864-642cd0285947",
        "auth": null,
        "name": "get_servicenow_records_by_tableName",
        "appName": "dev341424service-nowcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieve records from  existing tables.\n\nincident \u2014 Contains incident records used for break/fix issues.\nproblem \u2014 Contains problem records used for root cause analysis.\nchange_request \u2014 Used to store change requests, including standard, normal, and emergency changes.\ntask \u2014 The parent table for all task-type records, including incidents, problems, and changes.\nsc_request \u2014 Represents a Service Catalog request (REQ), the container for requested items.\nsc_req_item \u2014 Represents individual Service Catalog request items (RITM) inside a request.\nsc_task \u2014 Tasks associated with catalog request items (e.g., approvals, fulfillment steps).\ncmdb_ci \u2014 The core table for all configuration items in the CMDB.\ncmdb_ci_server \u2014 Stores server CIs (physical, virtual, cloud).\ncmdb_ci_app \u2014 Stores application-related configuration items.\nsys_user \u2014 Stores user accounts and profile data.\nsys_user_group \u2014 Stores group definitions (e.g., support groups, assignment groups).\nsys_choice \u2014 Stores the selectable values (choices) for dropdown fields.\nsys_properties \u2014 Stores system-wide configuration properties.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aint_path": {
              "type": "object",
              "required": [
                "tableName"
              ],
              "properties": {
                "tableName": {
                  "type": "string",
                  "description": "choose a table name which represent the data record, for instance incident related record, the table name is incident"
                }
              }
            },
            "aint_query": {
              "type": "object",
              "properties": {
                "sysparm_view": {
                  "description": "Render the response according to the specified UI view (overridden by sysparm_fields)"
                },
                "sysparm_limit": {
                  "description": "The maximum number of results returned per page (default: 10,000)"
                },
                "sysparm_query": {
                  "description": "An encoded query string used to filter the results"
                },
                "sysparm_fields": {
                  "description": "A comma-separated list of fields to return in the response"
                },
                "sysparm_no_count": {
                  "description": "Do not execute a select count(*) on table (default: false)"
                },
                "sysparm_display_value": {
                  "description": "Return field display values (true), actual values (false), or both (all) (default: false)"
                },
                "sysparm_query_category": {
                  "description": "Name of the query category (read replica category) to use for queries"
                },
                "sysparm_query_no_domain": {
                  "description": "True to access data across domains if authorized (default: false)"
                },
                "sysparm_exclude_reference_link": {
                  "description": "True to exclude Table API links for reference fields (default: false)"
                },
                "sysparm_suppress_pagination_header": {
                  "description": "True to supress pagination header (default: false)"
                }
              }
            }
          },
          "description": "Retrieve records from  existing tables.\n\nincident \u2014 Contains incident records used for break/fix issues.\nproblem \u2014 Contains problem records used for root cause analysis.\nchange_request \u2014 Used to store change requests, including standard, normal, and emergency changes.\ntask \u2014 The parent table for all task-type records, including incidents, problems, and changes.\nsc_request \u2014 Represents a Service Catalog request (REQ), the container for requested items.\nsc_req_item \u2014 Represents individual Service Catalog request items (RITM) inside a request.\nsc_task \u2014 Tasks associated with catalog request items (e.g., approvals, fulfillment steps).\ncmdb_ci \u2014 The core table for all configuration items in the CMDB.\ncmdb_ci_server \u2014 Stores server CIs (physical, virtual, cloud).\ncmdb_ci_app \u2014 Stores application-related configuration items.\nsys_user \u2014 Stores user accounts and profile data.\nsys_user_group \u2014 Stores group definitions (e.g., support groups, assignment groups).\nsys_choice \u2014 Stores the selectable values (choices) for dropdown fields.\nsys_properties \u2014 Stores system-wide configuration properties."
        },
        "staticInput": {
          "url": {
            "host": [
              "dev341424",
              "service-now",
              "com"
            ],
            "path": [
              "api",
              "now",
              "table",
              "${tableName}"
            ],
            "query": {},
            "protocol": "https"
          },
          "method": "GET"
        }
      },
      "canonical_data": {
        "name": "get_servicenow_records_by_tableName",
        "inputs": {
          "optional": "Optional query parameters control how records are filtered, limited, and formatted: an encoded query string can filter results; a limit sets the maximum records returned per page (default 10,000); specific fields can be selected (overrides view); a UI view can shape the response if fields are not explicitly set; display values can be returned instead of or in addition to raw values; a query category can direct reads to a named read replica category; domain-crossing access can be requested if authorized; reference field hyperlinks can be excluded; count queries can be skipped; and pagination headers can be suppressed. These options collectively influence result set size, projection, display formatting, domain scope, and response metadata.",
          "required": [
            "tableName: The name of the ServiceNow table to query (for example, incident, problem, change_request). It identifies which table the tool will read from and is necessary to scope the retrieval operation."
          ]
        },
        "intent": "Fetch records from a specified ServiceNow table using Table API-style query and formatting options.",
        "context": "Defaults and behaviors: sysparm_limit defaults to 10,000; sysparm_display_value defaults to false; boolean flags such as sysparm_no_count, sysparm_query_no_domain, sysparm_exclude_reference_link, and sysparm_suppress_pagination_header default to false. If sysparm_fields is provided it overrides sysparm_view. The tool can query common ServiceNow tables such as incident, problem, change_request, task, sc_request, sc_req_item, sc_task, cmdb_ci (and subtypes like cmdb_ci_server, cmdb_ci_app), sys_user, sys_user_group, sys_choice, and sys_properties. Filtering uses ServiceNow encoded query strings; pagination behavior is controlled via limit and may include or suppress pagination headers based on provided flags.",
        "outputs": "A collection of records from the specified ServiceNow table, constrained by the provided filters and limits. Returned objects include only the fields requested (if sysparm_fields is used) or fields determined by the specified view; field values are raw, display, or both depending on sysparm_display_value. The number of records returned is capped by sysparm_limit. The response shape and included metadata may be affected by options such as excluding reference links or suppressing pagination headers. These records can be consumed by downstream tools that operate on the same table records.",
        "operation": "Retrieve records from a specified ServiceNow table",
        "preconditions": "The target table name must refer to an existing ServiceNow table. If cross-domain access is requested (sysparm_query_no_domain=true), the caller must be authorized for cross-domain data access. Any provided encoded query must be valid, any specified fields must be valid for the table, and any named query category must be valid. The ServiceNow API must be reachable.",
        "postconditions": "Read-only operation; no data is created, updated, or deleted. After successful execution, a set of table records matching the query parameters is retrieved.",
        "business_objects": [
          "ServiceNow table",
          "ServiceNow table record"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "update_servicenow_record_in_table_by_id",
      "description": "Modify a servicenow record in table by sys-id ",
      "document": {
        "id": "89edd85f-cf95-4a4d-a15a-6405bc5a429f",
        "auth": null,
        "name": "update_servicenow_record_in_table_by_id",
        "appName": "dev341424service-nowcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Modify a servicenow record in table by sys-id ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aint_body": {
              "type": "string",
              "description": "application/json content"
            },
            "aint_path": {
              "type": "object",
              "required": [
                "sys_id",
                "tableName"
              ],
              "properties": {
                "sys_id": {
                  "type": "string",
                  "description": ""
                },
                "tableName": {
                  "type": "string",
                  "description": ""
                }
              }
            },
            "aint_query": {
              "type": "object",
              "properties": {
                "sysparm_view": {
                  "description": "Render the response according to the specified UI view (overridden by sysparm_fields)"
                },
                "sysparm_fields": {
                  "description": "A comma-separated list of fields to return in the response"
                },
                "sysparm_display_value": {
                  "description": "Return field display values (true), actual values (false), or both (all) (default: false)"
                },
                "sysparm_query_no_domain": {
                  "description": "True to access data across domains if authorized (default: false)"
                },
                "sysparm_input_display_value": {
                  "description": "Set field values using their display value (true) or actual value (false) (default: false)"
                },
                "sysparm_exclude_reference_link": {
                  "description": "True to exclude Table API links for reference fields (default: false)"
                },
                "sysparm_suppress_auto_sys_field": {
                  "description": "True to suppress auto generation of system fields (default: false)"
                }
              }
            }
          },
          "description": "Modify a record"
        },
        "staticInput": {
          "url": {
            "host": [
              "dev341424",
              "service-now",
              "com"
            ],
            "path": [
              "api",
              "now",
              "table",
              "${tableName}",
              "${sys_id}"
            ],
            "query": {},
            "protocol": "https"
          },
          "method": "PUT",
          "headers": {
            "Content-Type": "application/json"
          }
        }
      },
      "canonical_data": {
        "name": "update_servicenow_record_in_table_by_id",
        "inputs": {
          "optional": "An application/json request body (provided as a string) containing field names and values to modify on the targeted record; and query parameters that control response rendering and input handling, including: selecting a UI view or explicit fields to return, choosing display values vs actual values vs both for fields, optionally accessing data across domains if authorized, interpreting input field values as display values or actual values, excluding reference field links from the response, and suppressing automatic generation of system fields. Defaults for these flags are false unless specified.",
          "required": [
            "sys_id: The unique identifier of the target record in the specified ServiceNow table; required to precisely locate which record will be updated.",
            "tableName: The API name of the ServiceNow table that contains the record; required to route the update to the correct table."
          ]
        },
        "intent": "Update a specific record in a ServiceNow table identified by its sys_id.",
        "context": "This is a mutating Table API operation that updates a record and returns its representation. Response rendering can be controlled via sysparm_view (overridden by sysparm_fields) and sysparm_fields (comma-separated field list). Field value formatting can be set with sysparm_display_value (default false). Cross-domain access is possible if authorized via sysparm_query_no_domain (default false). Input interpretation can be set with sysparm_input_display_value (default false) to use display values when setting fields. Reference links can be excluded with sysparm_exclude_reference_link (default false). Automatic system field generation can be suppressed with sysparm_suppress_auto_sys_field (default false). The request body is application/json content provided as a string.",
        "outputs": "A single ServiceNow record representation for the specified table and sys_id after modification. The returned object\u2019s fields and formatting are governed by the query options (e.g., selected fields or view, display vs actual values, inclusion/exclusion of reference links, and suppression of auto-generated system fields).",
        "operation": "Modify a ServiceNow table record by sys_id",
        "preconditions": "The specified tableName and sys_id must correspond to an existing record in the ServiceNow instance. The ServiceNow Table API must be accessible. If cross-domain access is requested (sysparm_query_no_domain=true), the caller must be authorized to access data across domains.",
        "postconditions": "The targeted ServiceNow record is updated with the provided field values, and the API returns the record in the format specified by the query parameters. No other records are modified by this operation.",
        "business_objects": [
          "ServiceNow table record"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "get_servicenow_records_in_table_by_id",
      "description": "Retrieve a servicenow record for specific record id or sys_id in recorded ",
      "document": {
        "id": "bbc7944b-7cd5-46bb-a65a-8096810d87e1",
        "auth": null,
        "name": "get_servicenow_records_in_table_by_id",
        "appName": "dev341424service-nowcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieve a servicenow record for specific record id or sys_id in recorded ",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aint_path": {
              "type": "object",
              "required": [
                "sys_id",
                "tableName"
              ],
              "properties": {
                "sys_id": {
                  "type": "string",
                  "description": ""
                },
                "tableName": {
                  "type": "string",
                  "description": ""
                }
              }
            },
            "aint_query": {
              "type": "object",
              "properties": {
                "sysparm_view": {
                  "description": "Render the response according to the specified UI view (overridden by sysparm_fields)"
                },
                "sysparm_fields": {
                  "description": "A comma-separated list of fields to return in the response"
                },
                "sysparm_display_value": {
                  "description": "Return field display values (true), actual values (false), or both (all) (default: false)"
                },
                "sysparm_query_no_domain": {
                  "description": "True to access data across domains if authorized (default: false) "
                },
                "sysparm_exclude_reference_link": {
                  "description": "True to exclude Table API links for reference fields (default: false)"
                }
              }
            }
          },
          "description": "Retrieve a record"
        },
        "staticInput": {
          "url": {
            "host": [
              "dev341424",
              "service-now",
              "com"
            ],
            "path": [
              "api",
              "now",
              "table",
              "${tableName}",
              "${sys_id}"
            ],
            "query": {},
            "protocol": "https"
          },
          "method": "GET"
        }
      },
      "canonical_data": {
        "name": "get_servicenow_records_in_table_by_id",
        "inputs": {
          "optional": "An optional query object can refine the response: choose a UI view to render (sysparm_view), explicitly choose which fields to return (sysparm_fields, which overrides sysparm_view), control value format for fields (sysparm_display_value: true for display values, false for actual values, all for both; default false), toggle cross-domain data access if authorized (sysparm_query_no_domain; default false), and exclude Table API reference links from reference fields (sysparm_exclude_reference_link; default false).",
          "required": [
            {
              "name": "sys_id",
              "description": "The unique identifier of the target record within the ServiceNow table; used to precisely select which record to retrieve."
            },
            {
              "name": "tableName",
              "description": "The name of the ServiceNow table that contains the record; required to locate the correct table for the given sys_id."
            }
          ]
        },
        "intent": "Fetch a single record from a specified ServiceNow table using its unique sys_id, with optional controls over returned fields and value rendering.",
        "context": "This is a record-retrieval operation by sys_id within a named ServiceNow table. Response shaping is controlled by standard ServiceNow Table API-style parameters: sysparm_fields (if present) overrides sysparm_view; sysparm_display_value accepts true, false, or all (default false); sysparm_query_no_domain enables cross-domain access when authorized (default false); sysparm_exclude_reference_link removes Table API links from reference fields (default false). If no optional parameters are provided, defaults apply.",
        "outputs": "A single ServiceNow record object from the specified table, formatted according to the provided query options. The object contains the record\u2019s fields (potentially limited by sysparm_fields or view selection), with values rendered per sysparm_display_value, and may omit reference links if requested. The returned record\u2019s field values (including identifiers like sys_id) can be used as inputs to downstream tools that operate on ServiceNow records or related entities.",
        "operation": "Retrieve a record by sys_id from a specified ServiceNow table",
        "preconditions": "The caller must provide both the tableName and sys_id values. If cross-domain access is requested via sysparm_query_no_domain, the caller must be authorized for cross-domain data access.",
        "postconditions": "No data is modified; the operation is read-only. Upon success, the specified record is retrieved and returned according to the requested view/field and value-rendering options.",
        "business_objects": [
          "ServiceNow record",
          "ServiceNow table"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "send_email_by_gmail",
      "description": "Mutation tool for sending email in messaging: Sends an email via Gmail users.messages.send using a base64url-encoded RFC 2822 raw MIME string; inputs include user_id (string, use 'me' for the authenticated user), raw (string), optional thread_id (string), and label_ids (array of strings), and it returns the sent message\u2019s metadata (id, thread association, labels). Call when: you need to immediately deliver an email from the authenticated Gmail account, optionally add it to an existing thread, and apply labels at send time. Do not call when: you need to read or search mail, save or update a draft, modify labels on an existing message, or send via a non-Gmail provider\u2014use retrieval, drafts, or label-modification tools instead. Requires: user_id in path ('me' recommended), raw as base64url (no padding) of a complete RFC 2822 message with headers (To, From, Subject; Date optional), optional thread_id and label_ids as known strings. Rules: sending is immediate and not idempotent (retries may duplicate), attachments must be embedded within the raw MIME, if thread_id is provided the message is added to that thread, label_ids apply to the sent message, and base64url must be used rather than standard base64. Keywords: Gmail, users.messages.send, email send, base64url MIME, RFC 2822, threadId, labelIds, metadata.",
      "document": {
        "id": "ad4ed74f-28e8-4115-a05c-f7014d4f860d",
        "auth": {
          "provider": "google"
        },
        "name": "send_email_by_gmail",
        "appName": "gmailgoogleapiscom",
        "tool_type": "general",
        "transport": "http",
        "description": "Mutation tool for sending email in messaging: Sends an email via Gmail users.messages.send using a base64url-encoded RFC 2822 raw MIME string; inputs include user_id (string, use 'me' for the authenticated user), raw (string), optional thread_id (string), and label_ids (array of strings), and it returns the sent message\u2019s metadata (id, thread association, labels). Call when: you need to immediately deliver an email from the authenticated Gmail account, optionally add it to an existing thread, and apply labels at send time. Do not call when: you need to read or search mail, save or update a draft, modify labels on an existing message, or send via a non-Gmail provider\u2014use retrieval, drafts, or label-modification tools instead. Requires: user_id in path ('me' recommended), raw as base64url (no padding) of a complete RFC 2822 message with headers (To, From, Subject; Date optional), optional thread_id and label_ids as known strings. Rules: sending is immediate and not idempotent (retries may duplicate), attachments must be embedded within the raw MIME, if thread_id is provided the message is added to that thread, label_ids apply to the sent message, and base64url must be used rather than standard base64. Keywords: Gmail, users.messages.send, email send, base64url MIME, RFC 2822, threadId, labelIds, metadata.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_path",
            "aint_body"
          ],
          "properties": {
            "aint_body": {
              "type": "object",
              "required": [
                "raw"
              ],
              "properties": {
                "raw": {
                  "type": "string",
                  "description": "RFC 2822 formatted email message, base64url encoded."
                },
                "labelIds": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "description": "Labels to add to the sent message."
                },
                "threadId": {
                  "type": "string",
                  "description": "The ID of the thread to add the message to."
                }
              },
              "description": "Gmail Message resource to send.",
              "additionalProperties": false
            },
            "aint_path": {
              "type": "object",
              "required": [
                "userId"
              ],
              "properties": {
                "userId": {
                  "type": "string",
                  "description": "Use 'me' for the authenticated user."
                }
              },
              "additionalProperties": false
            },
            "aint_query": {
              "type": "object",
              "additionalProperties": {
                "type": [
                  "string",
                  "number",
                  "boolean"
                ]
              }
            },
            "aint_headers": {
              "type": "object",
              "additionalProperties": {
                "type": [
                  "string",
                  "number",
                  "boolean"
                ]
              }
            }
          },
          "description": "Dynamic inputs for Gmail users.messages.send (metadata).",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "gmail",
              "googleapis",
              "com"
            ],
            "path": [
              "gmail",
              "v1",
              "users",
              "$userId",
              "messages",
              "send"
            ],
            "protocol": "https"
          },
          "method": "POST",
          "headers": {
            "Content-Type": "application/json"
          }
        }
      },
      "canonical_data": {
        "name": "send_email_by_gmail",
        "inputs": {
          "optional": "Within aint_body, labelIds (array of string label IDs) may be provided to tag the sent message at send time, and threadId (string) may be provided to add the message to an existing thread. Optional aint_query and aint_headers objects allow passing additional query parameters or HTTP headers (string/number/boolean values) to the underlying API, though none are required. Only the documented properties are allowed inside aint_body and aint_path.",
          "required": [
            "aint_path: Path-parameter container required by the endpoint to specify the Gmail user context for the send operation.",
            "aint_path.userId: The Gmail user identifier in the request path (use 'me' for the authenticated user); determines the account from which the email is sent.",
            "aint_body: Request body container holding the Gmail Message resource to send.",
            "aint_body.raw: The complete RFC 2822 email message (including headers such as To, From, Subject; Date optional), base64url-encoded with no padding; this is the raw MIME content to be delivered."
          ]
        },
        "intent": "Deliver an email from a Gmail account by invoking Gmail's users.messages.send with a base64url-encoded RFC 2822 raw MIME message, optionally associating it with an existing thread and applying labels at send time.",
        "context": "This tool wraps Gmail users.messages.send. The message payload must use base64url encoding (not standard base64) and omit padding. Sending is immediate and not idempotent. Attachments must be included inline within the raw MIME. If threadId is provided, the send operation appends to that thread; labelIds apply at send time to the new message. Use 'me' for the authenticated userId in the path. aint_query and aint_headers can carry additional query parameters or headers as needed; no pagination is involved. The aint_body and aint_path objects disallow unspecified properties.",
        "outputs": "A Gmail message metadata object representing the sent message, including its unique message id, its thread association (threadId), and the applied label identifiers (labelIds). This metadata can be used to reference the sent message or its thread in subsequent operations.",
        "operation": "Send a Gmail message using a base64url-encoded raw MIME payload",
        "preconditions": "The caller must be authenticated to Gmail and authorized to send mail as the specified user. The users.messages.send API must be reachable. aint_path.userId must be provided ('me' recommended for the authenticated user). aint_body.raw must be a base64url-encoded (no padding) complete RFC 2822 message containing required headers (To, From, Subject; Date optional). If provided, threadId must identify an existing thread accessible to the user, and labelIds must be valid label identifiers for that user. If attachments are needed, they must be embedded within the raw MIME content.",
        "postconditions": "On success, an email is immediately sent from the specified Gmail account and a new message resource is created; if threadId was supplied, the message is added to that thread, and any provided labels are applied. The response returns the sent message\u2019s metadata (id, threadId, labelIds). The operation is mutating and not idempotent (retries may result in duplicate sent messages).",
        "business_objects": [
          "Gmail message",
          "Gmail thread",
          "Gmail label"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "create_google_calendar_event",
      "description": "Mutation tool for creating events in calendar: creates a new Google Calendar event and returns the created event resource with id and details, given a calendar_id and a start/end specification, with optional attendees, reminders, location, description, and conference data. Call when: you need to add a new all-day or timed event to a user's Google Calendar and optionally send notifications to attendees via sendUpdates. Do not call when: updating, deleting, or fetching events; use the corresponding update, delete, or retrieval tool instead. Requires: Google OAuth2 authorization with Calendar scope; calendar_id (string, e.g., 'primary'); start and end each as either date (YYYY-MM-DD for all-day) or dateTime (RFC3339, prefer UTC) plus optional timeZone (IANA name); optional summary, location, description; attendees [{email, optional, displayName, responseStatus}]; reminders {useDefault: boolean, overrides [{method: 'email'|'popup', minutes: integer}]}; sendUpdates ('all'|'externalOnly'|'none'); maxAttendees (integer); supportsAttachments (boolean); conferenceData (set conferenceDataVersion=1 if included). Rules: if dateTime is provided, ignore date; for all-day events provide date and omit dateTime; repeated calls create separate events (non-idempotent); prefer UTC unless a specific time zone is required; sendNotifications is deprecated\u2014use sendUpdates; attachments are only returned if supportsAttachments=true. Keywords: google calendar, create event, event attendees, event reminders, RFC3339 datetime, IANA time zone, send updates, conference data.",
      "document": {
        "id": "e636d04a-1117-4fab-853f-7beb79c941ae",
        "auth": {
          "provider": "google"
        },
        "name": "create_google_calendar_event",
        "appName": "wwwgoogleapiscom",
        "tool_type": "general",
        "transport": "http",
        "description": "Mutation tool for creating events in calendar: creates a new Google Calendar event and returns the created event resource with id and details, given a calendar_id and a start/end specification, with optional attendees, reminders, location, description, and conference data. Call when: you need to add a new all-day or timed event to a user's Google Calendar and optionally send notifications to attendees via sendUpdates. Do not call when: updating, deleting, or fetching events; use the corresponding update, delete, or retrieval tool instead. Requires: Google OAuth2 authorization with Calendar scope; calendar_id (string, e.g., 'primary'); start and end each as either date (YYYY-MM-DD for all-day) or dateTime (RFC3339, prefer UTC) plus optional timeZone (IANA name); optional summary, location, description; attendees [{email, optional, displayName, responseStatus}]; reminders {useDefault: boolean, overrides [{method: 'email'|'popup', minutes: integer}]}; sendUpdates ('all'|'externalOnly'|'none'); maxAttendees (integer); supportsAttachments (boolean); conferenceData (set conferenceDataVersion=1 if included). Rules: if dateTime is provided, ignore date; for all-day events provide date and omit dateTime; repeated calls create separate events (non-idempotent); prefer UTC unless a specific time zone is required; sendNotifications is deprecated\u2014use sendUpdates; attachments are only returned if supportsAttachments=true. Keywords: google calendar, create event, event attendees, event reminders, RFC3339 datetime, IANA time zone, send updates, conference data.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_path",
            "aint_body"
          ],
          "properties": {
            "aint_body": {
              "type": "object",
              "required": [
                "start",
                "end"
              ],
              "properties": {
                "end": {
                  "type": "object",
                  "properties": {
                    "date": {
                      "type": "string",
                      "description": "All-day end date (YYYY-MM-DD)."
                    },
                    "dateTime": {
                      "type": "string",
                      "description": "RFC3339 end date-time."
                    },
                    "timeZone": {
                      "type": "string",
                      "description": "IANA time zone name."
                    }
                  },
                  "additionalProperties": true
                },
                "start": {
                  "type": "object",
                  "properties": {
                    "date": {
                      "type": "string",
                      "description": "All-day start date (YYYY-MM-DD)."
                    },
                    "dateTime": {
                      "type": "string",
                      "description": "RFC3339 start date-time."
                    },
                    "timeZone": {
                      "type": "string",
                      "description": "IANA time zone name."
                    }
                  },
                  "additionalProperties": true
                },
                "summary": {
                  "type": "string",
                  "description": "Title of the event."
                },
                "location": {
                  "type": "string",
                  "description": "Free-form location text."
                },
                "attendees": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "email": {
                        "type": "string",
                        "description": "Attendee email address."
                      },
                      "optional": {
                        "type": "boolean",
                        "description": "Whether this is an optional attendee."
                      },
                      "displayName": {
                        "type": "string",
                        "description": "Attendee display name."
                      },
                      "responseStatus": {
                        "enum": [
                          "needsAction",
                          "declined",
                          "tentative",
                          "accepted"
                        ],
                        "type": "string",
                        "description": "Attendee response status."
                      }
                    },
                    "additionalProperties": true
                  }
                },
                "reminders": {
                  "type": "object",
                  "properties": {
                    "overrides": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "required": [
                          "method",
                          "minutes"
                        ],
                        "properties": {
                          "method": {
                            "enum": [
                              "email",
                              "popup"
                            ],
                            "type": "string",
                            "description": "Reminder delivery method."
                          },
                          "minutes": {
                            "type": "integer",
                            "description": "Minutes before start to trigger the reminder."
                          }
                        },
                        "additionalProperties": false
                      }
                    },
                    "useDefault": {
                      "type": "boolean",
                      "description": "Whether to use the calendar's default reminders."
                    }
                  },
                  "additionalProperties": false
                },
                "description": {
                  "type": "string",
                  "description": "Description of the event."
                },
                "conferenceData": {
                  "type": "object",
                  "description": "Conference-related info (e.g., Google Meet).",
                  "additionalProperties": true
                }
              },
              "description": "Events resource payload. 'start' and 'end' are required.",
              "additionalProperties": true
            },
            "aint_path": {
              "type": "object",
              "required": [
                "calendarId"
              ],
              "properties": {
                "calendarId": {
                  "type": "string",
                  "description": "Calendar identifier; use 'primary' for the user's primary calendar."
                }
              },
              "additionalProperties": false
            },
            "aint_query": {
              "type": "object",
              "properties": {
                "sendUpdates": {
                  "enum": [
                    "all",
                    "externalOnly",
                    "none"
                  ],
                  "type": "string",
                  "description": "Whether to send notifications about event creation."
                },
                "maxAttendees": {
                  "type": "integer",
                  "description": "Maximum number of attendees to include in the response."
                },
                "sendNotifications": {
                  "type": "boolean",
                  "description": "Deprecated. Use sendUpdates instead."
                },
                "supportsAttachments": {
                  "type": "boolean",
                  "description": "Whether the client supports event attachments."
                },
                "conferenceDataVersion": {
                  "type": "integer",
                  "maximum": 1,
                  "minimum": 0,
                  "description": "Set to 1 when creating conferenceData."
                }
              },
              "additionalProperties": false
            },
            "aint_headers": {
              "type": "object",
              "description": "Optional HTTP headers.",
              "additionalProperties": {
                "type": [
                  "string",
                  "number",
                  "boolean"
                ]
              }
            }
          },
          "description": "Dynamic inputs for creating a Google Calendar event.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "www",
              "googleapis",
              "com"
            ],
            "path": [
              "calendar",
              "v3",
              "calendars",
              "$calendarId",
              "events"
            ],
            "protocol": "https"
          },
          "method": "POST"
        }
      },
      "canonical_data": {
        "name": "create_google_calendar_event",
        "inputs": {
          "optional": "Within aint_body, additional event fields can be provided: summary (title), location (free-form text), description, attendees (array of attendee objects with email, optional, displayName, responseStatus), reminders (useDefault boolean or overrides array specifying method 'email'|'popup' and minutes), and conferenceData (conference-related info such as Google Meet). In aint_query, optional parameters control behavior and response shaping: sendUpdates ('all'|'externalOnly'|'none') to send notifications, maxAttendees (integer) to limit the number of attendee entries returned, supportsAttachments (boolean) to indicate the client supports event attachments (attachments are only returned when true), conferenceDataVersion (integer 0\u20131; set to 1 when including conferenceData), and a deprecated sendNotifications (boolean; use sendUpdates instead). Optional HTTP headers can be passed via aint_headers. For start/end: if dateTime is provided, date is ignored; for all-day events, provide date and omit dateTime; timeZone (IANA name) may be supplied if needed.",
          "required": [
            "aint_path: Object containing the target calendar identifier. It must include calendarId (e.g., 'primary') to specify which calendar the event will be created in.",
            "aint_path.calendarId: String that identifies the calendar (e.g., 'primary'); required to determine the destination calendar for the new event.",
            "aint_body: Object carrying the event payload; required to define the event being created.",
            "aint_body.start: Object defining the event start as either an all-day date (YYYY-MM-DD) or a dateTime (RFC3339, optionally with timeZone). Required to establish when the event begins.",
            "aint_body.end: Object defining the event end as either an all-day date (YYYY-MM-DD) or a dateTime (RFC3339, optionally with timeZone). Required to establish when the event ends."
          ]
        },
        "intent": "Create a new event in a specified Google Calendar and return the created event resource.",
        "context": "Use this tool only to create events (not to update, delete, or fetch). Prefer UTC for dateTime values unless a specific time zone is required. For all-day events, use date and omit dateTime; if dateTime is provided, any date value is ignored. sendNotifications is deprecated\u2014use sendUpdates. maxAttendees limits the number of attendee entries included in the response only. Attachments are only returned when supportsAttachments=true. Include conferenceDataVersion=1 in the query when creating conferenceData. The event payload (aint_body) allows additional properties except where restricted (e.g., reminders.overrides forbids additional properties), while aint_query and aint_path disallow unspecified properties. No pagination applies; this is a single-create mutation.",
        "outputs": "A single Google Calendar event resource (object) representing the newly created event, including its server-assigned id and the event details provided or computed by the API. This may include start/end (date or RFC3339 dateTime with optional timeZone), summary, location, description, attendees (possibly limited by maxAttendees), reminders, and conferenceData (when conferenceDataVersion=1 and conferenceData is included). Event attachments, if any, are only included when supportsAttachments=true. The returned event object can be used as input to other tools that operate on event ids or event fields.",
        "operation": "create a Google Calendar event",
        "preconditions": "The caller must be authorized via Google OAuth2 with Calendar scope and have write access to the specified calendarId. The aint_body must include valid start and end objects, each providing either a date (YYYY-MM-DD) for all-day events or a dateTime in RFC3339 format; if provided, timeZone must be a valid IANA name. If conferenceData is included in the body, aint_query.conferenceDataVersion must be set to 1. For reminders.overrides entries, both method ('email' or 'popup') and minutes (integer) are required. Query parameters must adhere to their allowed values and ranges (e.g., conferenceDataVersion in [0,1]). The API must be reachable.",
        "postconditions": "A new event is created in the specified calendar, persisted by Google Calendar, and assigned a unique id. The tool returns the created event resource. Depending on sendUpdates, notifications may be sent to attendees. The operation is non-idempotent; repeated calls create separate events.",
        "business_objects": [
          "calendar",
          "event",
          "attendee",
          "reminder",
          "conference data",
          "attachment"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "get_linkedin_user_info",
      "description": "Retrieval tool for fetching OpenID Connect user profile in identity: Retrieves the authenticated LinkedIn member\u2019s OIDC userinfo claims (e.g., sub, name, given_name, family_name, email, picture) from LinkedIn\u2019s userinfo endpoint and returns a JSON object with fields available per granted scopes. Call when: you need the current authenticated user\u2019s standardized identity claims from LinkedIn using an already-configured Bearer access token. Do not call when: you need non-OIDC LinkedIn data (posts, connections, companies), data for another user, or a different identity provider; use the corresponding LinkedIn API or provider-specific tool instead. Requires: a valid LinkedIn Bearer access token with appropriate scopes (at minimum openid, optionally profile and email), and any optional aint_query and aint_headers objects where values are strings, numbers, or booleans. Rules: performs a GET with no request body; Authorization is injected automatically\u2014do not include it in aint_headers; any Authorization supplied will be ignored; additional headers may override defaults; response content is read-only and idempotent, and absent fields indicate insufficient scopes. Keywords: openid connect, linkedin, userinfo, identity claims, bearer token, oidc scopes, profile.",
      "document": {
        "id": "69c71d84-5580-457f-9110-289708126a75",
        "auth": {
          "provider": "linkedin"
        },
        "name": "get_linkedin_user_info",
        "appName": "apilinkedincom",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for fetching OpenID Connect user profile in identity: Retrieves the authenticated LinkedIn member\u2019s OIDC userinfo claims (e.g., sub, name, given_name, family_name, email, picture) from LinkedIn\u2019s userinfo endpoint and returns a JSON object with fields available per granted scopes. Call when: you need the current authenticated user\u2019s standardized identity claims from LinkedIn using an already-configured Bearer access token. Do not call when: you need non-OIDC LinkedIn data (posts, connections, companies), data for another user, or a different identity provider; use the corresponding LinkedIn API or provider-specific tool instead. Requires: a valid LinkedIn Bearer access token with appropriate scopes (at minimum openid, optionally profile and email), and any optional aint_query and aint_headers objects where values are strings, numbers, or booleans. Rules: performs a GET with no request body; Authorization is injected automatically\u2014do not include it in aint_headers; any Authorization supplied will be ignored; additional headers may override defaults; response content is read-only and idempotent, and absent fields indicate insufficient scopes. Keywords: openid connect, linkedin, userinfo, identity claims, bearer token, oidc scopes, profile.",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aint_query": {
              "type": "object",
              "description": "Optional query parameters.",
              "additionalProperties": {
                "type": [
                  "string",
                  "number",
                  "boolean"
                ]
              }
            },
            "aint_headers": {
              "type": "object",
              "description": "Optional additional headers. Authorization is provided statically.",
              "additionalProperties": {
                "type": [
                  "string",
                  "number",
                  "boolean"
                ]
              }
            }
          },
          "description": "Optional dynamic inputs for the userinfo request. No body is used.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "api",
              "linkedin",
              "com"
            ],
            "path": [
              "v2",
              "userinfo"
            ],
            "protocol": "https"
          },
          "method": "GET",
          "headers": {
            "Authorization": "Bearer $Authorization"
          }
        }
      },
      "canonical_data": {
        "name": "get_linkedin_user_info",
        "inputs": {
          "optional": "Optional query parameters (aint_query) and additional headers (aint_headers) may be provided to influence the userinfo request; all values must be strings, numbers, or booleans. No request body is used. Authorization is injected automatically and any supplied Authorization header is ignored. Additional headers, if supplied, can override default headers.",
          "required": "none"
        },
        "intent": "Retrieve the current authenticated LinkedIn member\u2019s standardized OpenID Connect (OIDC) userinfo claims from LinkedIn\u2019s userinfo endpoint.",
        "context": "Performs an HTTP GET to LinkedIn\u2019s OIDC userinfo endpoint with no request body. Authorization is automatically added; any provided Authorization header is ignored. Optional headers may override defaults. Optional query and header values must be primitives (string, number, boolean). Returned claims vary by granted scopes (openid required; profile and email optional). The tool is restricted to OIDC userinfo retrieval and should not be used for posts, connections, companies, or other providers. The input schema disallows properties beyond aint_query and aint_headers. The response content is read-only and idempotent.",
        "outputs": "A JSON object containing the authenticated LinkedIn user\u2019s OIDC userinfo claims from LinkedIn\u2019s userinfo endpoint. Fields are present only if permitted by the token\u2019s granted scopes (e.g., sub, name, given_name, family_name, email, picture). Missing fields indicate insufficient scopes. This claims object can serve as standardized identity data for downstream tools that require attributes like subject identifier (sub), display names, or email.",
        "operation": "Retrieve OIDC userinfo claims for the authenticated LinkedIn member",
        "preconditions": "A valid LinkedIn Bearer access token must be configured and available to the tool. The token must include the openid scope; profile and email scopes are required to receive corresponding profile and email claims. The tool retrieves data only for the current authenticated LinkedIn member via the OIDC userinfo endpoint; it is not usable for other users, non-OIDC LinkedIn data, or other identity providers. LinkedIn\u2019s userinfo endpoint must be reachable. Optional input values must conform to primitive types (string, number, boolean).",
        "postconditions": "No server-side state is modified; the operation is read-only and idempotent. On success, the caller obtains a JSON userinfo claims object whose contents reflect the token\u2019s scopes; absent claims indicate insufficient scopes.",
        "business_objects": [
          "OIDC userinfo claims"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "list_gmail_messages",
      "description": "Retrieval tool for listing messages in email: lists a user's Gmail mailbox messages with optional search and label filters, returning a paginated set of message identifiers (e.g., id, threadId) and nextPageToken for continuation. Call when you need to enumerate message IDs for subsequent detail retrieval, filter messages by Gmail search query or labels, or page through a mailbox to build result sets. Do not call when you need message headers or body content, send or delete email, or modify labels; use an email message detail or mutation tool instead. Requires: userId (string; use 'me' for the authenticated account), optional maxResults (integer 1\u2013500, default 100), pageToken (string for pagination), q (string using Gmail search operators like from:, to:, subject:, label:, newer_than:, older_than:), labelIds (string of label IDs), includeSpamTrash (boolean, default false). Rules: q and labelIds filters are combined; if maxResults exceeds 500 it is capped; when pageToken is provided pagination continues from that token; results are read-only and idempotent; for stable pagination keep all filters constant across calls; SPAM/TRASH are excluded unless includeSpamTrash is true. Keywords: gmail, email listing, message ids, search query, label filter, pagination, spam and trash.",
      "document": {
        "id": "c0f05f06-6a18-4fb9-b058-3351447dcfac",
        "auth": {
          "provider": "google"
        },
        "name": "list_gmail_messages",
        "appName": "gmailgoogleapiscom",
        "tool_type": "general",
        "transport": "http",
        "description": "Retrieval tool for listing messages in email: lists a user's Gmail mailbox messages with optional search and label filters, returning a paginated set of message identifiers (e.g., id, threadId) and nextPageToken for continuation. Call when you need to enumerate message IDs for subsequent detail retrieval, filter messages by Gmail search query or labels, or page through a mailbox to build result sets. Do not call when you need message headers or body content, send or delete email, or modify labels; use an email message detail or mutation tool instead. Requires: userId (string; use 'me' for the authenticated account), optional maxResults (integer 1\u2013500, default 100), pageToken (string for pagination), q (string using Gmail search operators like from:, to:, subject:, label:, newer_than:, older_than:), labelIds (string of label IDs), includeSpamTrash (boolean, default false). Rules: q and labelIds filters are combined; if maxResults exceeds 500 it is capped; when pageToken is provided pagination continues from that token; results are read-only and idempotent; for stable pagination keep all filters constant across calls; SPAM/TRASH are excluded unless includeSpamTrash is true. Keywords: gmail, email listing, message ids, search query, label filter, pagination, spam and trash.",
        "inputSchema": {
          "type": "object",
          "required": [
            "aint_path"
          ],
          "properties": {
            "aint_path": {
              "type": "object",
              "required": [
                "userId"
              ],
              "properties": {
                "userId": {
                  "type": "string",
                  "description": "Use 'me' for the authenticated user."
                }
              },
              "additionalProperties": false
            },
            "aint_query": {
              "type": "object",
              "properties": {
                "q": {
                  "type": "string",
                  "description": "Gmail search query."
                },
                "labelIds": {
                  "type": "string",
                  "description": "Filter by label IDs."
                },
                "pageToken": {
                  "type": "string",
                  "description": "Page token to retrieve a specific page of results."
                },
                "maxResults": {
                  "type": "integer",
                  "maximum": 500,
                  "description": "Maximum number of messages to return (max 500)."
                },
                "includeSpamTrash": {
                  "type": "boolean",
                  "description": "Include messages from SPAM and TRASH."
                }
              },
              "additionalProperties": false
            }
          },
          "description": "Dynamic inputs for listing Gmail messages.",
          "additionalProperties": false
        },
        "staticInput": {
          "url": {
            "host": [
              "gmail",
              "googleapis",
              "com"
            ],
            "path": [
              "gmail",
              "v1",
              "users",
              "$userId",
              "messages"
            ],
            "protocol": "https"
          },
          "method": "GET"
        }
      },
      "canonical_data": {
        "name": "list_gmail_messages",
        "inputs": {
          "optional": "Query parameters may refine and page results: a Gmail search query string (q) using operators like from:, to:, subject:, label:, newer_than:, older_than:; a string of label IDs (labelIds) to filter by; a pageToken to continue from a prior page; maxResults to limit the page size (default 100, values above 500 are capped); and includeSpamTrash (default false) to include messages from SPAM and TRASH. All provided filters are combined, and pagination continues from the supplied pageToken.",
          "required": [
            "aint_path: An object of path parameters that must be provided and contains the target mailbox identifier for the operation.",
            "aint_path.userId: The user whose Gmail mailbox to list; use 'me' to target the authenticated account. This is necessary to scope the listing to a specific mailbox."
          ]
        },
        "intent": "Enumerate a user's Gmail mailbox messages by returning their identifiers, with optional search and label filtering and pagination, so downstream tools can fetch message details or continue paging.",
        "context": "Results are read-only and idempotent. Pagination is controlled via nextPageToken in the response and pageToken in subsequent requests; for stable pagination, keep all filters constant across calls. Search (q) and labelIds filters are combined. SPAM and TRASH are excluded unless includeSpamTrash is true. maxResults defaults to 100 and any value above 500 is capped. The q string follows Gmail search operators such as from:, to:, subject:, label:, newer_than:, older_than:.",
        "outputs": "A paginated set of minimal message records and pagination metadata: an array where each item contains the message id and its threadId, plus a nextPageToken string to fetch the subsequent page. These identifiers can be used by other tools to retrieve full message or thread details or to perform message/thread-level operations, and nextPageToken can be supplied back as pageToken to continue pagination.",
        "operation": "List Gmail message identifiers",
        "preconditions": "The caller must be authenticated to access the specified user's Gmail mailbox and must provide aint_path with a userId (use 'me' for the authenticated account). If maxResults is provided, it is constrained to 1\u2013500 (values above 500 are capped by the service).",
        "postconditions": "No mailbox state is modified. After successful execution, the caller has a read-only, idempotent list of message identifiers matching the provided filters and, if applicable, a nextPageToken to continue pagination.",
        "business_objects": [
          "Gmail messages",
          "Gmail message identifiers",
          "Gmail threads",
          "Pagination tokens"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    },
    {
      "name": "delete_servicenow_record_in_table_by_sys_id",
      "description": "Delete a servicenow record in table by using record id or sys id",
      "document": {
        "id": "a035d537-8211-4528-9aa2-8f8c315a735f",
        "auth": null,
        "name": "delete_servicenow_record_in_table_by_sys_id",
        "appName": "dev296096service-nowcom",
        "tool_type": "general",
        "transport": "http",
        "description": "Delete a servicenow record in table by using record id or sys id",
        "inputSchema": {
          "type": "object",
          "properties": {
            "aint_path": {
              "type": "object",
              "required": [
                "sys_id",
                "tableName"
              ],
              "properties": {
                "sys_id": {
                  "type": "string",
                  "description": ""
                },
                "tableName": {
                  "type": "string",
                  "description": ""
                }
              }
            },
            "aint_query": {
              "type": "object",
              "properties": {
                "sysparm_query_no_domain": {
                  "description": "True to access data across domains if authorized (default: false)"
                }
              }
            }
          },
          "description": "Delete a record"
        },
        "staticInput": {
          "url": {
            "host": [
              "dev296096",
              "service-now",
              "com"
            ],
            "path": [
              "api",
              "now",
              "table",
              "${tableName}",
              "${sys_id}"
            ],
            "query": {},
            "protocol": "https"
          },
          "method": "DELETE"
        }
      },
      "canonical_data": {
        "name": "delete_servicenow_record_in_table_by_sys_id",
        "inputs": {
          "optional": "Query-level controls may be provided to influence domain access behavior, specifically sysparm_query_no_domain, which when set to true allows cross-domain data access if the caller is authorized (default is false). These options are supplied via the aint_query object and do not change which record is targeted; they only affect domain access eligibility.",
          "required": [
            "sys_id: String identifier of the target ServiceNow record to delete. It uniquely selects which record will be removed and is necessary to perform the deletion against the correct resource.",
            "tableName: String name of the ServiceNow table that contains the target record. It scopes the deletion to the correct table so the sys_id can be resolved to the intended record."
          ]
        },
        "intent": "Remove a specific record from a given ServiceNow table by its unique identifier.",
        "context": "Path parameters (aint_path) carry the tableName and sys_id used to resolve the record to delete. Query parameters (aint_query) may include sysparm_query_no_domain to enable cross-domain access when authorized; its default behavior is false. The tool performs a destructive, non-paginated operation. No output format, pagination, or rate limit details are specified.",
        "outputs": "No response payload is defined in the specification. The operation\u2019s outcome is the deletion of the specified record; consumers should rely on the success of the call rather than a returned object.",
        "operation": "Delete a ServiceNow record by sys_id",
        "preconditions": "The specified ServiceNow instance must be reachable. The caller must have permissions to delete records in the specified table. The provided sys_id must refer to a record within the given table. If sysparm_query_no_domain is used, the caller must be authorized for cross-domain access.",
        "postconditions": "Upon successful execution, the record identified by the given sys_id is removed from the specified ServiceNow table. No other state changes are implied and no response body is guaranteed.",
        "business_objects": [
          "ServiceNow record",
          "ServiceNow table"
        ]
      },
      "tenant": "default",
      "tool_type": "general"
    }
  ]
}